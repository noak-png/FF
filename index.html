<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<meta name="format-detection" content="telephone=no" />
<meta name="msapplication-tap-highlight" content="no" />
<title>Sum-it Forecast - Financial Forecaster</title>

<style>
/* ========== Base Theme Variables ========== */
:root {
  --bg: #f2f2f7; --card: #ffffff; --text: #1c1c1e; --muted: #3a3a3c;
  --accent: #34c759; --ok: #30d158; --danger: #ff3b30; --pending: #e0f2fe; --pending-text: #075985; --pending-border: #bae6fd;
  --paid: #d1fae5; --paid-text: #065f46; --border: #8e8e93;
  --shadow: 0 6px 16px rgba(0,0,0,.08);
  --font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", "Helvetica", "Arial", sans-serif; --font-size: 16px; /* Apple-inspired base font size */
  --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --glass-tint: 255,255,255; --glass-alpha: 0.8; --glass-stroke: rgba(60,60,67,0.29);
  --glass-shadow: 0 2px 8px rgba(0,0,0,.12);   --glass-backdrop-sat: 120%;
  --glass-backdrop-blur: 4px; --slide-duration: 800ms; --slide-ease: cubic-bezier(.22,.61,.36,1);
  --border-radius: 20px; /* Apple-inspired corner radius */
  --glass-shadow-blur: 28px; --glass-shadow-alpha: 0.12; /* NEW: Controllable shadow parts */
  --glass-shadow: 0 8px var(--glass-shadow-blur) rgba(0,0,0,var(--glass-shadow-alpha));
  --calendar-balance-font-size: 6px; /* Calendar balance text size */
  
  /* Bottom navigation variables */
  --nav-bg: var(--card);
  --nav-border: var(--border);
  --nav-icon: var(--muted);
  --nav-icon-active: var(--accent);
  --nav-text: var(--text);
}

/* Light mode specific enhancements for better contrast */
:root:not(.dark) {
  --text: #1a1a1a; /* Slightly darker text for better contrast */
  --muted: #2d2d30; /* Darker muted text */
  --border: #6d6d70; /* Darker borders for better visibility */
}
.dark {
  --bg: #000000; --card: #1c1c1e; --text: #ffffff; --muted: #98989d;
  --accent: #30d158; --ok: #32d74b; --danger: #ff453a; --pending: #1e293b; --pending-text: #7dd3fc; --pending-border: #384252;
  --paid: #064e3b; --paid-text: #a7f3d0; --border: #2c2c2e;
  --shadow: 0 14px 36px rgba(0,0,0,.45); --glass-tint: 15,20,24;
  --glass-alpha: 0.65; --glass-stroke: rgba(255,255,255,0.12);
  --glass-shadow-blur: 32px; --glass-shadow-alpha: 0.35; /* NEW: Dark mode shadow parts */
  --glass-shadow: 0 18px var(--glass-shadow-blur) rgba(0,0,0,var(--glass-shadow-alpha));
  
  /* Dark mode navigation variables */
  --nav-bg: #1c1c1e;
  --nav-border: #2c2c2e;
  --nav-icon: #98989d;
  --nav-icon-active: var(--accent);
  --nav-text: var(--text);
}

/* ========== Global & App Layout ========== */
*{box-sizing:border-box}
html { height: 100%; }
body {
  margin:0; min-height: 100vh; font-family:var(--font-family); font-size:var(--font-size);
  color:var(--text); background:var(--bg); line-height:1.4;
  transition: background .15s ease, color .15s ease;
  background-position:center center; background-repeat:no-repeat; background-size:cover;
  background-attachment:fixed; display: grid; place-items: center; padding: 20px;
}
.glass {
    background: rgba(var(--glass-tint), var(--glass-alpha));
    backdrop-filter: saturate(var(--glass-backdrop-sat)) blur(var(--glass-backdrop-blur));
    -webkit-backdrop-filter: saturate(var(--glass-backdrop-sat)) blur(var(--glass-backdrop-blur));
    border: 1px solid var(--glass-stroke); box-shadow: var(--glass-shadow);
    transform: translateZ(0); /* BUG FIX: Prevents rendering glitches on style change */
}
.app { width:100%; max-width:980px; display:flex; flex-direction:column; gap:20px; z-index: 10; height: calc(100vh - 40px); min-height: 700px; position: relative; }
.title-wrap { width: 100%; padding:10px 16px; border-radius:var(--border-radius); display: flex; justify-content: space-between; align-items: center; background: var(--card); border: 1px solid var(--border); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
.title-wrap h1 { margin:0; font-size:24px; font-weight: 700; display: flex; align-items: center; gap: 10px; color: var(--text); }
.title-wrap h1 svg { width: 26px; height: 26px; fill: var(--accent); }
.header-controls { display: flex; align-items: center; gap: 8px; }
.ctrl-btn { background: var(--card); border: 1px solid var(--border); color: var(--text); padding: 8px; width: 36px; height: 36px; border-radius: calc(var(--border-radius) / 1.5); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
.ctrl-btn:hover { background: rgba(0,0,0,0.05); border-color: var(--text); }
.ctrl-btn.active { background-color: var(--accent); color: white; border-color: var(--accent); }
.ctrl-btn svg { width: 20px; height: 20px; fill: currentColor; }

/* ========== Font Size Control ========== */
.font-size-control {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    background: rgba(var(--glass-tint), var(--glass-alpha));
    backdrop-filter: saturate(var(--glass-backdrop-sat)) blur(var(--glass-backdrop-blur));
    -webkit-backdrop-filter: saturate(var(--glass-backdrop-sat)) blur(var(--glass-backdrop-blur));
    border: 1px solid var(--glass-stroke);
    border-radius: calc(var(--border-radius) / 2);
    color: var(--text);
    font-size: 12px;
    transition: background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease;
}

.font-size-control:hover {
    background: rgba(var(--glass-tint), var(--glass-alpha) + 0.1);
}

.font-size-control input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    outline: none;
}

.font-size-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 1px solid var(--border);
}

.font-size-control input[type="range"]::-moz-range-thumb {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 1px solid var(--border);
}

.font-size-control input[type="range"]::-webkit-slider-track {
    background: var(--border);
    height: 4px;
    border-radius: 2px;
}

.font-size-control input[type="range"]::-moz-range-track {
    background: var(--border);
    height: 4px;
    border-radius: 2px;
    border: none;
}

/* ========== Cards & Grids ========== */
.dashboard-container { display: flex; flex-direction: column; gap: 20px; width: 100%; max-width: 100%; box-sizing: border-box; }
.dashboard-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; width: 100%; max-width: 100%; box-sizing: border-box; }
.card, .summary-card, .finance-card, #expenseTrackerCard { 
  padding: 16px; 
  border-radius: var(--border-radius); 
  text-align: center; 
  display: flex; 
  flex-direction: column;
  background: var(--card);
  border: 1px solid var(--border);
  box-shadow: 0 2px 4px rgba(0,0,0,0.04);
}
.summary-card { justify-content: space-between; }
.card { 
    border-radius: var(--border-radius); 
    width: 100%; 
    max-width: 100%;
    overflow: hidden; 
    padding-bottom: 10px;
    box-sizing: border-box;
    contain: layout;
}
h2, h3 { 
  margin: 0 0 10px; 
  font-size: 16px; 
  color: var(--text); 
  font-weight: 600; 
  opacity: 0.85;
}
.card h2 { padding: 0 4px; }
.card-header { display: flex; justify-content: space-between; align-items: center; margin: -4px -4px 12px; }
.card-header h2 { padding: 0; }
.add-bill-container {
    display: flex;
    justify-content: flex-end;
    padding-right: 25%;
    height: 0;
    position: relative;
    z-index: 20;
    margin-top: -20px; /* Counteracts the parent's 'gap' to fix spacing */
}
.add-bill-header-btn {
    background: var(--accent);
    color: white;
    border: none;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.15s ease, color 0.15s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 28px rgba(0,0,0,.18);
    height: 36px; /* 25% smaller than 48px */
    width: auto;
    padding: 0 18px; /* Proportional padding */
    font-size: 14px;
    border-radius: 999px;
    position: relative;
    transform: translateY(-75%); /* This is the key for the 75% floating effect */
}
.add-bill-header-btn svg {
    width: 14px;
    height: 14px;
}
.add-bill-header-btn:hover {
    background: color-mix(in srgb, var(--accent) 90%, black);
    box-shadow: 0 8px 24px rgba(0,0,0,.18);
}
.link-button { background: transparent; border: none; color: var(--accent); cursor: pointer; font-size: 14px; padding: 8px; font-weight: 600; }
.link-button:hover { text-decoration: underline; }

.card-footer {
    display: none;
    padding: 10px 0 0 0;
    text-align: left;
}
.btn-success {
    background-color: var(--ok);
    color: white;
    border: none;
    padding: 10px 16px;
    font-size: 14px;
    font-weight: 600;
    border-radius: calc(var(--border-radius) / 1.5);
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.btn-success:hover {
    background-color: color-mix(in srgb, var(--ok) 90%, black);
}

.btn-primary {
    background: linear-gradient(180deg, #34c759, #30b957);
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 999px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(52, 199, 89, 0.3);
    text-decoration: none; /* In case it's an anchor tag */
    font-size: 16px;
}

.btn-primary:hover {
      background: linear-gradient(180deg, #30b957, #2ea043);
      box-shadow: 0 4px 12px rgba(52, 199, 89, 0.4);
      transform: translateY(-1px);
    }

    /* iOS-style toggles */
    .ios-toggle-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }

    .ios-toggle-row:last-child {
      border-bottom: none;
    }

    .ios-toggle-row label {
      font-size: 16px;
      color: var(--text);
      margin: 0;
    }

    .ios-toggle {
      position: relative;
      width: 51px;
      height: 31px;
    }

    .ios-toggle-input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .ios-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.2s;
      border-radius: 31px;
    }

    .ios-toggle-slider:before {
      position: absolute;
      content: "";
      height: 27px;
      width: 27px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: 0.2s;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .ios-toggle-input:checked + .ios-toggle-slider {
      background-color: var(--accent);
    }

    .ios-toggle-input:checked + .ios-toggle-slider:before {
      transform: translateX(20px);
    }

    /* Accent color buttons */
    .accent-color-btn {
      transition: all 0.2s ease;
      border: 2px solid var(--border) !important;
    }

    .accent-color-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .accent-color-btn.active {
      border: 3px solid var(--text) !important;
      box-shadow: 0 0 0 2px var(--accent);
    }

    /* Apple-style transitions and motion */
    .card {
      transition: transform 0.25s cubic-bezier(.22,.61,.36,1), box-shadow 0.25s ease;
    }
    
    .card:active {
      transform: scale(0.98);
    }
    
    .modal-overlay.visible {
      animation: fadeIn 0.25s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Spring animations for expanding/collapsing */
    details[open] {
      animation: springSlideDown 0.3s cubic-bezier(.22,.61,.36,1);
    }
    
    @keyframes springSlideDown {
      0% {
        max-height: 0;
        opacity: 0;
        transform: translateY(-8px);
      }
      50% {
        opacity: 0.5;
        transform: translateY(-2px);
      }
      100% {
        max-height: 2000px;
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Smooth button interactions */
    .btn-primary, .ctrl-btn {
      transition: all 0.2s cubic-bezier(.22,.61,.36,1);
    }
    
    .btn-primary:active, .ctrl-btn:active {
      transform: scale(0.96);
    }
    
    /* Smooth input focus transitions */
    input, select, textarea {
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    /* Apple-style alert banners */
    .alert-banner {
      background: rgba(255,255,255,0.95);
      border-radius: 14px;
      padding: 12px 16px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 12px 0;
      border-left: 4px solid var(--accent);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }
    
    .alert-banner.success { 
      border-left: 4px solid #34c759; 
      background: rgba(52,199,89,0.1);
    }
    
    .alert-banner.error { 
      border-left: 4px solid #ff3b30; 
      background: rgba(255,59,48,0.1);
    }
    
    .alert-banner.warning { 
      border-left: 4px solid #ff9500; 
      background: rgba(255,149,0,0.1);
    }
    
    .alert-banner.info { 
      border-left: 4px solid #007aff; 
      background: rgba(0,122,255,0.1);
    }
    
    .alert-banner-icon {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
    }
    
    .alert-banner-content {
      flex: 1;
      font-size: 14px;
      line-height: 1.4;
    }
    
    .alert-banner-close {
      background: none;
      border: none;
      color: var(--muted);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
    }
    
    .alert-banner-close:hover {
      background: rgba(0,0,0,0.1);
    }
    
    /* Dark mode support for alert banners */
    .dark .alert-banner {
      background: rgba(28,28,30,0.95);
      color: var(--text);
    }
    
    .dark .alert-banner.success { 
      background: rgba(52,199,89,0.15);
    }
    
    .dark .alert-banner.error { 
      background: rgba(255,59,48,0.15);
    }
    
    .dark .alert-banner.warning { 
      background: rgba(255,149,0,0.15);
    }
    
    .dark .alert-banner.info { 
      background: rgba(0,122,255,0.15);
    }

    /* Theme preview cards */
    .theme-preview-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-top: 8px;
    }
    
    .theme-preview-card {
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      background: var(--card);
    }
    
    .theme-preview-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    
    .theme-preview-card.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(52,199,89,0.2);
    }
    
    .preview-header {
      height: 20px;
      background: #f2f2f7;
      border-radius: 6px;
      margin-bottom: 6px;
    }
    
    .preview-header.dark {
      background: #1c1c1e;
    }
    
    .preview-header.auto {
      background: linear-gradient(90deg, #f2f2f7 50%, #1c1c1e 50%);
    }
    
    .preview-content {
      padding: 4px 0;
    }
    
    .preview-line {
      height: 8px;
      background: #e5e5ea;
      border-radius: 4px;
      margin-bottom: 4px;
    }
    
    .preview-line.short {
      width: 60%;
    }
    
    .preview-line.dark {
      background: #2c2c2e;
    }
    
    .preview-line.auto {
      background: linear-gradient(90deg, #e5e5ea 50%, #2c2c2e 50%);
    }
    
    .preview-label {
      display: block;
      text-align: center;
      font-size: 11px;
      font-weight: 500;
      color: var(--muted);
      margin-top: 6px;
}

.summary-card .amount { font-size: 36px; font-weight: 700; line-height: 1.1; }
.summary-card .projected-balance { font-size: 12px; color: var(--muted); margin-top: 4px; height: 1.2em; font-weight: 600; }
.summary-card .amount.paid { color: var(--ok); } .summary-card .amount.unpaid { color: var(--danger); } .summary-card .amount.total { color: var(--accent); }

/* Finance Card - default is <details> now */
.finance-card-header {
    display: flex;
    justify-content: center; /* Changed */
    align-items: center;
    width: 100%;
    position: relative; /* Added */
}
.privacy-btn {
    position: absolute;
    right: 16px;
    top: 50%;
    transform: translateY(-50%);
    background: transparent;
    border: none;
    color: var(--muted);
    width: 32px;
    height: 32px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    pointer-events: auto !important; /* Keep this for functionality */
}
.privacy-btn:hover {
    background: rgba(128,128,128,0.15);
    color: var(--text);
}
.privacy-btn svg {
    width: 20px;
    height: 20px;
}
.finance-card .stack.blurred {
    filter: blur(5px);
    pointer-events: none;
    user-select: none;
}
.privacy-blurred {
    filter: blur(5px);
    transition: filter 0.2s ease-in-out;
}
details.finance-card { padding: 16px; text-align: left; }
details.finance-card > summary {
    font-size: 14px;
    color: var(--muted);
    font-weight: 600;
    margin: -16px -16px 10px;
    padding: 16px;
    padding-bottom: 10px;
    list-style: none;
    cursor: pointer;
}
details.finance-card > summary::-webkit-details-marker { display: none; }
#billTrackerCard > summary {
    font-size: 14px;
    color: var(--muted);
    font-weight: 600;
    margin: -16px -16px 10px;
    padding: 16px;
    padding-bottom: 10px;
    list-style: none;
    cursor: pointer;
    background: rgba(128,128,128,0.05);
}
#billTrackerCard > summary::-webkit-details-marker { display: none; }
.finance-card .finance-row { display: grid; grid-template-columns: max-content 1fr; gap: 12px; align-items: center; }
.finance-card label { font-weight: 600; font-size: 13px; text-align: right; }
.finance-card input, .finance-card select, #expenseTrackerCard input, #expenseTrackerCard select { flex-grow: 1; padding: 8px 10px; border: 1px solid var(--border); border-radius: calc(var(--border-radius) / 2); background: var(--card); color: var(--text); font-size: 14px; width: 100%; min-width: 0; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
#expenseTrackerCard form { display: flex; flex-direction: column; gap: 10px; margin-top: auto; }
#expenseTrackerCard button { background: var(--accent); color: white; border: none; padding: 10px; border-radius: calc(var(--border-radius) / 2); font-weight: 600; cursor: pointer; }

/* Pending & 30-Day Bills */
#pendingBillsList, #next30DaysList { display: flex; flex-direction: column; gap: 8px; flex-grow: 1; overflow-y: auto; padding-right: 5px; min-height: 80px; }
#next30DaysList { max-height: 207px; /* Approx 4 items */ }
#pendingBillsList { max-height: 95px; }
.upcoming-item { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  background: var(--card); 
  border: 1px solid var(--border);
  padding: 6px 10px; 
  border-radius: calc(var(--border-radius) / 2); 
  transition: all 0.2s ease;
}
.upcoming-item:hover {
  background: rgba(0,0,0,0.05);
}
.dark .upcoming-item:hover {
  background: rgba(255,255,255,0.1);
}
.upcoming-item .name { font-weight: 600; font-size: 14px; }
.upcoming-item .details { font-size: 13px; text-align: right; }
.upcoming-item .amount { font-weight: 700; font-family: var(--font-mono); }
.upcoming-item .countdown { color: var(--muted); font-size: 11px; }

/* Add Bill Form & Bill List Table */
details#billTrackerCard { /* flex: 1 1 auto; min-height: 0; */ }
.bill-table-wrapper { width: 100%; max-width: 100%; overflow-y: auto; flex-grow: 1; box-sizing: border-box; }
.bill-table-wrapper.scrollable {
    max-height: 300px; /* Approx height of 4-5 rows */
    overflow-y: auto;
    padding-right: 5px;
}
details#addBillSection > summary { 
  list-style: none; 
  cursor: pointer; 
  font-weight: 600; 
  padding: 12px 16px; 
  border-bottom: 1px solid var(--border); 
  margin: -16px -16px 16px; 
  background: var(--card); 
  border: 1px solid var(--border);
  border-radius: var(--border-radius) var(--border-radius) 0 0;
}
details#addBillSection > summary::-webkit-details-marker { display: none; }
.add-bill-form { display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 10px; padding: 0 16px 16px; border-bottom: 1px solid var(--border); align-items: center; }
#billNotes { grid-column: 1 / -1; } #addBtn { grid-column: 1 / -1; }
#splitBillInputs { grid-column: 1 / -1; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 6px; }
.add-bill-form input, .add-bill-form select { 
  padding: 12px 14px; 
  border: 1px solid var(--border); 
  border-radius: 12px; 
  background: var(--card); 
  color: var(--text); 
  outline: none; 
  font-size: 16px; 
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}
.add-bill-form input:focus, .add-bill-form select:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(52,199,89,0.2);
}
.add-bill-form button { padding: 10px 14px; border: none; background: var(--accent); color: white; border-radius: calc(var(--border-radius) / 1.5); cursor: pointer; font-weight: 600; }
table.bill-table { width: 100%; max-width: 100%; border-collapse: collapse; text-align: left; box-sizing: border-box; }
table.bill-table th, table.bill-table td { padding: 14px 18px; font-size: 14px; }
table.bill-table tbody tr { cursor: pointer; border-bottom: 1px dashed var(--border); }
.bill-details-cell { line-height: 1.3; }
.bill-name { font-weight: 600; }
.bill-sub-details { display: flex; gap: 8px; margin-top: 4px; }
.bill-category-badge, .bill-frequency-badge { font-size: 10px; padding: 2px 8px; border-radius: 999px; background: var(--bg); border: 1px solid var(--border); color: var(--muted); font-weight: 500;}
.split-info-icon { font-size: 11px; margin-left: 6px; color: var(--muted); border: 1px solid; padding: 1px 4px; border-radius: 6px; }
.bill-notes {
    font-size: 13px;
    color: var(--muted);
    white-space: pre-wrap; /* Allow wrapping */
    word-break: break-word; /* Break long words */
    max-height: 60px; /* Limit height to about 3-4 lines */
    overflow-y: auto; /* Add scroll for longer notes */
    padding: 4px 8px;
    background-color: rgba(128,128,128,0.05);
    border-radius: 6px;
    line-height: 1.4;
}
.bill-amount-cell .bill-amount { font-weight: 700; }
.bill-amount-cell .split-info-total { font-size: 11px; color: var(--muted); display: block; }
tr.paid { background-color: color-mix(in srgb, var(--ok) 8%, transparent); color: var(--paid-text); }
tr.paid td { box-shadow: inset 0 1px 0 0 var(--ok), inset 0 -1px 0 0 var(--ok); }
tr.paid td:first-child { box-shadow: inset 1px 1px 0 0 var(--ok), inset 0 -1px 0 0 var(--ok); border-radius: calc(var(--border-radius) / 2) 0 0 calc(var(--border-radius) / 2);}
tr.paid td:last-child { box-shadow: inset -1px 1px 0 0 var(--ok), inset 0 -1px 0 0 var(--ok); border-radius: 0 calc(var(--border-radius) / 2) calc(var(--border-radius) / 2) 0;}
tr.paid .split-info-total, tr.paid .split-info-icon, tr.paid .bill-category-badge, tr.paid .bill-frequency-badge { color: var(--paid-text); border-color: currentColor; background: transparent; }
.date-box { text-align: center; border-radius: calc(var(--border-radius) / 2); padding: 6px; width: 56px; flex-shrink: 0; border: 1px solid var(--border); }
.date-box .month { font-size: 11px; font-weight: 600; text-transform: uppercase; display: block; background-color: var(--accent); color: white; border-radius: 6px 6px 0 0; margin: -6px -6px 3px; padding: 3px; }
tr.paid .date-box .month { background-color: var(--ok); }

tr.pending { background-color: color-mix(in srgb, var(--pending) 8%, transparent); color: var(--pending-text); }
tr.pending td { box-shadow: inset 0 1px 0 0 var(--pending-border), inset 0 -1px 0 0 var(--pending-border); }
tr.pending td:first-child { box-shadow: inset 1px 1px 0 0 var(--pending-border), inset 0 -1px 0 0 var(--pending-border); border-radius: calc(var(--border-radius) / 2) 0 0 calc(var(--border-radius) / 2);}
tr.pending td:last-child { box-shadow: inset -1px 1px 0 0 var(--pending-border), inset 0 -1px 0 0 var(--pending-border); border-radius: 0 calc(var(--border-radius) / 2) calc(var(--border-radius) / 2) 0;}
tr.pending .split-info-total, tr.pending .split-info-icon, tr.pending .bill-category-badge, tr.pending .bill-frequency-badge { color: var(--pending-text); border-color: currentColor; background: transparent; }
tr.pending .date-box .month { background-color: var(--pending-text); color: var(--pending); }

.date-box .day { font-size: 22px; font-weight: 700; line-height: 1; display: block; }
.date-info { display: flex; align-items: center; justify-content: center; font-size: 11px; line-height: 1.3; width: 56px; }
.due-date-cell { padding: 8px 12px !important; width: 120px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; }
.countdown.overdue { color: var(--danger); font-weight: 600; }
.countdown.paid { color: var(--ok); font-weight: 600; }
.countdown.pending { color: var(--pending-text); font-weight: 600; }
.countdown { font-size: 10px; line-height: 1.3; text-align: center; white-space: nowrap; }

.actions-cell { text-align: right; white-space: nowrap; cursor: default; width: 1%; }
.actions-cell button { margin-left: 8px; }

/* Action Button Styling for Desktop & Mobile consistency */
.actions-cell button, .mobile-bill-actions button {
    border: none;
    padding: 6px 12px;
    border-radius: calc(var(--border-radius) / 2);
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    color: white;
    transition: background-color 0.15s ease;
}
.actions-cell button:hover, .mobile-bill-actions button:hover {
    /* Removed transform for better performance */
}
.actions-cell .details-btn, .mobile-bill-actions .details-btn { background-color: var(--accent); }
.actions-cell .pay-btn, .mobile-bill-actions .pay-btn { background-color: var(--ok); }
.actions-cell .pending-btn, .mobile-bill-actions .pending-btn { background-color: var(--pending-text); color: var(--pending); }
.dark .actions-cell .pending-btn, .dark .mobile-bill-actions .pending-btn { background-color: var(--pending-border); color: var(--pending-text); }
.actions-cell .unpay-btn, .mobile-bill-actions .unpay-btn { background-color: var(--muted); }
.actions-cell .remove-btn, .mobile-bill-actions .remove-btn { background-color: var(--danger); }

/* Default state for buttons inside a row */
.actions-cell .details-btn,
.actions-cell .unpay-btn,
.actions-cell .pay-btn,
.actions-cell .pending-btn {
    display: none;
}
/* Show buttons based on row status */
tr .details-btn { display: inline-block; }
tr.unpaid .pay-btn,
tr.unpaid .pending-btn { display: inline-block; }
tr.pending .pay-btn,
tr.pending .unpay-btn { display: inline-block; }
tr.paid .unpay-btn { display: inline-block; }

.no-bills-message { padding: 40px; text-align: center; color: var(--muted); }
#pastBillsCard > summary { 
    color: var(--muted); 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    list-style: none; 
    cursor: pointer; 
    font-weight: 600; 
    padding: 16px; 
    padding-bottom: 10px; 
    margin: -16px -16px 10px; 
    background: rgba(128,128,128,0.05); 
}
#pastBillsCard > summary::-webkit-details-marker { display: none; }
#pastBillsCard[open] { padding-bottom: 16px; }
#pastBillsCard .bill-table-wrapper {
    /* overflow: hidden; */ /* REMOVED FOR SCROLL FIX */
}

/* ========== Dropdown Cards Styles ========== */
#pendingBillsCard > summary,
#next30DaysCard > summary,
#recurringPaymentManagerCard > summary {
    color: var(--muted);
    display: flex;
    justify-content: center;
    align-items: center;
    list-style: none;
    font-weight: 600;
    font-size: 16px;
    padding: 16px;
    padding-bottom: 10px;
    margin: -16px -16px 10px;
    background: rgba(128,128,128,0.05);
    cursor: pointer;
}

#pendingBillsCard > summary::-webkit-details-marker,
#next30DaysCard > summary::-webkit-details-marker,
#recurringPaymentManagerCard > summary::-webkit-details-marker {
    display: none;
}

#pendingBillsCard[open],
#next30DaysCard[open],
#recurringPaymentManagerCard[open] {
    padding-bottom: 16px;
}

/* Desktop behavior - make dropdown cards behave like Past Bills */
@media (min-width: 769px) {
    #pendingBillsCard > summary,
    #next30DaysCard > summary,
    #recurringPaymentManagerCard > summary {
        pointer-events: none;
        cursor: default;
    }
    #pendingBillsCard > summary::-webkit-details-marker,
    #next30DaysCard > summary::-webkit-details-marker,
    #recurringPaymentManagerCard > summary::-webkit-details-marker {
        display: none;
    }
}

/* ========== The Tab Feature ========== */
#theTabCard > summary {
    font-size: 16px;
    color: var(--text);
    font-weight: 600;
    margin: -16px -16px 10px;
    padding: 16px;
    padding-bottom: 10px;
    list-style: none;
    cursor: pointer;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--border-radius) var(--border-radius) 0 0;
    opacity: 0.85;
}
#theTabCard > summary::-webkit-details-marker {
    display: none;
}
.debt-content-wrapper { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; flex-grow: 1; }
.debt-list { display: flex; flex-direction: column; gap: 8px; max-height: 220px; overflow-y: auto; padding-right: 5px; }
.debt-item { 
  display: grid; 
  grid-template-columns: 1fr auto; 
  gap: 10px; 
  align-items: center; 
  padding: 10px; 
  background: var(--card); 
  border: 1px solid var(--border);
  border-radius: calc(var(--border-radius) / 2); 
  border-left: 3px solid var(--accent); 
  transition: all 0.2s ease;
}
.debt-item:hover {
  background: rgba(0,0,0,0.05);
}
.dark .debt-item:hover {
  background: rgba(255,255,255,0.1);
}
.debt-item.satisfied { border-left-color: var(--ok); opacity: 0.7; }
.debt-item.satisfied .debt-details { text-decoration: line-through; }
.debt-details { display: flex; flex-direction: column; gap: 2px; }
.debt-details .debt-name { font-weight: 600; }
.debt-details .debt-subtext { font-size: 12px; color: var(--muted); }
.debt-actions button {
    border: none;
    padding: 6px 12px;
    margin-left: 4px;
    border-radius: calc(var(--border-radius) / 2);
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    color: white;
    transition: background-color 0.15s ease;
}
.debt-actions button:hover {
    /* Removed transform for better performance */
}
.debt-actions .pay-btn { background-color: var(--ok); }
.debt-actions .remove-btn { background-color: var(--danger); }
.debt-item .unpaid-btn { display: none; }
.debt-item.satisfied .pay-btn { display: none; }
.debt-item.satisfied .unpaid-btn { display: inline-block; background-color: var(--pending-text); }
.debt-item.satisfied .remove-btn { 
    background-color: var(--accent); 
    position: relative;
}
.debt-item.satisfied .remove-btn:hover::after {
    content: 'Archive or Remove';
    position: absolute;
    bottom: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--text);
    color: var(--bg);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    z-index: 1000;
}
.debt-form-container form { display: flex; flex-direction: column; gap: 10px; }
.debt-form-container h3 { text-align: left; }
.debt-form-container input, .debt-form-container textarea { 
  width: 100%; 
  padding: 12px 14px; 
  border: 1px solid rgba(60,60,67,0.29); 
  border-radius: 12px; 
  background: #fff; 
  color: var(--text); 
  font-size: 16px; 
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
.debt-form-container input:focus, .debt-form-container textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(52,199,89,0.2);
  outline: none;
}
.debt-form-container textarea { resize: vertical; min-height: 40px; }
.debt-form-container button { background: var(--accent); color: white; border: none; padding: 10px; border-radius: calc(var(--border-radius) / 2); font-weight: 600; cursor: pointer; }

/* ========== Archive View & Filters ========== */
#archive-filters { padding: 16px; border-bottom: 1px solid var(--border); margin-bottom: 10px; }
#archive-filters summary { list-style: none; cursor: pointer; font-weight: 600; }
#archive-filters summary::-webkit-details-marker { display: none; }
.filter-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-top: 12px; }
.filter-grid label { display: flex; flex-direction: column; text-align: left; font-size: 12px; font-weight: 600; color: var(--muted); }
.filter-grid input, .filter-grid select { 
  margin-top: 4px; 
  padding: 12px 14px; 
  border: 1px solid rgba(60,60,67,0.29); 
  border-radius: 12px; 
  background: #fff; 
  color: var(--text); 
  font-size: 16px;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
.filter-grid input:focus, .filter-grid select:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(52,199,89,0.2);
  outline: none;
}


/* ========== Calendar View ========== */
#calendarView { padding: 0; }
.calendar-header { display: flex; justify-content: space-between; align-items: center; margin: 12px 0 16px 0; padding: 0 8px; }
.calendar-header button { background: none; border: 1px solid var(--border); border-radius: calc(var(--border-radius) / 2); cursor: pointer; width: 36px; height: 36px; flex-shrink: 0; }
.calendar-header h2 { position: absolute; left: 50%; transform: translateX(-50%); margin: 0; }
.calendar-grid-container { display: grid; grid-template-columns: repeat(7, 1fr); gap: 1px; background-color: var(--border); border: 1px solid var(--border); border-radius: 0; overflow: hidden; }
.calendar-day-name { text-align: center; font-weight: 600; font-size: 12px; padding: 8px 4px; background: var(--bg); color: var(--muted); }
.calendar-day { background: var(--card); min-height: 120px; padding: 4px; font-size: 12px; display: flex; flex-direction: column; justify-content: space-between; cursor: pointer; position: relative; }
.calendar-day.other-month { visibility: hidden; }
.day-number { font-weight: 600; text-align: left; }
.calendar-day.today {
    box-shadow: inset 0 0 0 2px #3b82f6; /* A nice, modern blue for highlighting the current day */
}
.calendar-day.today .day-number {
    /* The green oval was removed as per user request */
}
.day-balance { font-size: var(--calendar-balance-font-size); font-weight: 700; color: var(--accent); }
.day-balance.negative { color: var(--danger); font-size: var(--calendar-balance-font-size); }
.day-balance.positive { color: var(--ok); font-size: var(--calendar-balance-font-size); }
.day-balance-container { text-align: right; min-height: 3.5em; display: flex; flex-direction: column; justify-content: flex-end; align-items: flex-end; gap: 1px; }
.bills-on-day {
    display: flex;
    flex-direction: column;
    gap: 4px;
    justify-content: flex-start;
    align-items: center;
    flex-grow: 1;
    padding-top: 4px;
}
.day-bill-count {
    background: var(--accent);
    color: white;
    font-size: 10px;
    font-weight: 700;
    min-width: 16px;
    height: 16px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    border: 1px solid rgba(255,255,255,0.2);
    padding: 0 4px;
    position: absolute;
    top: 8px;
    right: 8px;
    z-index: 10;
}

/* Payment notification pill */
.day-bill-count.payment-notification {
    background: #ff9500;
    box-shadow: 0 2px 4px rgba(255, 149, 0, 0.3);
}

.day-bill-count.prepaid {
    background: #af52de;
    box-shadow: 0 2px 4px rgba(175, 82, 222, 0.3);
}
.bills-on-day {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

.bills-on-day .day-bill-count {
    position: absolute;
    top: 25%;
    left: 25%;
    transform: translate(-50%, -50%);
    margin: 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    border: 1px solid rgba(255,255,255,0.2);
}

/* Bubble arrangement in a plus sign shape */
.bills-on-day .day-bill-count:nth-child(1) {
    transform: translate(-50%, -50%);
    z-index: 1;
}
.bills-on-day .day-bill-count:nth-child(2) {
    transform: translate(-50%, -90%);
    z-index: 2;
}
.bills-on-day .day-bill-count:nth-child(3) {
    transform: translate(-50%, -10%);
    z-index: 3;
}
.bills-on-day .day-bill-count:nth-child(4) {
    transform: translate(-90%, -50%);
    z-index: 4;
}
.bills-on-day .day-bill-count:nth-child(5) {
    transform: translate(-10%, -50%);
    z-index: 5;
}

/* Removed expensive hover effects for better performance */
.bills-on-day:hover .day-bill-count:nth-child(1),
.bills-on-day:hover .day-bill-count:nth-child(2),
.bills-on-day:hover .day-bill-count:nth-child(3),
.bills-on-day:hover .day-bill-count:nth-child(4),
.bills-on-day:hover .day-bill-count:nth-child(5) {
    /* Removed transforms for better performance */
}
.bill-item-calendar { font-size: 11px; padding: 2px 6px; border-radius: 6px; background-color: var(--accent); color: white; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.bill-item-calendar.expense { background-color: var(--muted); }
.bill-item-calendar.paid {
    background-color: var(--ok);
    text-decoration: line-through;
}
.bill-item-calendar.prepaid {
    background-color: #8b5cf6;
    color: white;
}

/* ========== Edit & Add Bill Modals ========== */
.modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: grid; place-items: center; opacity: 0; visibility: hidden; transition: opacity .15s ease, visibility .15s; }
.modal-overlay.visible { opacity: 1; visibility: visible; }
.modal-content { width: 90%; max-width: 500px; padding: 24px; border-radius: var(--border-radius); transform: scale(0.95); transition: transform .15s ease; }
.modal-overlay.visible .modal-content { transform: scale(1); }
.modal-content h2 { margin-top: 0; }
.modal-form, .modal-content form.add-bill-form { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
.modal-form label, .modal-content form.add-bill-form label { font-weight: 600; font-size: 14px; text-align: left; grid-column: 1 / -1; margin-bottom: -8px; }
.modal-form .full-width, .modal-content form.add-bill-form .full-width { grid-column: 1 / -1; }
.modal-form input, .modal-form select, .modal-form textarea, .modal-content form.add-bill-form input, .modal-content form.add-bill-form select { width: 100%; padding: 8px 10px; border: 1px solid var(--border); border-radius: calc(var(--border-radius) / 2); background: var(--card); color: var(--text); box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
.modal-form textarea { resize: vertical; min-height: 80px; }
.modal-buttons { display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px; grid-column: 1 / -1; }
.modal-buttons button { padding: 10px 16px; border: none; border-radius: calc(var(--border-radius) / 2); font-weight: 600; cursor: pointer; }
.modal-buttons .save-btn { background: var(--accent); color: white; }
.modal-buttons .cancel-btn { background: var(--bg); color: var(--text); border: 1px solid var(--border); }
.modal-buttons .danger-btn { background: var(--danger); color: white; }
.modal-buttons .special-btn { background: var(--pending-text); color: var(--pending); }
#genericModalContent input {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border);
    border-radius: calc(var(--border-radius) / 1.5);
    background: var(--bg);
    color: var(--text);
    outline: none;
    font-size: 16px;
    margin-top: 8px;
}


#dayBreakdownContent ul {
    list-style: none;
    padding: 0;
    margin: 0;
}
#dayBreakdownContent li {
    padding: 8px 0;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
}
#dayBreakdownContent li:last-child {
    border-bottom: none;
}
#dayBreakdownContent h3 {
    margin-top: 16px;
    margin-bottom: 8px;
}
#dayBreakdownContent ul.day-breakdown-list {
    list-style: none;
    padding: 0;
    margin: 10px 0 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
#dayBreakdownContent ul.day-breakdown-list li {
    padding: 10px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: calc(var(--border-radius) / 2);
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: none;
    transition: all 0.2s ease;
}
#dayBreakdownContent ul.day-breakdown-list li:hover {
    background: rgba(0,0,0,0.05);
}
.dark #dayBreakdownContent ul.day-breakdown-list li:hover {
    background: rgba(255,255,255,0.1);
}
.modal-bill-details {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 600;
}
.modal-bill-amount {
    font-weight: 700;
    font-family: var(--font-mono);
}
.status-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
}
.status-indicator.status-paid { background-color: var(--ok); }
.status-indicator.status-unpaid { background-color: var(--danger); }
.status-indicator.status-pending { background-color: var(--pending-text); }
.status-indicator.status-expense { background-color: var(--muted); }
.status-indicator.status-income { background-color: var(--accent); }
.status-indicator.status-prepaid { background-color: #8b5cf6; }
.modal-bill-actions {
    display: flex;
    gap: 6px;
}
.modal-bill-actions button {
    border: none;
    padding: 4px 8px;
    border-radius: calc(var(--border-radius) / 2.5);
    cursor: pointer;
    font-size: 11px;
    font-weight: 600;
    color: white;
    transition: background-color 0.15s ease;
}
.modal-bill-actions button:hover {
    /* Removed transform for better performance */
}
.modal-bill-actions .pay-btn { background-color: var(--ok); }
.modal-bill-actions .pending-btn { background-color: var(--pending-text); color: var(--pending); }
.dark .modal-bill-actions .pending-btn { background-color: var(--pending-border); color: var(--pending-text); }
.modal-bill-actions .unpay-btn { background-color: var(--muted); }
.modal-bill-actions .dismiss-btn { background-color: var(--danger); }
.modal-bill-actions .details-btn { background-color: var(--accent); padding: 5px 10px; }

/* ========== Natural Slide Animations ========== */
/* Simple, clean details animations - fixed width */
details {
    width: 100%;
    box-sizing: border-box;
}

details[open] {
    animation: smoothSlideDown 0.15s ease-out;
}

@keyframes smoothSlideDown {
    from {
        max-height: 0;
        opacity: 0;
    }
    to {
        max-height: 2000px;
        opacity: 1;
    }
}

/* Legacy table row animations (kept for compatibility) */
tr.slide-enter { opacity:0; transform:translateY(10px); }
tr.slide-enter-active { transition: opacity var(--slide-duration) var(--slide-ease), transform var(--slide-duration) var(--slide-ease); opacity:1; transform:translateY(0); }
tr.slide-out { transition: opacity calc(var(--slide-duration) / 2) ease, transform calc(var(--slide-duration) / 2) ease; opacity:0; transform:translateX(14px); }
tr.collapsing { overflow:hidden; height:0 !important; padding-top:0 !important; padding-bottom:0 !important; margin:0 !important; border:0 !important; transition: height var(--slide-duration) var(--slide-ease) !important; }

/* ========== Settings Menu (Condensed) ========== */
#ambianceCanvas{ 
    position:fixed; 
    top:0; 
    left:0; 
    width:100vw; 
    height:100vh; 
    pointer-events:none; 
    z-index: 5; 
}
.menu-panel{ position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); border-radius:var(--border-radius); padding:14px; width:540px; display:none; z-index:1100; max-height:calc(100vh - 100px); overflow:auto; }
.menu-panel .section, .sub-section { border:1px solid var(--border); border-radius: calc(var(--border-radius) / 1.5); overflow:hidden; margin-top: 10px; }
.menu-panel summary{ 
  list-style:none; 
  cursor:pointer; 
  padding:12px 14px; 
  display:flex; 
  align-items:center; 
  justify-content:space-between; 
  font-weight:700; 
  background: var(--card); 
  border: 1px solid var(--border);
  border-radius: 8px; 
}
.sub-section summary { 
  font-weight: 600; 
  font-size: 14px; 
  background: var(--card); 
  border: 1px solid var(--border);
  padding: 10px 12px; 
}
.menu-panel .content{ padding:10px 12px 14px; border-top:1px solid var(--border); display:flex; flex-direction:column; gap:10px; }
.slider-row{ display:flex; align-items:center; gap:10px; } .slider-row label{ min-width:148px; } .slider-row input[type=range]{ flex:1; }
.pct{ min-width:48px; text-align:right; font-size:12px; color:var(--muted); }
.shadow-cue { /* NEW */
    width: 50px; height: 30px; border-radius: 5px; background: var(--card); border: 1px solid var(--border);
    transition: box-shadow 0.1s ease-in-out;
}
.menu-notch{
  position:sticky; bottom:0;
  display:flex; flex-direction:column; justify-content:center; align-items:center;
  padding:12px 0 2px; margin-top:8px; gap:8px;
}
.menu-notch button{ border:none; cursor:pointer; font-weight:600; padding:12px 16px; border-radius:999px; background:var(--card); color:var(--text); border:1px solid var(--border); box-shadow:var(--shadow); }
.stack{ display:flex; flex-direction:column; gap:8px; } .hr{ border:none; border-top:1px solid var(--border); margin:6px 0; }
#resetProfileBtn { background-color: var(--danger); color: white; } /* NEW */

/* ========== Organizational Sections Styles ========== */
.dashboard-section-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: var(--card);
    border-radius: calc(var(--border-radius) / 2);
    border: 1px solid var(--border);
    transition: all 0.2s ease;
}
.dashboard-section-item:hover {
    background: rgba(0,0,0,0.05);
    transform: translateY(-1px);
}
.dark .dashboard-section-item:hover {
    background: rgba(255,255,255,0.1);
}
.section-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
}
.section-name {
    font-weight: 600;
    font-size: 14px;
    color: var(--text);
}
.section-description {
    font-size: 12px;
    color: var(--muted);
}
.section-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}
.section-toggle {
    position: relative;
    width: 44px;
    height: 24px;
    background: var(--border);
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.2s ease;
}
.section-toggle.active {
    background: var(--accent);
}
.section-toggle::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
    transition: transform 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
.section-toggle.active::after {
    transform: translateX(20px);
}

/* Utility toggle styles */
.utility-toggle {
    position: relative;
    width: 44px;
    height: 24px;
    background: var(--border);
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.2s ease;
    flex-shrink: 0;
}

.utility-toggle.active {
    background: var(--accent);
}

.utility-toggle::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
    transition: transform 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.utility-toggle.active::after {
    transform: translateX(20px);
}

.utility-toggle-label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    margin: 8px 0;
}

.utility-toggle-label:hover .utility-toggle {
    background: var(--muted);
}

.utility-toggle-label:hover .utility-toggle.active {
    background: var(--accent);
    opacity: 0.8;
}

.order-controls {
    display: flex;
    flex-direction: column;
    gap: 2px;
}
.order-btn {
    width: 20px;
    height: 16px;
    border: none;
    background: var(--card);
    color: var(--text);
    border-radius: 3px;
    cursor: pointer;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    border: 1px solid var(--border);
}
.order-btn:hover {
    background: var(--accent);
    color: white;
    transform: scale(1.1);
}
.order-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

/* Required section toggle styles */
.section-toggle.required {
    background: var(--accent) !important;
    cursor: not-allowed !important;
    opacity: 0.8;
}

.section-toggle.required::after {
    background: white;
    transform: translateX(20px);
}

.section-toggle.required:hover {
    transform: none !important;
    box-shadow: none !important;
}

/* Enhanced drag and drop styles */
.dragging-active {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.dragging-active .dashboard-section-item:not(.dragging) {
    opacity: 0.6;
    transition: opacity 0.2s ease;
}

.dashboard-section-item.dragging {
    opacity: 0.8;
    transform: rotate(2deg) scale(1.02);
    z-index: 1000;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
}

.section-drag-handle {
    cursor: grab;
    color: var(--muted);
    font-size: 16px;
    padding: 8px;
    border-radius: 4px;
    transition: all 0.2s ease;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    touch-action: none;
}

.section-drag-handle:hover {
    color: var(--text);
    background: rgba(128,128,128,0.1);
    transform: scale(1.1);
}

.section-drag-handle:active {
    cursor: grabbing;
    background: rgba(128,128,128,0.2);
    transform: scale(0.95);
}

/* Mobile-specific drag handle improvements */
@media (max-width: 768px) {
    .section-drag-handle {
        padding: 12px;
        font-size: 18px;
        min-width: 44px;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .section-drag-handle:hover {
        transform: none;
    }
    
    .section-drag-handle:active {
        transform: scale(0.9);
    }
}

/* Settings menu touch isolation */
.menu-panel {
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.menu-panel * {
    touch-action: manipulation;
}

/* Screen lock when menu is open */
body.menu-open {
    overflow: hidden !important;
    position: fixed !important;
    width: 100% !important;
    height: 100% !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
}

html.menu-open {
    overflow: hidden !important;
    position: fixed !important;
    width: 100% !important;
    height: 100% !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
}

/* Ensure menu panel is always on top when open */
.menu-panel {
    position: fixed !important;
    z-index: 9999 !important;
    pointer-events: auto !important;
}

/* Ensure menu panel is interactive */
.menu-panel {
    pointer-events: auto !important;
}

.menu-panel * {
    pointer-events: auto !important;
}

/* Backdrop overlay styling */
#menuBackdrop {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    z-index: 9998 !important;
    pointer-events: auto !important;
}

/* Ensure menu button remains clickable */
.menu-btn {
    z-index: 10000 !important;
    pointer-events: auto !important;
    position: relative !important;
}

/* Ensure organizational sections list is touch-friendly */
#dashboardSectionsList {
    touch-action: manipulation;
    -webkit-overflow-scrolling: touch;
}

/* Profile items styling */
.profile-item {
    width: 100%;
    margin-bottom: 8px;
}

.profile-item:last-child {
    margin-bottom: 0;
}

.profile-info {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    border-radius: var(--border-radius);
    background: var(--card);
    transition: all 0.2s ease;
}

.profile-info:hover {
    background: var(--card-hover);
}

.profile-name {
    font-size: 14px;
    font-weight: 500;
    color: var(--text);
}

    .profile-current .profile-info {
        position: relative;
        box-shadow: inset 0 0 20px rgba(0, 191, 255, 0.4);
        animation: profileGlow 3s ease-in-out infinite alternate;
    }
    
    @keyframes profileGlow {
        0% {
            box-shadow: inset 0 0 15px rgba(0, 191, 255, 0.3);
        }
        100% {
            box-shadow: inset 0 0 25px rgba(0, 191, 255, 0.6);
        }
    }

.profile-current .profile-name {
    color: var(--accent);
    font-weight: 700;
}

    .profile-name-container {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .profile-name {
        font-size: 14px;
        font-weight: 500;
        color: var(--text);
    }
    
    .profile-active-indicator {
        position: absolute;
        bottom: 4px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        animation: activeBreathing 3s ease-in-out infinite alternate;
    }
    
    @keyframes activeBreathing {
        0% {
            color: #000000;
            opacity: 0.7;
        }
        100% {
            color: #00bfff;
            opacity: 1;
        }
    }

.profile-delete-btn {
    color: #ff4444 !important;
}

    .profile-delete-btn:hover {
        background: rgba(255, 68, 68, 0.1) !important;
    }
    
    .profile-creation-options {
        margin-top: 8px;
        padding: 8px;
        background: rgba(var(--accent-rgb), 0.05);
        border-radius: 8px;
        border: 1px solid rgba(var(--accent-rgb), 0.2);
    }
    
    .profile-creation-options .profile-option-btn {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        margin-bottom: 4px;
        background: rgba(var(--accent-rgb), 0.1);
        border: 1px solid rgba(var(--accent-rgb), 0.3);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 13px;
    }
    
    .profile-creation-options .profile-option-btn:last-child {
        margin-bottom: 0;
    }
    
    .profile-creation-options .profile-option-btn:hover {
        background: rgba(var(--accent-rgb), 0.2);
        border-color: var(--accent);
    }
    
    .profile-creation-options .option-icon {
        font-size: 14px;
    }
    
    .profile-creation-options .option-text {
        color: var(--text);
        font-weight: 500;
    }

.profile-menu-btn {
    background: none;
    border: none;
    color: var(--muted);
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    transition: all 0.2s ease;
    line-height: 1;
}

.profile-menu-btn:hover {
    color: var(--accent);
    background: rgba(var(--accent-rgb), 0.1);
}

.profile-options {
    margin-top: 8px;
    padding: 8px 0;
    border-top: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.profile-option-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    cursor: pointer;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    font-size: 14px;
    color: var(--text);
    transition: background-color 0.2s ease;
    border-radius: 4px;
}

.profile-option-btn:hover {
    background: rgba(128, 128, 128, 0.1);
}

.option-icon {
    font-size: 16px;
    width: 20px;
    text-align: center;
}

.option-text {
    flex: 1;
    font-size: 13px;
    font-weight: 500;
    color: var(--text);
}

.add-profile {
    margin-top: 8px;
}

.add-profile-btn {
    width: 100%;
    padding: 12px 16px;
    border: 1px solid var(--border);
    border-radius: var(--border-radius);
    background: var(--card);
    color: var(--text);
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
}

.add-profile-btn:hover {
    border-color: var(--accent);
    background: var(--card-hover);
    color: var(--accent);
}

#dashboardSectionsList .dashboard-section-item {
    touch-action: manipulation;
}

/* ========== Recurring Payment Manager Styles ========== */

#recurringPaymentManagerCard[open] {
    min-height: 300px;
    max-height: none;
    contain: layout style;
}

/* Ensure proper collapse behavior */
#recurringPaymentManagerCard:not([open]) {
    min-height: auto;
    height: auto;
}

/* Override text-align for closed state to match other cards */
#recurringPaymentManagerCard:not([open]) {
    text-align: center;
}

/* Only apply left alignment when open */
#recurringPaymentManagerCard[open] {
    text-align: left;
}
.recurring-payment-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    background: var(--card);
    border-radius: calc(var(--border-radius) / 2);
    margin-bottom: 8px;
    border: 1px solid var(--border);
    transition: background-color 0.2s ease;
}
.recurring-payment-item:hover {
    background: rgba(0,0,0,0.05);
}
.dark .recurring-payment-item:hover {
    background: rgba(255,255,255,0.1);
}
.recurring-payment-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.recurring-payment-name {
    font-weight: 600;
    font-size: 14px;
    color: var(--text);
}
.recurring-payment-details {
    display: flex;
    gap: 8px;
    font-size: 12px;
    color: var(--muted);
}
.recurring-payment-amount {
    font-weight: 600;
    color: var(--accent);
    font-size: 14px;
}
.recurring-payment-actions {
    display: flex;
    gap: 6px;
}
.recurring-payment-btn {
    padding: 6px 10px;
    border: none;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}
.recurring-payment-btn.edit {
    background: var(--accent);
    color: white;
}
.recurring-payment-btn.breakdown {
    background: var(--muted);
    color: white;
}
.recurring-payment-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
.recurring-payment-summary {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border);
}
.recurring-payment-stats {
    display: flex;
    gap: 16px;
    font-size: 12px;
    color: var(--muted);
}
.recurring-payment-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
}
.recurring-payment-stat-value {
    font-weight: 600;
    font-size: 14px;
    color: var(--text);
}
.recurring-payment-list {
    max-height: none;
    overflow-y: visible;
    padding-right: 5px;
}
.recurring-payment-empty {
    text-align: center;
    color: var(--muted);
    font-style: italic;
    padding: 20px;
}

/* Mobile optimizations for organizational sections */
@media (max-width: 768px) {
    .dashboard-section-item {
        padding: 10px;
        gap: 8px;
    }
    .section-name {
        font-size: 13px;
    }
    .section-description {
        font-size: 11px;
    }
    .section-toggle {
        width: 40px;
        height: 22px;
    }
    .section-toggle::after {
        width: 18px;
        height: 18px;
    }
    .section-toggle.active::after {
        transform: translateX(18px);
    }
    .order-btn {
        width: 18px;
        height: 14px;
        font-size: 9px;
    }
    
    /* Mobile optimizations for recurring payment manager */
    #recurringPaymentManagerCard[open] {
        min-height: auto;
        max-height: none;
    }
    .recurring-payment-item {
        padding: 10px;
        gap: 8px;
    }
    .recurring-payment-name {
        font-size: 13px;
    }
    .recurring-payment-details {
        font-size: 11px;
        flex-wrap: wrap;
        gap: 4px;
    }
    .recurring-payment-amount {
        font-size: 13px;
    }
    .recurring-payment-btn {
        padding: 4px 8px;
        font-size: 10px;
    }
    .recurring-payment-stats {
        gap: 12px;
    }
    .recurring-payment-stat-value {
        font-size: 13px;
    }
    .recurring-payment-list {
        max-height: none;
    }
}

/* iOS-style Bottom Navigation */
.bottom-nav {
    display: flex;
    justify-content: space-around;
    align-items: center;
    height: 60px;
    background: var(--nav-bg);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-top: 1px solid var(--nav-border);
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    padding: 0 8px;
    padding-bottom: env(safe-area-inset-bottom);
    box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
    transition: background-color 0.25s ease, border-color 0.25s ease;
}

.bottom-nav .nav-item {
    background: none;
    border: none;
    flex: 1;
    font-size: 14px;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: var(--nav-icon);
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 8px 4px;
    border-radius: 8px;
    position: relative;
}

.bottom-nav .nav-item:hover {
    background: rgba(0,0,0,0.05);
}

.bottom-nav .nav-item.active {
    color: var(--nav-icon-active);
}

.bottom-nav .nav-item.active::before {
    content: '';
    position: absolute;
    top: -2px;
    left: 50%;
    transform: translateX(-50%);
    width: 4px;
    height: 4px;
    background: var(--nav-icon-active);
    border-radius: 50%;
}

.bottom-nav .nav-item svg {
    margin-bottom: 2px;
    transition: transform 0.2s ease;
}

.bottom-nav .nav-item.active svg {
    transform: scale(1.1);
}

.bottom-nav .nav-item span {
    font-weight: 500;
    line-height: 1;
}

/* Dark mode support for bottom nav - now handled by CSS variables */
.dark .bottom-nav .nav-item:hover {
    background: rgba(255,255,255,0.05);
}

@media (max-width: 768px) {
    body { padding: 10px; }
    .app { gap: 16px; height: auto; min-height: initial; }
    .dashboard-container { grid-template-columns: 1fr; }
    details#billTrackerCard { max-height: none; flex: initial; }
    .menu-panel {
        /* Complete mobile positioning override */
        position: fixed !important;
        top: 70px !important;
        right: 8px !important;
        left: 8px !important;
        width: auto !important;
        transform: none !important;
        max-height: calc(100vh - 80px) !important;
        overflow: auto !important;
    }
    
    /* Mobile modal positioning fixes */
    .modal-overlay {
        padding: 10px !important;
        align-items: center !important;
    }
    
    .modal-content {
        width: 100% !important;
        max-width: none !important;
        max-height: calc(100vh - 40px) !important;
        overflow-y: auto !important;
        margin: 0 !important;
    }
    .calendar-day {
        height: 96px;
        width: 100%;
        max-width: 100%;
        padding: 0;
        box-sizing: border-box;
        overflow: hidden;
    }

    /* Mobile calendar pill adjustments */
    .day-bill-count {
        min-width: 14px !important;
        height: 14px !important;
        top: 8px !important;
        right: 8px !important;
        left: auto !important;
        z-index: 1000 !important;
        pointer-events: none !important;
        transform: none !important;
        position: absolute !important;
        margin-left: 0 !important;
        font-size: 9px !important;
    }


    /* Mobile multiple bubble arrangement - positioned within day boundaries */
    .bills-on-day .day-bill-count:nth-child(1) {
        transform: translate(-40%, -50%) !important;
    }
    .bills-on-day .day-bill-count:nth-child(2) {
        transform: translate(-20%, -50%) !important;
    }
    .bills-on-day .day-bill-count:nth-child(3) {
        transform: translate(0%, -50%) !important;
    }
    .bills-on-day .day-bill-count:nth-child(4) {
        transform: translate(20%, -50%) !important;
    }
    .bills-on-day .day-bill-count:nth-child(5) {
        transform: translate(40%, -50%) !important;
    }


    /* Ensure balance text goes behind bubbles */
    .mobile-view .day-balance-container {
        position: relative !important;
        z-index: 1 !important;
        padding: 4px !important;
    }

    .mobile-view .day-balance {
        position: relative !important;
        z-index: 1 !important;
        text-align: right !important;
        padding-right: 4px !important;
        transform: translateX(15%) !important;
        font-size: 9px !important;
    }
}

/* ========== DESKTOP CENTERING STYLES ========== */
@media (min-width: 769px) {
    .app {
        height: auto;
        min-height: initial;
    }

    /* Desktop calendar balance text fixed size */
    .day-balance {
        font-size: 11px !important;
    }
}

/* ========== MOBILE MODE STYLES ========== */
@media (max-width: 768px) {
    /* Base layout fix to prevent overflow */
    .mobile-view {
        display: block; /* Override grid centering */
        padding: 0;
        overscroll-behavior-y: contain;
    }

    /* Smooth, fast transitions for mobile dropdowns - no pulsing */
    .mobile-view .card[open] summary,
    .mobile-view details[open] summary {
        transition: background-color 0.15s ease, color 0.15s ease;
    }

    .mobile-view details.pulsing summary {
        /* Removed infinite pulsing animation for better performance */
        transition: background-color 0.15s ease, color 0.15s ease;
    }

    /* Set up main layout flow */
    .mobile-view .app {
        padding: 65px 10px 90px; /* Space for sticky header/FAB and body padding */
        max-width: 100%;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        box-sizing: border-box;
        gap: 12px; /* Reduce gap between sections */
    }
    .mobile-view .title-wrap {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        max-width: none;
        width: 100%;
        z-index: 1000;
        border-radius: 0;
        border-bottom: 1px solid var(--border);
        box-shadow: none;
    }

    /* Re-flow dashboard into a single column */
    .mobile-view .dashboard-container {
        display: flex;
        flex-direction: column;
        order: 1; /* Dashboard section first */
    }
    .mobile-view .dashboard-row {
        display: contents; /* Let children be direct flex items */
    }

    /* Order dashboard cards vertically */
    .mobile-view #balanceSummaryCard { order: 1; }
    .mobile-view #dueSummaryCard { order: 2; }
    .mobile-view #pendingBillsCard { order: 3; }
    .mobile-view #next30DaysCard { order: 4; }
    .mobile-view #recurringPaymentManagerCard { order: 5; }
    .mobile-view #financeCard { order: 6; }

    /* Make Finance card collapsible on mobile */

    @media (min-width: 769px) {
        #financeCard > summary {
            pointer-events: none;
            cursor: default;
        }
        #financeCard > summary::-webkit-details-marker {
            display: none;
        }
    }

    .mobile-view #theTabCard {
        order: 7;
        text-align: left;
    }
    
    .mobile-view #theTabCard .debt-content-wrapper {
        grid-template-columns: 1fr;
        gap: 20px;
    }
    .mobile-view details.finance-card .stack {
        overflow: hidden;
    }

    /* Fix finance card animation on mobile by ensuring proper overflow handling */
    .mobile-view details.finance-card > div {
        overflow: visible;
        position: relative;
        transition: height var(--slide-duration) var(--slide-ease), opacity 0.2s ease;
    }

    /* Mobile input improvements - keep inputs in view */
    .mobile-view input:focus,
    .mobile-view select:focus,
    .mobile-view textarea:focus {
        scroll-margin: 100px;
        scroll-padding: 100px;
    }

    .mobile-view .finance-card input:focus,
    .mobile-view .finance-card select:focus {
        scroll-margin-top: 150px; /* Extra space for finance card header */
    }

    .mobile-view #expenseAmount:focus,
    .mobile-view #expenseDescription:focus {
        scroll-margin-top: 120px;
    }

    /* Mobile modal input improvements */
    .mobile-view .modal-content input:focus {
        scroll-margin: 150px;
        scroll-padding: 150px;
    }

    .mobile-view #modal-input {
        font-size: 16px; /* Prevents zoom on iOS */
        inputmode: decimal;
    }

    /* Income Management Styles - Modernized */
    .income-list {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }

    .income-item {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 18px;
        background: rgba(var(--glass-tint), var(--glass-alpha));
        backdrop-filter: blur(12px);
        border: 1px solid var(--glass-stroke);
        border-radius: var(--border-radius);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
        min-height: 140px;
    }

    .income-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--accent), var(--ok));
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .income-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        border-color: var(--accent);
    }

    .income-item:hover::before {
        opacity: 1;
    }

    .income-item.primary-income {
        border-color: var(--accent);
        background: rgba(5, 150, 105, 0.08);
        box-shadow: 0 4px 15px rgba(5, 150, 105, 0.1);
    }

    .income-item.primary-income::before {
        opacity: 1;
        background: var(--accent);
    }

    .income-info {
        flex: 1;
        min-width: 0;
    }

    .income-name {
        font-weight: 700;
        font-size: 18px;
        color: var(--text);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        line-height: 1.2;
    }

    /* Ensure emoji displays properly on mobile and in APKs */
    .income-name {
        font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Android Emoji', 'EmojiSymbols', 'Noto Emoji', 'Twemoji', system-ui, sans-serif;
        -webkit-font-feature-settings: "liga", "kern";
        font-feature-settings: "liga", "kern";
    }
    
    /* Fallback for APK WebView emoji issues */
    .emoji-fallback {
        display: inline-block;
        width: 18px;
        height: 18px;
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        border-radius: 50%;
        text-align: center;
        line-height: 18px;
        font-size: 12px;
        color: white;
        font-weight: bold;
        margin-right: 8px;
    }
    
    /* APK-specific emoji handling */
    @media screen and (-webkit-min-device-pixel-ratio: 0) {
        .income-name {
            font-family: 'Noto Color Emoji', 'Android Emoji', 'Segoe UI Emoji', system-ui, sans-serif;
        }
    }

    .income-details {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 12px;
    }

    .income-detail {
        display: flex;
        align-items: center;
        gap: 6px;
        font-weight: 500;
        font-size: 14px;
        background: rgba(var(--glass-tint), 0.3);
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
        transition: all 0.2s ease;
    }

    .income-detail:hover {
        background: rgba(var(--glass-tint), 0.5);
        transform: translateX(4px);
    }

    .income-detail:first-child {
        color: var(--ok);
        font-weight: 600;
        background: rgba(5, 150, 105, 0.1);
        border-color: rgba(5, 150, 105, 0.3);
    }

    .income-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: auto;
        padding-top: 12px;
        border-top: 1px solid var(--border);
    }

    .income-btn {
        padding: 10px 16px;
        border: 1px solid var(--border);
        border-radius: calc(var(--border-radius) / 2);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 13px;
        font-weight: 600;
        transition: all 0.3s ease;
        min-width: auto;
        height: auto;
        position: relative;
        overflow: hidden;
        gap: 4px;
    }

    .income-btn::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background: rgba(255,255,255,0.2);
        border-radius: 50%;
        transition: all 0.3s ease;
        transform: translate(-50%, -50%);
    }

    .income-btn:hover::before {
        width: 100%;
        height: 100%;
    }

    .income-btn:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 6px 20px rgba(0,0,0,0.2);
    }

    .income-btn.edit {
        background: var(--bg);
        color: var(--text);
        border-color: var(--accent);
    }

    .income-btn.edit:hover {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
    }

    .income-btn.delete {
        background: var(--bg);
        color: var(--text);
        border-color: var(--danger);
    }

    .income-btn.delete:hover {
        background: var(--danger);
        color: white;
        border-color: var(--danger);
    }

    .income-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }

    .income-form {
        background: rgba(var(--glass-tint), var(--glass-alpha));
        backdrop-filter: blur(12px);
        border: 2px solid var(--accent);
        border-radius: var(--border-radius);
        padding: 24px;
        margin-bottom: 16px;
        position: relative;
        overflow: hidden;
    }

    .income-form::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--accent), var(--ok));
    }

    .income-form-row {
        display: flex;
        gap: 16px;
        margin-bottom: 16px;
    }

    .income-form-row:last-child {
        margin-bottom: 0;
    }

    .income-form-group {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .income-form-group label {
        font-size: 13px;
        font-weight: 700;
        color: var(--text);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .income-form-group input,
    .income-form-group select {
        padding: 12px 16px;
        border: 2px solid var(--border);
        border-radius: calc(var(--border-radius) / 2);
        background: rgba(var(--glass-tint), 0.3);
        color: var(--text);
        font-size: 15px;
        font-weight: 500;
        transition: all 0.3s ease;
    }

    .income-form-group input:focus,
    .income-form-group select:focus {
        outline: none;
        border-color: var(--accent);
        background: rgba(var(--glass-tint), 0.5);
        box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
    }

    .income-form-actions {
        display: flex;
        gap: 12px;
        margin-top: 20px;
    }

    .income-form-actions button {
        flex: 1;
        padding: 14px 20px;
        border: none;
        border-radius: calc(var(--border-radius) / 2);
        font-weight: 700;
        font-size: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }

    .income-form-actions .save-btn {
        background: linear-gradient(135deg, var(--accent), #059669);
        color: white;
        box-shadow: 0 4px 15px rgba(5, 150, 105, 0.3);
    }

    .income-form-actions .save-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(5, 150, 105, 0.4);
    }

    .income-form-actions .cancel-btn {
        background: transparent;
        border: 2px solid var(--border);
        color: var(--text);
    }

    .income-form-actions .cancel-btn:hover {
        border-color: var(--danger);
        color: var(--danger);
        transform: translateY(-2px);
    }

    /* Mobile optimizations for income management */
    @media (max-width: 768px) {
        .income-list {
            grid-template-columns: 1fr;
            gap: 16px;
        }

        .income-item {
            min-height: auto;
            padding: 16px;
        }

        .income-name {
            font-size: 16px;
            margin-bottom: 10px;
        }

        .income-details {
            gap: 8px;
            margin-bottom: 12px;
        }

        .income-detail {
            font-size: 13px;
            padding: 6px 10px;
        }

        .income-actions {
            justify-content: center;
            margin-top: 8px;
            padding-top: 10px;
        }

        .income-form-row {
            flex-direction: column;
            gap: 12px;
        }

        .income-form-actions {
            flex-direction: column;
        }

        .income-form-actions button {
            padding: 16px;
            font-size: 16px;
        }
    }

    /* Order main content sections */
    .mobile-view #billTrackerCard { order: 8; margin-top: 0; }
    .mobile-view .add-bill-container { order: 9; }
    .mobile-view #pastBillsCard {
        order: 10;
        margin-bottom: auto;
    }
    .mobile-view #billTrackerCard > summary,
    .mobile-view #pastBillsCard > summary,
    .mobile-view #financeCard > summary,
    .mobile-view #theTabCard > summary,
    .mobile-view #pendingBillsCard > summary,
    .mobile-view #next30DaysCard > summary,
    .mobile-view #recurringPaymentManagerCard > summary {
        text-align: left;
        cursor: pointer;
        list-style: revert;
        margin: -16px -16px 10px;
        padding: 16px;
        padding-bottom: 10px;
        display: list-item;
    }
    /* START: MODIFICATION */
    .mobile-view #billTrackerCard > summary,
    .mobile-view #pastBillsCard > summary,
    .mobile-view #theTabCard > summary,
    .mobile-view #pendingBillsCard > summary,
    .mobile-view #next30DaysCard > summary,
    .mobile-view #recurringPaymentManagerCard > summary {
        background: rgba(128,128,128,0.05);
    }
    /* END: MODIFICATION */
    #pastBillsCard[open] .card-footer {
        display: block;
    }
    .mobile-view .bill-table-wrapper {
      padding-right: 0;
    }

    .mobile-view #archiveView main.card {
        flex-grow: 1;
        height: 70vh;
    }

    /* Floating Action Button (FAB) for "Add Bill" */
    .mobile-view .add-bill-container {
        position: fixed;
        bottom: 80px; /* Adjusted for bottom nav */
        right: 20px;
        left: auto;
        width: auto;
        height: auto;
        z-index: 1050;
        padding-right: 0;
        margin-top: 0;
    }
    .mobile-view .add-bill-header-btn {
        width: auto;
        height: 56px;
        border-radius: 999px;
        padding: 0 24px;
        box-shadow: 0 6px 16px rgba(0,0,0,.2);
        transform: none;
        font-size: 16px;
        font-weight: 700;
    }
    .mobile-view .add-bill-header-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 20px rgba(0,0,0,.25);
    }
    .mobile-view .add-bill-header-btn svg {
        margin-right: 8px;
        width: 20px;
        height: 20px;
    }

    /* Hide non-essential cards in mobile view */
    .mobile-view #expenseTrackerCard {
        display: none !important;
    }

    /* --- Bill List Redesign --- */
    .mobile-view .bill-table {
        border-collapse: separate;
        border-spacing: 0 10px;
        margin-top: -10px;
    }
    .mobile-view .bill-table thead {
        display: none;
    }
    .mobile-view .bill-table tbody tr {
        background: transparent;
        border: none;
        padding: 0;
        cursor: default;
        border-bottom: none; /* Override default */
    }
    .mobile-view .bill-table tbody tr td {
        padding: 0 !important;
        box-shadow: none !important;
        display: block;
        border: none !important; /* Override paid/pending borders */
        border-radius: 0 !important;
    }
    .mobile-bill-layout {
        display: grid;
        grid-template:
            "date info amount" auto
            "actions actions actions" auto / 48px 1fr auto;
        gap: 8px 12px;
        padding: 12px;
        border-radius: calc(var(--border-radius) / 1.5);
        background: var(--card);
        border: 1px solid var(--border);
    }
    tr.paid .mobile-bill-layout { border-left: 4px solid var(--ok); }
    tr.pending .mobile-bill-layout { border-left: 4px solid var(--pending-border); }
    tr.unpaid .mobile-bill-layout { border-left: 4px solid var(--danger); }

    .mobile-bill-date {
        grid-area: date;
        align-self: center;
    }
    .mobile-bill-date .date-box { width: 100%; }

    .mobile-bill-info {
        grid-area: info;
        display: flex;
        flex-direction: column;
        justify-content: center;
        text-align: left;
        min-width: 0;
    }
    .mobile-bill-info .bill-name {
        font-weight: 600; font-size: 16px; line-height: 1.2;
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .mobile-bill-info .bill-status { margin-top: 4px; font-size: 13px; }

    .mobile-bill-amount {
        grid-area: amount;
        text-align: right;
        align-self: center;
    }
    .mobile-bill-amount .bill-amount { font-size: 18px; font-weight: 700; font-family: var(--font-mono);}
    .mobile-bill-amount .split-info-total { font-size: 10px; }


    .mobile-bill-actions {
        grid-area: actions;
        display: flex; flex-wrap: wrap; justify-content: flex-end;
        gap: 8px; padding-top: 8px; margin-top: 8px;
        border-top: 1px dashed var(--border);
    }

    /* --- Hide desktop elements in mobile view --- */
    .mobile-view .due-date-cell, .mobile-view .bill-details-cell, .mobile-view .bill-notes-cell, .mobile-view .bill-amount-cell, .mobile-view .actions-cell {
        display: none;
    }
    .mobile-view tr td[colspan="5"] {
        display: block;
    }
    
    /* --- Mobile Calendar Optimizations --- */
    .mobile-view #calendarView {
        padding: 0;
    }
    .mobile-view .calendar-header {
        margin-bottom: 12px;
        padding: 8px 12px;
        position: relative;
    }
    .mobile-view .calendar-header h2 {
        font-size: 18px;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        margin: 0;
        white-space: nowrap;
    }
    .mobile-view .calendar-grid-container {
        grid-template-columns: repeat(7, minmax(0, 1fr));
        overflow: visible;
    }
    .mobile-view .calendar-day-name {
        padding: 6px 2px;
        font-size: 11px;
    }
    .mobile-view .calendar-day {
        min-height: auto;
        aspect-ratio: 1 / 1;
        padding: 3px;
        overflow: visible;
        font-size: 11px;
    }
    .mobile-view .day-number {
        font-size: 11px;
        font-weight: 700;
    }
    .mobile-view .day-balance {
        font-size: var(--calendar-balance-font-size);
        text-align: center;
    }
    .mobile-view .day-balance-container {
        min-height: 3em;
        gap: 0px;
    }
    .mobile-view .bills-on-day {
        gap: 2px;
        overflow: hidden;
        margin-bottom: 1em;
    }
    .mobile-view .bill-item-calendar {
        font-size: 10px;
        padding: 1px 4px;
        border-radius: 4px;
    }

    /* Bottom Navigation */
    .bottom-nav {
        display: none; /* Hidden by default on desktop */
    }
    .mobile-view .bottom-nav {
        display: flex;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: var(--nav-bg);
        backdrop-filter: saturate(var(--glass-backdrop-sat)) blur(var(--glass-backdrop-blur));
        -webkit-backdrop-filter: saturate(var(--glass-backdrop-sat)) blur(var(--glass-backdrop-blur));
        border-top: 1px solid var(--nav-border);
        z-index: 1000;
        padding-bottom: env(safe-area-inset-bottom); /* For iPhone X notch */
        transition: background-color 0.25s ease, border-color 0.25s ease;
    }
    .mobile-view .bottom-nav-btn {
        flex: 1;
        background: transparent;
        border: none;
        color: var(--nav-icon);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        font-size: 12px;
        cursor: pointer;
        padding-top: 8px;
        transition: color 0.2s ease;
    }
    .mobile-view .bottom-nav-btn svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
    }
    .mobile-view .bottom-nav-btn.active {
        color: var(--nav-icon-active);
    }

    /* Mobile Font Size Control */
    .mobile-view .font-size-control {
        display: none; /* Hide desktop control on mobile */
    }

}

/* ========== Statistics View Specific Styles ========== */
.desktop-stats-controls { display: flex; gap: 10px; }
.mobile-stats-controls { display: none; }

#statisticsView .dashboard-row.summary-metrics {
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}
#statisticsView .dashboard-row.charts {
    grid-template-columns: 1fr 1fr;
    gap: 16px;
}
#statisticsView .dashboard-row.tables {
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}
@media (max-width: 768px) {
    .mobile-view #statisticsView .dashboard-row {
        grid-template-columns: 1fr;
    }
    .mobile-view #statisticsView main.dashboard-container {
        padding: 0 !important; /* Override inline style for mobile consistency */
        overflow-y: visible !important; /* Prevent shadow clipping on mobile */
    }
    .mobile-view #statisticsView .desktop-stats-controls {
        display: none;
    }
    .mobile-view #statisticsView .mobile-stats-controls {
        display: flex;
    }
    .mobile-view #statisticsView .mobile-stats-controls .ctrl-btn {
        width: auto;
        padding: 8px 12px;
        gap: 6px;
    }
    .mobile-view #statisticsView .mobile-stats-controls .ctrl-btn svg {
        width: 18px;
        height: 18px;
    }
}

.recurring-breakdown summary {
    cursor: pointer;
    font-weight: 600;
    padding: 8px 0;
    list-style-type: ' ';
}
.recurring-breakdown[open] > summary {
    list-style-type: ' ';
}
.recurring-breakdown summary:hover {
    color: var(--accent);
}
.breakdown-list {
    padding-left: 16px;
    border-left: 2px solid var(--border);
    margin: 8px 0 16px;
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.breakdown-item {
    display: flex;
    justify-content: space-between;
    font-size: 14px;
}
.breakdown-item span:last-child {
    font-weight: 600;
    font-family: var(--font-mono);
}

/* ========== Goals View Specific Styles ========== */
#goalsView .dashboard-row {
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}

.goals-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-height: 200px;
}

.goal-item {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--border-radius);
    padding: 16px 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.04);
}
.dark .goal-item {
    background: #1c1c1e;
    border-color: #38383a;
}

.goal-item:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow);
}

.goal-info {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.goal-name {
    font-weight: 600;
    font-size: 18px;
    color: var(--text);
}

.goal-notes-display {
    font-size: 13px;
    color: var(--muted);
    line-height: 1.4;
}

.goal-progress {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.goal-progress-bar {
    width: 100%;
    height: 10px;
    background: var(--border);
    border-radius: 5px;
    overflow: hidden;
}

.goal-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--ok));
    border-radius: 5px;
    transition: width 0.4s ease;
}

.goal-progress-text {
    font-size: 12px;
    color: var(--muted);
    display: flex;
    justify-content: space-between;
    font-weight: 500;
}

.goal-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin-top: 4px;
}

.goal-amount-container {
    display: flex;
    align-items: baseline;
    gap: 4px;
}

.goal-amount-saved {
    font-size: 24px;
    font-weight: 700;
    color: var(--text);
    font-family: var(--font-mono);
}

.goal-amount-total {
    font-size: 14px;
    font-weight: 500;
    color: var(--muted);
}

.goal-action-buttons {
    display: flex;
    gap: 12px;
}

.goal-action-btn {
    background-color: color-mix(in srgb, var(--bg) 50%, var(--border));
    border: none;
    width: 34px;
    height: 34px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--muted);
    transition: all 0.2s ease;
}
.dark .goal-action-btn {
    background-color: #2c2c2e;
}

.goal-action-btn:hover {
    background-color: color-mix(in srgb, var(--bg) 30%, var(--border));
    color: var(--text);
    transform: scale(1.1);
}
.dark .goal-action-btn:hover {
    background-color: #3a3a3c;
}

.goal-action-btn.add {
    background-color: var(--accent);
    color: white;
}
.goal-action-btn.add:hover {
    background-color: color-mix(in srgb, var(--accent) 90%, black);
    color: white;
}

.goal-action-btn.delete:hover {
    background-color: var(--danger);
    color: white;
}

.goal-action-btn svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
}

.goal-form {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.form-row {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.form-row label {
    font-weight: 600;
    font-size: 14px;
    color: var(--text);
}

.form-row input, .form-row textarea {
    padding: 10px 12px;
    border: 1px solid var(--border);
    border-radius: calc(var(--border-radius) / 1.5);
    background: var(--bg);
    color: var(--text);
    font-size: 14px;
    outline: none;
    transition: border-color 0.2s ease;
}

.form-row input:focus, .form-row textarea:focus {
    border-color: var(--accent);
}

.form-row textarea {
    resize: vertical;
    min-height: 80px;
}

.form-actions {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
}

.feasibility-feedback {
    padding: 12px;
    border-radius: calc(var(--border-radius) / 1.5);
    border: 1px solid;
    margin: 8px 0;
}

.feasibility-feedback.feasible {
    background: color-mix(in srgb, var(--ok) 8%, transparent);
    border-color: var(--ok);
    color: var(--ok);
}

.feasibility-feedback.not-feasible {
    background: color-mix(in srgb, var(--danger) 8%, transparent);
    border-color: var(--danger);
    color: var(--danger);
}

.feasibility-feedback.warning {
    background: color-mix(in srgb, var(--pending-text) 8%, transparent);
    border-color: var(--pending-text);
    color: var(--pending-text);
}

.no-goals-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 40px 20px;
    color: var(--muted);
}

.no-goals-message p {
    margin: 0 0 16px 0;
    font-size: 16px;
}

.payment-schedule-preview {
    background: rgba(128,128,128,0.05);
    border: 1px solid var(--border);
    border-radius: calc(var(--border-radius) / 1.5);
    padding: 16px;
    margin: 16px 0;
}

.payment-schedule-preview h4 {
    margin: 0 0 12px 0;
    color: var(--accent);
    font-size: 16px;
}

.schedule-list {
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 12px;
}

.schedule-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    margin: 4px 0;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 14px;
}

.schedule-date {
    font-weight: 600;
    color: var(--text);
}

.schedule-amount {
    font-family: var(--font-mono);
    font-weight: 700;
    color: var(--accent);
}

.schedule-summary {
    text-align: center;
    padding: 12px;
    background: var(--card);
    border-radius: 8px;
    border: 1px solid var(--accent);
    color: var(--accent);
}

@media (max-width: 768px) {
    .mobile-view #goalsView .dashboard-row {
        grid-template-columns: 1fr;
    }
    .mobile-view #goalsView main.dashboard-container {
        padding: 0 !important; /* Override inline style for mobile consistency */
        overflow-y: visible !important; /* Prevent shadow clipping on mobile */
    }
}

.checkbox-label {
    display: flex;
    align-items: center;
    cursor: pointer;
    font-size: 14px;
    margin-bottom: 0;
}

.checkbox-label input[type="checkbox"] {
    margin-right: 10px;
    width: 18px;
    height: 18px;
}

.checkmark {
    flex-grow: 1;
}

.schedule-item.down-payment {
    background: rgba(34, 197, 94, 0.1);
    border-left: 3px solid #22c55e;
}

/* Goal Payment Styling */
.goal-payment {
    border-left: 3px solid #059669;
}

.goal-payment.locked {
    background: rgba(251, 191, 36, 0.1);
    border-left-color: #f59e0b;
}

.goal-payment.grayed-out {
    opacity: 0.5;
    background: rgba(107, 114, 128, 0.1);
    border-left-color: #374151;
}

.goal-payment.grayed-out .bill-name,
.goal-payment.grayed-out .bill-amount {
    color: #374151;
}

.edit-goal-payment-btn,
.lock-goal-payment-btn {
    background: #3b82f6;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    margin: 2px;
}

.edit-goal-payment-btn:hover,
.lock-goal-payment-btn:hover {
    background: #2563eb;
}

.lock-goal-payment-btn {
    background: #f59e0b;
}

.lock-goal-payment-btn:hover {
    background: #d97706;
}

/* Goal Edit Modal Styles */
.goal-edit-container {
    max-width: 480px;
    margin: 0 auto;
}

.goal-edit-header {
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--accent);
}

.goal-edit-header h3 {
    margin: 0 0 6px 0;
    color: var(--accent);
    font-size: 15px;
}

.goal-progress-info {
    font-size: 11px;
    color: var(--text-secondary);
    line-height: 1.3;
}

.payment-schedule-list {
    max-height: 250px;
    overflow-y: auto;
    margin-bottom: 10px;
}

.schedule-payment-item {
    display: grid;
    grid-template-columns: 1fr 75px 60px 95px;
    gap: 4px;
    align-items: center;
    padding: 4px 6px;
    margin-bottom: 3px;
    border: 1px solid var(--accent);
    border-radius: 3px;
    background: var(--card);
    font-size: 11px;
    min-height: 32px;
}

.schedule-payment-item.editable {
    border-left: 3px solid #059669;
}

.schedule-payment-item.non-editable {
    border-left: 3px solid #f59e0b;
}

.schedule-payment-item.grayed-out {
    opacity: 0.6;
    border-left-color: #374151;
}

.payment-date {
    font-weight: 500;
    font-size: 11px;
    line-height: 1.2;
}

.payment-date-text {
    font-size: 9px;
    color: var(--text-secondary);
    margin-top: 1px;
}

.payment-amount-input {
    width: 100%;
    padding: 3px 4px;
    border: 1px solid var(--accent);
    border-radius: 2px;
    background: var(--input);
    color: var(--text);
    font-size: 11px;
    height: 24px;
}

.payment-amount-display {
    font-weight: 500;
    color: var(--accent);
    font-size: 11px;
}

.payment-status {
    text-align: center;
    font-size: 9px;
}

.payment-controls {
    display: flex;
    gap: 2px;
    justify-content: flex-end;
}

.toggle-lock-btn,
.delete-payment-btn {
    padding: 2px 4px;
    border: none;
    border-radius: 2px;
    font-size: 9px;
    cursor: pointer;
    white-space: nowrap;
    min-height: 20px;
}

.toggle-lock-btn {
    background: #f59e0b;
    color: white;
}

.toggle-lock-btn:hover {
    background: #d97706;
}

.delete-payment-btn {
    background: #dc2626;
    color: white;
}

.delete-payment-btn:hover {
    background: #b91c1c;
}

.goal-edit-summary {
    padding: 8px;
    background: var(--input);
    border-radius: 4px;
    border: 1px solid var(--accent);
    font-size: 11px;
    line-height: 1.3;
}

.recalculate-btn {
    background: #8b5cf6;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    font-weight: 500;
    cursor: pointer;
}

.recalculate-btn:hover {
    background: #7c3aed;
}

@media (max-width: 768px) {
    .goal-edit-container {
        max-width: 100%;
        margin: 0;
    }

    .goal-edit-header {
        margin-bottom: 8px;
    }

    .schedule-payment-item {
        grid-template-columns: 1fr;
        gap: 4px;
        text-align: left;
        padding: 5px 6px;
        margin-bottom: 3px;
    }

    .payment-controls {
        justify-content: center;
        margin-top: 3px;
        gap: 2px;
    }

    .payment-schedule-list {
        max-height: 200px;
        margin-bottom: 8px;
    }

    .goal-edit-summary {
        padding: 6px;
        font-size: 10px;
    }
}


@media print {
    body > *:not(#app),
    #app > *:not(#calendarView),
    .menu-panel, #editModal, #archiveView {
        display: none !important;
    }
    .app, body {
        padding: 0;
        margin: 0;
        background: none;
    }
    #calendarView {
        display: block !important;
        max-width: 100% !important;
        box-shadow: none !important;
        border: none !important;
        background: white !important;
        color: black !important;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
    }
    .glass {
        background: transparent !important;
        backdrop-filter: none !important;
        --glass-stroke: #ccc !important;
        border-color: #ccc !important;
    }
    .calendar-header .ctrl-btn {
        display: none !important;
    }
    .calendar-header h2 {
        color: black !important;
    }
    .bill-item-calendar {
        background-color: #eee !important;
        color: #333 !important;
        border: 1px solid #ddd;
    }
    .bill-item-calendar.paid {
        background-color: #e8f5e9 !important;
        color: #2e7d32 !important;
        text-decoration: none;
    }
    .calendar-day.today .day-number {
        background-color: #ddd !important;
        color: black !important;
    }
    :root {
        --text: #000;
        --muted: #555;
        --card: #fff;
        --bg: #fff;
        --border: #ccc;
    }
}
.prepaid-indicator {
    background-color: #8b5cf6 !important; /* A distinct purple */
    color: white !important;
    font-size: 12px !important;
    width: 18px !important;
    height: 18px !important;
    font-weight: 800;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.3);
    position: absolute;
    top: 50px; /* Position below other indicators */
    left: 27%;
    transform: translateX(-50%);
    z-index: 12;
}

.menu-footnote{ font-size:12px; color:var(--muted); letter-spacing:0.2px; margin-bottom:0; }

/* Hide menu footnote on mobile to prevent text appearing at bottom of tabs */
@media (max-width: 768px) {
    .menu-footnote {
        display: none;
    }
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf-autotable.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.5.0/chart.umd.min.js"></script>
<script src="cordova.js"></script>
</head>
<body>
  <canvas id="ambianceCanvas"></canvas>
  <div class="app" id="app">
    <header class="title-wrap glass">
      <h1><svg fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 415.259 415.259" xml:space="preserve"><g><g><g id="Layer_5_47_"><g><path d="M327.073,323.196L174.091,90.426c-3.1-4.718-7.795-7.423-12.877-7.423c-5.209,0-9.955,2.811-13.023,7.712L2.671,323.26 c-3.166,5.062-3.535,10.572-1.013,15.127c2.522,4.556,7.392,7.166,13.36,7.166h299.995c6.015,0,10.881-2.633,13.358-7.225 C330.848,333.736,330.375,328.223,327.073,323.196z M161.304,101.234c1.529,0,2.417,1.472,2.417,1.472l92.72,138.025 c5.974,10.752,1.974,14.086-9.36,3.086c0,0-33.562-38.944-46.108-50.578c-3.15-2.921-9.553-3.67-13.12-1.275 c-9.288,6.233-25.457,21.991-34.852,28.063c-3.607,2.332-8.505,0.328-9.525-3.847c-3.373-13.792-6.196-42.208-9.754-55.955 c-1.076-4.159-5.102-4.926-8.567-2.387c-0.858,0.629-2.687,1.727-3.603,2.268c-1.06,0.625-0.469-0.259-0.469-0.259 l37.937-57.292C159.018,102.558,159.708,101.234,161.304,101.234z"/><path d="M412.619,290.749L271.834,76.537c-2.854-4.341-7.173-6.831-11.852-6.831c-4.793,0-9.161,2.587-11.983,7.098 l-29.411,46.999c0,0-1.099,1.681-0.247,3.573c0.951,2.113,3.63,5.949,5.093,7.748c1.142,1.401,2.588-0.974,2.588-0.974 l32.199-48.845c0,0,0.873-1.301,1.847-1.301c1.109,0,1.947,1.386,1.947,1.386l91.624,135.562 c2.603,3.782-4.281,3.799-10.285-1.016c-9.071-7.274-27.021-22.074-36.116-29.319c-3.094-2.464-8.74-3.301-12.073-1.174 c-4.911,3.135-16.602,12.289-21.366,16.683c-2.557,2.357-0.692,4.572-0.692,4.572l64.075,97.496c0,0,1.812,3.129,4.688,3.129 c14.914,0,59.656,0,59.656,0c5.532,0,10.015-2.424,12.293-6.648C416.095,300.45,415.658,295.374,412.619,290.749z"/></g></g></g></g></svg>Sum-it Forecast</h1>
        <div class="header-controls">
          <button id="calendarToggleBtn" class="ctrl-btn" title="Toggle Calendar View"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,19H5V8H19M19,3H18V1H16V3H8V1H6V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M16.53,11.06L15.47,10L10.5,14.97L8.47,12.94L7.41,14L10.5,17.09L16.53,11.06Z"/></svg></button>
          <button id="menuBtn" class="ctrl-btn menu-btn" title="Open Settings"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg></button>
        </div>
    </header>

    <div class="dashboard-container">
        <div class="dashboard-row">
            <div id="balanceSummaryCard" class="summary-card glass"><h3 id="totalAmountLabel">Available Balance</h3><div class="amount total" id="totalAmount">$0.00</div><div class="projected-balance" id="actualBalance"></div></div>
            <div id="dueSummaryCard" class="summary-card glass"><h3 id="totalDueNext10DaysLabel">Your Share (Next 10 Days)</h3><div class="amount unpaid" id="totalDueNext10Days">$0.00</div><div class="projected-balance" id="projected10Day"></div></div>
            <details id="pendingBillsCard" class="card glass">
                <summary>Pending</summary>
                <div>
                    <div id="pendingBillsList"></div>
                </div>
            </details>
        </div>
        <div class="dashboard-row">
            <details id="next30DaysCard" class="card glass">
                <summary>Next 30 Days</summary>
                <div>
                    <div id="next30DaysList"></div>
                </div>
            </details>
            <details id="recurringPaymentManagerCard" class="card glass">
                <summary>Recurring Payment Manager</summary>
                <div>
                    <div class="recurring-payment-summary">
                        <div class="recurring-payment-stats">
                            <div class="recurring-payment-stat">
                                <div class="recurring-payment-stat-value" id="recurringTotalCount">0</div>
                                <div>Total</div>
                            </div>
                            <div class="recurring-payment-stat">
                                <div class="recurring-payment-stat-value" id="recurringMonthlyTotal">$0.00</div>
                                <div>Monthly</div>
                            </div>
                            <div class="recurring-payment-stat">
                                <div class="recurring-payment-stat-value" id="recurringYearlyTotal">$0.00</div>
                                <div>Yearly</div>
                            </div>
                        </div>
                    </div>
                    <div class="recurring-payment-list" id="recurringPaymentList">
                        <div class="recurring-payment-empty">No recurring payments found</div>
                    </div>
                </div>
            </details>
            <details id="financeCard" class="finance-card glass">
                <summary class="finance-card-header">
                    My Finances
                    <button id="privacyToggleBtn" class="ctrl-btn privacy-btn" title="Toggle Visibility">
                        <svg class="eye-open" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z"/></svg>
                        <svg class="eye-closed" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M11.83,9L15,12.17V12A3,3 0 0,0 12,9C11.94,9 11.89,9 11.83,9M7.53,9.8L9.08,11.35C9.03,11.56 9,11.77 9,12A3,3 0 0,0 12,15C12.22,15 12.44,14.97 12.65,14.92L14.2,16.47C13.53,16.8 12.79,17 12,17A5,5 0 0,1 7,12C7,10.79 7.2,9.67 7.53,9.8M2,4.27L4.28,6.55L4.73,7C3.08,8.3 1.78,10 1,12C2.73,16.39 7,19.5 12,19.5C13.55,19.5 15.03,19.2 16.38,18.66L16.81,19.08L19.73,22L21,20.73L3.27,3L2,4.27M12,7A5,5 0 0,1 17,12C17,12.64 16.87,13.26 16.64,13.82L19.55,16.73C21.07,15.5 22.27,13.86 23,12C21.27,7.61 17,4.5 12,4.5C10.6,4.5 9.27,4.75 8.04,5.25L9.9,7.11C10.54,7.03 11.22,7 12,7Z"/></svg>
                    </button>
                </summary>
                <div>
                    <div class="stack">
                        <div class="finance-row"><label for="currentBalance">Balance:</label><input type="number" id="currentBalance" placeholder="$0.00"></div>
                        <div class="utility-toggle-label" style="margin: 8px 0;">
                          <div class="utility-toggle" id="dontAutoDeductToggle"></div>
                          <span>Don't auto-deduct</span>
                        </div>
                        <div class="finance-row"><label for="primaryIncomeName">Income Name:</label><input type="text" id="primaryIncomeName" placeholder="e.g., Salary, Wages"></div>
                        <div class="finance-row"><label for="paycheckAmount">Next/Est Paycheck:</label><input type="number" id="paycheckAmount" placeholder="$0.00"></div>
                        <div class="finance-row"><label for="nextPayday">Next Payday:</label><input type="date" id="nextPayday"></div>
                        <div class="finance-row" style="display: grid; grid-template-columns: auto 1fr auto; gap: 10px; align-items: center;">
                            <label for="payFrequency">Frequency:</label>
                            <select id="payFrequency" style="width: 100%;"><option>Weekly</option><option selected>Bi-Weekly</option><option>Monthly</option></select>
                            <button id="submitIncomeBtn" class="ctrl-btn" style="width: auto; padding: 8px 16px; background: linear-gradient(135deg, var(--accent), #059669); color: white; border-radius: var(--border-radius); font-weight: 600; font-size: 14px; white-space: nowrap;">Submit</button>
                        </div>
                        <div class="finance-row" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid var(--accent); display: flex; justify-content: center;">
                            <button id="manageIncomeBtn" class="ctrl-btn" style="width: 100%; max-width: 300px; background: linear-gradient(135deg, var(--accent), #059669); color: white; padding: 16px; border-radius: var(--border-radius); font-weight: 700; font-size: 16px; box-shadow: 0 4px 15px rgba(5, 150, 105, 0.3); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; gap: 8px;">
                                 Manage Additional Income
                            </button>
                        </div>
                    </div>
                </div>
            </details>
            <div id="expenseTrackerCard" class="glass">
                <h3>Log an Expense</h3>
                <div id="expenseQuickOptions" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                    <button class="ctrl-btn quick-expense-btn glass" data-expense="Food" style="width:100%; height:auto; padding: 16px 12px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>Food
                    </button>
                    <button class="ctrl-btn quick-expense-btn glass" data-expense="Gas" style="width:100%; height:auto; padding: 16px 12px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M18.32 8.56L16.9 7.14c.9-1.1 1.4-2.5 1.4-4 0-3.31-2.69-6-6-6S6.3.69 6.3 4c0 1.5.5 2.9 1.4 4L5.68 8.56c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L9.11 8.14c1.1.9 2.5 1.4 4 1.4s2.9-.5 4-1.4l2.02 1.83c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41zM12 2c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4z"/></svg>Gas
                    </button>
                    <button class="ctrl-btn quick-expense-btn glass" data-expense="Coffee" style="width:100%; height:auto; padding: 16px 12px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-2h2c1.11 0 2-.9 2-2V5c0-1.11-.89-2-2-2zm-4 10c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V5h10v8zm4-4h-2V5h2v4z"/></svg>Coffee
                    </button>
                    <button class="ctrl-btn quick-expense-btn glass" data-expense="Cigarettes" style="width:100%; height:auto; padding: 16px 12px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M18 6h-2V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM8 4h8v2H8V4zm10 15H4V8h2v9h2V8h4v9h2V8h2v11z"/></svg>Cigarettes
                    </button>
                    <button class="ctrl-btn quick-expense-btn glass" data-expense="Baseball Cards" style="width:100%; height:auto; padding: 16px 12px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg>Cards
                    </button>
                    <button class="ctrl-btn quick-expense-btn glass" data-expense="Groceries" style="width:100%; height:auto; padding: 16px 12px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M7 4V2c0-.55-.45-1-1-1s-1 .45-1 1v2H3c-.55 0-1 .45-1 1s.45 1 1 1h1v10c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V6h1c.55 0 1-.45 1-1s-.45-1-1-1h-2V2c0-.55-.45-1-1-1s-1 .45-1 1v2H7zm2 2h6v8H9V6z"/></svg>Groceries
                    </button>
                    <button class="ctrl-btn" id="customExpenseBtn" style="width:100%; height:auto; padding: 12px; grid-column: 1 / -1;">Custom</button>
                </div>
                <form id="expenseForm" style="display: none;">
                    <input type="text" id="expenseDescription" placeholder="e.g., Lunch" required>
                    <input type="number" id="expenseAmount" placeholder="$ Amount" step="0.01" required>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <button type="button" id="cancelCustomExpenseBtn">Cancel</button>
                        <button type="submit">Log Expense</button>
                    </div>
                </form>
            </div>
        </div>
        <div class="dashboard-row" id="theTabRow">
            <details id="theTabCard" class="card glass">
                <summary>The Tab</summary>
                <div class="debt-content-wrapper">
                    <div id="debtList" class="debt-list">
                        </div>
                    <div class="debt-form-container">
                        <h3>Log a New Debt</h3>
                        <form id="addDebtForm">
                            <input type="text" id="debtName" placeholder="Who owes you?" required>
                            <input type="number" id="debtAmount" placeholder="Amount ($)" step="0.01" required>
                            <input type="date" id="debtDate" required>
                            <textarea id="debtNotes" placeholder="Notes (e.g., for lunch)"></textarea>
                            <button type="submit">Log Debt</button>
                        </form>
                    </div>
                </div>
                <div class="card-footer" style="display: block; text-align: center;">
                    <button id="tabArchiveBtn" class="link-button">View Tab Archive</button>
                </div>
            </details>
        </div>
    </div>

    <details id="billTrackerCard" class="card glass" role="main">
      <summary>Upcoming Bills (Next 10 Days)</summary>
      <div>
          <div class="bill-table-wrapper">
            <table class="bill-table" id="billList">
                <thead id="billListHead">
                    <tr><th>Due Date</th><th>Bill Details</th><th>Notes</th><th>Amount</th><th style-align: right;>Actions</th></tr>
                </thead>
                <tbody id="billListBody"></tbody>
            </table>
            <div class="no-bills-message" id="noBillsMessage"><p>No upcoming bills. Add one to get started! </p></div>
          </div>
      </div>
    </details>

    <div class="add-bill-container">
        <button id="addBillBtnHeader" class="add-bill-header-btn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="14" height="14" fill="currentColor" style="vertical-align: middle; margin-right: 8px;"><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2h6z"></path></svg><span class="add-bill-text">Add Bill</span>
        </button>
    </div>

    <details id="pastBillsCard" class="card glass">
        <summary>Past Bills</summary>
        <div>
            <div class="bill-table-wrapper">
                <table class="bill-table" id="pastBillsTable">
                    <thead><tr><th>Due Date</th><th>Bill Details</th><th>Notes</th><th>Amount</th><th style="text-align: right;">Actions</th></tr></thead>
                    <tbody id="pastBillsListBody"></tbody>
                </table>
                 <div class="no-bills-message" id="noPastBillsMessage" style="display: none;"><p>No paid bills yet.</p></div>
            </div>
            <div class="card-footer">
                <button id="archiveBtn" class="btn-success">View Full Archive</button>
            </div>
        </div>
    </details>

    <div id="calendarView" class="card glass" style="display: none;"></div>
  </div>

  <div id="archiveView" class="app" style="display: none; flex-direction: column;">
    <main class="card glass" role="main">
        <details id="archive-filters">
            <summary>Filter & Search</summary>
            <div class="filter-grid">
                <label>Search Term <input type="text" id="filterSearchTerm" placeholder="e.g., Netflix..."></label>
                <label>Start Date <input type="date" id="filterStartDate"></label>
                <label>End Date <input type="date" id="filterEndDate"></label>
                <label>Category <select id="filterCategory"></select></label>
                <button id="clearFiltersBtn" class="ctrl-btn" style="width: auto; height: 38px; align-self: end; padding: 0 16px;">Clear</button>
            </div>
        </details>
        <div class="bill-table-wrapper" id="archive-table-wrapper">
            <table class="bill-table" id="archiveBillsTable">
                <tbody id="archiveBillsListBody"></tbody>
            </table>
            <div class="no-bills-message" id="noArchivedBillsMessage" style="display: none;"><p>No archived bills found.</p></div>
        </div>
    </main>
    <div class="add-bill-container">
        <button id="backFromArchiveBtn" class="add-bill-header-btn"> Go Back</button>
    </div>
  </div>

  

  <div id="statisticsView" class="app" style="display: none; flex-direction: column;">
    <header class="title-wrap glass">
      <h1><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M3.5 18.5C4.22 18.5 4.85 18.22 5.33 17.74L17.74 5.33C18.22 4.85 18.5 4.22 18.5 3.5C18.5 2.67 17.83 2 17 2C16.17 2 15.5 2.67 15.5 3.5C15.5 4.22 15.78 4.85 16.26 5.33L3.85 17.74C3.37 18.22 3 18.83 3 19.5V20H10V18.5H3.5M19 12V15L22 12L19 9V12M17 16V19L20 16L17 13V16M13 16H15V18H13V16M9 12H11V14H9V12M5 8H7V10H5V8Z"/></svg>Statistics</h1>
      <div class="header-controls desktop-stats-controls">
        <select id="statsTimeRange" class="ctrl-btn" style="width: auto; padding: 0 10px;"><option value="7">Last 7 Days</option><option value="30" selected>Last 30 Days</option><option value="90">Last 90 Days</option><option value="365">This Year</option><option value="all">All Time</option></select>
        <select id="statsCategory" class="ctrl-btn" style="width: auto; padding: 0 10px;"><option value="all">All Categories</option></select>
      </div>
      <div class="header-controls mobile-stats-controls">
        <button id="statsFilterBtn" class="ctrl-btn" title="Filter Statistics">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14,12V19.88C14.04,20.18 13.94,20.5 13.71,20.71C13.32,21.1 12.69,21.1 12.3,20.71L10.29,18.7C10.06,18.47 9.96,18.16 10,17.87V12H14M15,9H9V4H15V9M17,2H7A2,2 0 0,0 5,4V9A2,2 0 0,0 7,11H10V17L12,19L14,17V11H17A2,2 0 0,0 19,9V4A2,2 0 0,0 17,2Z" /></svg>
            <span>Filter</span>
        </button>
      </div>
    </header>
    <main class="dashboard-container" style="flex-grow: 1; overflow-y: auto; padding: 0 10px 10px; gap: 16px;">
      
      <!-- Key Summary Metrics -->
      <div class="dashboard-row summary-metrics">
        <div class="summary-card glass"><h3>Total Income</h3><div id="statsTotalIncome" class="amount" style="color: var(--ok);">$0.00</div></div>
        <div class="summary-card glass"><h3>Total Expenses</h3><div id="statsTotalExpenses" class="amount" style="color: var(--danger);">$0.00</div></div>
        <div class="summary-card glass"><h3>Net Balance</h3><div id="statsNetBalance" class="amount" style="color: var(--accent);">$0.00</div></div>
        <div class="summary-card glass"><h3>Bills Paid</h3><div id="statsBillsPaid" class="amount">0 / 0</div></div>
      </div>

      <!-- Charts & Visualizations -->
      <div class="dashboard-row charts">
        <div class="card glass" style="min-height: 300px; display: flex; flex-direction: column;">
          <h2>Spending by Category</h2>
          <div class="chart-placeholder" style="flex-grow: 1; display: grid; place-items: center; color: var(--muted); position: relative;"><canvas id="categoryPieChart"></canvas></div>
        </div>
        <div class="card glass" style="min-height: 300px; display: flex; flex-direction: column;">
          <h2>Expenses Over Time</h2>
          <div class="chart-placeholder" style="flex-grow: 1; display: grid; place-items: center; color: var(--muted); position: relative;"><canvas id="expensesLineChart"></canvas></div>
        </div>
        <div class="card glass" style="min-height: 300px; display: flex; flex-direction: column;">
          <h2>Upcoming vs Paid Bills</h2>
          <div class="chart-placeholder" style="flex-grow: 1; display: grid; place-items: center; color: var(--muted); position: relative;"><canvas id="billsBarChart"></canvas></div>
        </div>
        <div class="card glass" style="min-height: 300px; display: flex; flex-direction: column;">
          <h2>Cash Flow Projection</h2>
          <div class="chart-placeholder" style="flex-grow: 1; display: grid; place-items: center; color: var(--muted); position: relative;"><canvas id="cashFlowLineChart"></canvas></div>
        </div>
      </div>

      <!-- Tables/Lists -->
      <div class="dashboard-row tables">
        <div id="topCategoriesCard" class="card glass">
          <h2>Top Expense Categories</h2>
          <div id="topCategoriesList" class="table-placeholder" style="padding: 10px; color: var(--muted); text-align: left;">
            <!-- Dynamic Content -->
          </div>
        </div>
        <div id="largestExpensesCard" class="card glass">
          <h2>Largest Single Expenses</h2>
          <div id="largestExpensesList" class="table-placeholder" style="padding: 10px; color: var(--muted); text-align: left;">
            <!-- Dynamic Content -->
          </div>
        </div>
        <div id="recurringBillsCard" class="card glass">
          <h2>Recurring Bill Totals</h2>
          <div id="recurringBillsList" class="table-placeholder" style="padding: 10px; color: var(--muted); text-align: left;">
            <!-- Dynamic Content -->
          </div>
        </div>
      </div>

      <!-- Debt/Tab Stats -->
      <div class="dashboard-row">
        <div id="debtStatsCard" class="card glass" style="width: 100%;">
          <h2>Debt / "The Tab" Stats</h2>
          <div id="debtStatsList" class="debt-stats-placeholder" style="padding: 10px; color: var(--muted); display: grid; grid-template-columns: 1fr 1fr; gap: 16px; text-align: left;">
            <!-- Dynamic Content -->
          </div>
        </div>
      </div>

    </main>
  </div>

  <div id="statsFilterModal" class="modal-overlay">
    <div class="modal-content glass" style="max-width: 320px;">
      <h2>Filter Statistics</h2>
      <div class="modal-form" style="grid-template-columns: 1fr; gap: 16px;">
        <div class="form-row">
            <label for="modalStatsTimeRange">Time Range</label>
            <select id="modalStatsTimeRange" class="ctrl-btn" style="width: 100%; padding: 8px 10px; height: auto;"></select>
        </div>
        <div class="form-row">
            <label for="modalStatsCategory">Category</label>
            <select id="modalStatsCategory" class="ctrl-btn" style="width: 100%; padding: 8px 10px; height: auto;"></select>
        </div>
      </div>
      <div class="modal-buttons" style="margin-top: 24px;">
        <button type="button" class="cancel-btn" id="closeStatsFilterModalBtn">Done</button>
      </div>
    </div>
  </div>

  <div id="goalsView" class="app" style="display: none; flex-direction: column;">
    <header class="title-wrap glass">
      <h1><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>AI Goal System</h1>
      <div class="header-controls">
        <button id="addGoalBtn" class="ctrl-btn" title="Add New Goal" style="width: auto; padding: 8px 16px;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px; margin-right: 8px;"><path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z"></path></svg>
          <span>New Goal</span>
        </button>
      </div>
    </header>
    <main class="dashboard-container" style="flex-grow: 1; overflow-y: auto; padding: 0 10px 10px; gap: 16px;">
      
      <!-- Goals Dashboard -->
      <div id="goalsDashboard" class="dashboard-row">
        <div class="summary-card glass">
          <h3>Active Goals</h3>
          <div id="activeGoalsCount" class="amount" style="color: var(--accent);">0</div>
        </div>
        <div class="summary-card glass">
          <h3>Total Saved</h3>
          <div id="totalSaved" class="amount" style="color: var(--ok);">$0.00</div>
        </div>
        <div class="summary-card glass">
          <h3>Total Goal Amount</h3>
          <div id="totalGoalAmount" class="amount" style="color: var(--muted);">$0.00</div>
        </div>
      </div>

      <!-- Active Goals List -->
      <div class="dashboard-row">
        <div id="activeGoalsCard" class="card glass" style="width: 100%;">
          <div class="card-header">
            <h2>Your Financial Goals</h2>
          </div>
          <div id="activeGoalsList" class="goals-list">
            <div class="no-goals-message" id="noGoalsMessage">
              <p> No goals yet! Create your first financial goal to get started.</p>
              <button id="createFirstGoalBtn" class="btn-primary" style="margin-top: 10px;">Create Your First Goal</button>
            </div>
          </div>
        </div>
      </div>

    </main>
  </div>

  <div id="goalCreationModal" class="modal-overlay">
    <div class="modal-content glass">
      <h2>Create New Goal</h2>
      <form id="goalCreationForm" class="goal-form" style="border-bottom: none; padding-bottom: 0;">
          <div class="form-row">
            <label for="goalName">Goal Name</label>
            <input type="text" id="goalName" placeholder="e.g., Emergency Fund, Vacation" required>
          </div>
          <div class="form-row">
            <label for="goalAmount">Goal Amount ($)</label>
            <input type="number" id="goalAmount" placeholder="5000" min="1" step="0.01" required>
          </div>
          <div class="form-row">
            <label for="goalEndDate">Target Date</label>
            <input type="date" id="goalEndDate" required>
          </div>
          <div class="form-row">
            <label for="goalNotes">Notes (Optional)</label>
            <textarea id="goalNotes" placeholder="What is this goal for?"></textarea>
          </div>
          <div class="form-row">
            <label class="checkbox-label">
              <input type="checkbox" id="makeDownPayment">
              <span class="checkmark"></span>
              Make a down payment today (will reduce future payments)
            </label>
          </div>
          <div id="downPaymentAmount" class="form-row" style="display: none;">
            <label for="downPaymentInput">Down Payment Amount</label>
            <input type="number" id="downPaymentInput" placeholder="0.00" min="0" step="0.01">
          </div>
          <div id="feasibilityCheck" class="feasibility-feedback" style="display: none;">
            <!-- AI feasibility analysis will be displayed here -->
          </div>
          <div id="paymentSchedulePreview" class="payment-schedule-preview" style="display: none;">
            <h4> Proposed Payment Schedule (Based on Your Paydays)</h4>
            <div id="scheduleList" class="schedule-list"></div>
            <div class="schedule-summary">
              <strong>Total: <span id="scheduleTotalAmount">$0.00</span> over <span id="scheduleTotalPayments">0</span> payments</strong>
            </div>
          </div>
          <div class="form-actions modal-buttons">
            <button type="button" id="cancelGoalBtn" class="cancel-btn">Cancel</button>
            <button type="button" id="previewGoalBtn" class="save-btn" style="display: none;">Create</button>
            <button type="submit" id="createGoalBtn" class="save-btn" style="display: none;"> Confirm & Create Goal</button>
          </div>
        </form>
    </div>
  </div>

  <div id="editModal" class="modal-overlay"><div class="modal-content glass"><h2 id="editModalTitle">Edit Bill</h2><div class="modal-form"><label for="editBillName">Bill Name</label><input type="text" id="editBillName" class="full-width"><label for="editBillAmount">Total Amount</label><input type="number" step="0.01" id="editBillAmount" class="full-width"><label for="editBillDate">Due Date</label><input type="date" id="editBillDate" class="full-width"><label for="editBillCategory">Category</label><select id="editBillCategory" class="full-width"></select><label for="editBillFrequency">Frequency</label><select id="editBillFrequency" class="full-width"></select><div id="editCustomFrequencyWrapper" class="full-width" style="display: none;"><input type="number" id="editBillCustomFrequency" placeholder="Every X Days" style="width: 100%;"></div><label for="editBillNotes">Notes</label><textarea id="editBillNotes" class="full-width"></textarea><div id="editSplitBillInputs" class="full-width"><hr><label>Split Info</label><input type="text" id="editBillSplitName" placeholder="Split with (Name)"><input type="number" id="editBillSplitAmount" placeholder="Their Share ($)"></div><div class="modal-buttons"><button type="button" class="cancel-btn" id="closeModalBtn">Cancel</button><button type="button" class="save-btn" id="saveEditBtn">Save Changes</button></div></div></div></div>

  <div id="dayBreakdownModal" class="modal-overlay">
    <div class="modal-content glass">
      <h2 id="dayBreakdownTitle">Day Breakdown</h2>
      <div id="dayBreakdownContent"></div>
      <div class="modal-buttons">
        <button type="button" class="cancel-btn" id="closeDayBreakdownModalBtn">Close</button>
      </div>
    </div>
  </div>

  <div id="addBillModal" class="modal-overlay">
    <div class="modal-content glass">
      <h2>Add New Bill</h2>
      <form class="add-bill-form" id="addBillForm" style="border-bottom: none; padding-bottom: 0;">
          <input id="billName" type="text" placeholder="Bill Name (e.g., Netflix)" required class="full-width" />
          <input id="billAmount" type="number" placeholder="Total Amount ($)" step="0.01" min="0" />
          <input id="billDate" type="date" required />
          <select id="billFrequency"><option>One-Time</option><option>Weekly</option><option>Bi-Weekly</option><option selected>Monthly</option><option>Quarterly</option><option>Annually</option><option>Custom</option></select>
          <select id="billCategory"><option>Utilities</option><option>Subscription</option><option>Rent/Mortgage</option><option>Loan</option><option>Insurance</option><option>Groceries</option><option>Personal</option><option>Other</option><option value="Expense">Expense</option></select>
          <div id="customFrequencyWrapper" class="full-width" style="display: none;">
            <input type="number" id="billCustomFrequency" placeholder="Every X Days" style="width: 100%;">
          </div>
          <input id="billNotes" type="text" placeholder="Notes (optional)" class="full-width" />
          <div id="splitBillInputs" class="full-width"><input type="text" id="billSplitName" placeholder="Split with (Name)"><input type="number" id="billSplitAmount" placeholder="Their Share ($)"></div>
          <div class="modal-buttons full-width">
            <button type="button" class="cancel-btn" id="closeAddBillModalBtn">Cancel</button>
            <button id="addBtn" type="button" class="save-btn">Add Bill</button>
          </div>
      </form>
    </div>
  </div>

    <div id="expenseModal" class="modal-overlay">
      <div class="modal-content glass">
        <h2>Log an Expense</h2>
        <div id="expenseModalContent">
            <div id="expenseModalQuickOptions" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <button class="ctrl-btn quick-expense-btn glass" data-expense="Food" style="width:100%; height:auto; padding: 16px 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>Food
                </button>
                <button class="ctrl-btn quick-expense-btn glass" data-expense="Gas" style="width:100%; height:auto; padding: 16px 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M18.32 8.56L16.9 7.14c.9-1.1 1.4-2.5 1.4-4 0-3.31-2.69-6-6-6S6.3.69 6.3 4c0 1.5.5 2.9 1.4 4L5.68 8.56c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L9.11 8.14c1.1.9 2.5 1.4 4 1.4s2.9-.5 4-1.4l2.02 1.83c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41zM12 2c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4z"/></svg>Gas
                </button>
                <button class="ctrl-btn quick-expense-btn glass" data-expense="Coffee" style="width:100%; height:auto; padding: 16px 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-2h2c1.11 0 2-.9 2-2V5c0-1.11-.89-2-2-2zm-4 10c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V5h10v8zm4-4h-2V5h2v4z"/></svg>Coffee
                </button>
                <button class="ctrl-btn quick-expense-btn glass" data-expense="Cigarettes" style="width:100%; height:auto; padding: 16px 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M18 6h-2V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM8 4h8v2H8V4zm10 15H4V8h2v9h2V8h4v9h2V8h2v11z"/></svg>Cigarettes
                </button>
                <button class="ctrl-btn quick-expense-btn glass" data-expense="Baseball Cards" style="width:100%; height:auto; padding: 16px 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg>Cards
                </button>
                <button class="ctrl-btn quick-expense-btn glass" data-expense="Groceries" style="width:100%; height:auto; padding: 16px 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M7 4V2c0-.55-.45-1-1-1s-1 .45-1 1v2H3c-.55 0-1 .45-1 1s.45 1 1 1h1v10c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V6h1c.55 0 1-.45 1-1s-.45-1-1-1h-2V2c0-.55-.45-1-1-1s-1 .45-1 1v2H7zm2 2h6v8H9V6z"/></svg>Groceries
                </button>
                <button class="ctrl-btn" id="customExpenseModalBtn" style="width:100%; height:auto; padding: 12px; grid-column: 1 / -1;">Custom</button>
            </div>
            <form id="expenseModalForm" style="display: none; flex-direction: column; gap: 10px; margin-top: 10px;">
                <input type="text" id="expenseModalDescription" placeholder="e.g., Lunch" required>
                <input type="number" id="expenseModalAmount" placeholder="$ Amount" step="0.01" required>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <button type="button" id="cancelCustomExpenseModalBtn">Cancel</button>
                    <button type="submit">Log Expense</button>
                </div>
            </form>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button type="button" class="cancel-btn" id="closeExpenseModalBtn">Close</button>
        </div>
      </div>
    </div>

    <!-- Income Management Modal -->
    <div id="incomeModal" class="modal-overlay">
      <div class="modal-content glass">
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 2px solid var(--accent);">
          <div style="font-size: 24px;"></div>
          <h2 style="margin: 0; color: var(--text); font-weight: 700;">Manage Income Streams</h2>
        </div>
        <div id="incomeModalContent">
            <div class="income-list" id="incomeList">
                <!-- Income items will be populated here -->
            </div>
            <div class="income-actions" style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border);">
                <button id="addIncomeBtn" class="ctrl-btn" style="width: 100%; background: linear-gradient(135deg, var(--accent), #059669); color: white; padding: 16px; border-radius: var(--border-radius); font-weight: 700; font-size: 16px; box-shadow: 0 4px 15px rgba(5, 150, 105, 0.3); transition: all 0.3s ease;">
                     Add New Income Stream
                </button>
            </div>
        </div>
        <div class="modal-buttons" style="margin-top: 24px;">
          <button type="button" class="cancel-btn" id="closeIncomeModalBtn" style="padding: 12px 24px; border-radius: var(--border-radius); font-weight: 600;">Close</button>
        </div>
      </div>
    </div>

  <div class="menu-panel glass" id="menuPanel" aria-hidden="true">
    <div class="section"><details><summary>Profiles</summary>
        <div class="content">
          <div id="profilesList">
            <!-- Profiles will be dynamically generated here -->
          </div>
          <div class="profile-item add-profile">
            <button class="add-profile-btn" id="addProfileBtn"> Add Profile</button>
            <div class="profile-creation-options" id="profileCreationOptions" style="display: none;">
              <div class="profile-option-btn" id="createNewProfileBtn">
                <span class="option-icon"></span>
                <span class="option-text">Start Fresh Profile</span>
              </div>
              <div class="profile-option-btn" id="importProfileBtn">
                <span class="option-icon"></span>
                <span class="option-text">Import Profile</span>
              </div>
            </div>
          </div>
        </div>
    </details></div>
    <div class="section"><details><summary>Personalize</summary>
        <div class="content">
          <div class="stack" style="margin-top: 16px;">
            <div class="theme-preview-grid">
              <div class="theme-preview-card" data-theme="light">
                <div class="preview-header"></div>
                <div class="preview-content">
                  <div class="preview-line"></div>
                  <div class="preview-line short"></div>
                </div>
                <span class="preview-label">Light</span>
              </div>
              <div class="theme-preview-card" data-theme="dark">
                <div class="preview-header dark"></div>
                <div class="preview-content dark">
                  <div class="preview-line dark"></div>
                  <div class="preview-line short dark"></div>
                </div>
                <span class="preview-label">Dark</span>
              </div>
              <div class="theme-preview-card" data-theme="auto">
                <div class="preview-header auto"></div>
                <div class="preview-content auto">
                  <div class="preview-line auto"></div>
                  <div class="preview-line short auto"></div>
                </div>
                <span class="preview-label">Auto</span>
              </div>
            </div>
          </div>
          <div class="stack" style="margin-top: 16px;">
            <label for="accentColorPicker">Accent Color</label>
            <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
              <button class="accent-color-btn" data-color="#34c759" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--border); background: #34c759; cursor: pointer;"></button>
              <button class="accent-color-btn" data-color="#007aff" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--border); background: #007aff; cursor: pointer;"></button>
              <button class="accent-color-btn" data-color="#ff3b30" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--border); background: #ff3b30; cursor: pointer;"></button>
              <button class="accent-color-btn" data-color="#ff9500" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--border); background: #ff9500; cursor: pointer;"></button>
              <button class="accent-color-btn" data-color="#af52de" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--border); background: #af52de; cursor: pointer;"></button>
              <button class="accent-color-btn" data-color="#5ac8fa" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--border); background: #5ac8fa; cursor: pointer;"></button>
            </div>
          </div>
        </div>
    </details></div>
    <div class="section"><details><summary>Utility</summary><div class="content">
      <div class="stack">
        <div class="utility-toggle-label">
          <div class="utility-toggle" id="disableAutoOpenCurrentBillsToggle"></div>
          <span>Disable auto-opening current bills on startup</span>
        </div>
        <div class="hr"></div>
        <button id="resetProfileBtn" class="ctrl-btn" style="width: 100%; height: auto; padding: 10px; margin-top: 5px;">Reset to Factory Defaults</button>
        <div class="utility-toggle-label">
          <div class="utility-toggle" id="blurSummaryToggle"></div>
          <span>Blur Summary Amounts</span>
        </div>
        <div class="utility-toggle-label">
          <div class="utility-toggle" id="dailyBalanceInCalendarToggle"></div>
          <span>Daily Balance in Calendar</span>
        </div>
        <div class="utility-toggle-label">
          <div class="utility-toggle" id="disableBackMonthNavToggle"></div>
          <span>Disable back month navigation in calendar</span>
        </div>
        <div class="utility-toggle-label">
          <div class="utility-toggle" id="disableLandscapeModeToggle"></div>
          <span>Disable landscape mode on mobile</span>
        </div>
      </div>
      <div class="hr"></div>
      <div class="sub-section"><details open><summary>Experimental Tools</summary><div class="content"><div class="stack">
        <label for="unpaidDays" style="text-align: left; font-size: 14px; font-weight: 600;">Mark bills unpaid after X days:</label>
        <div style="display: grid; grid-template-columns: 1fr auto; gap: 10px;">
            <input type="number" id="unpaidDays" value="30" style="padding: 8px 10px; border: 1px solid var(--border); border-radius: calc(var(--border-radius) / 2); background: var(--bg); color: var(--text);">
            <button id="unpaidToolBtn" class="ctrl-btn" style="width: auto; height: 38px; padding: 0 16px; background-color: var(--pending-text); color: var(--pending);">Run</button>
        </div>
        <div class="hr"></div>
        <div>
            <p style="font-size:12px;color:var(--muted);margin:4px 0 10px;">Generate a realistic, randomized profile of a heavy user to see the app's full potential.</p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button id="demoModeBtn" class="ctrl-btn" style="width:100%; height:auto; padding: 10px; background-color: var(--accent); color: white;">Enable Demo Mode</button>
                <button id="deactivateDemoBtn" class="ctrl-btn" style="width:100%; height:auto; padding: 10px;">Deactivate</button>
            </div>
        </div>
      </div></div></details></div>
    </div></details></div>
    <div class="section" id="devSection" style="display: none;"><details><summary>Dev</summary><div class="content">
      <div class="sub-section"><details><summary>Premium Features</summary><div class="content"><div class="stack"><p style="font-size:12px;color:var(--muted);margin:4px 0 0;">Enable premium features and permissions for advanced functionality.</p><div style="margin-top: 10px;">
          <div class="utility-toggle-label">
            <div class="utility-toggle" id="enablePremiumToggle"></div>
            <span>Premium</span>
          </div>
          <p style="font-size:11px;color:var(--muted);margin:4px 0 0;font-style:italic;">When enabled, permissions will be granted for certain premium options.</p>
          <div class="hr" style="margin: 15px 0;"></div>
          <div class="utility-toggle-label">
            <div class="utility-toggle" id="enableMultipleIncomeToggle"></div>
            <span>Multiple Incomes</span>
          </div>
          <p style="font-size:11px;color:var(--muted);margin:4px 0 0;font-style:italic;">Allow unlimited additional income streams. When disabled, additional incomes are hidden but preserved.</p>
          <div class="hr" style="margin: 15px 0;"></div>
          <div class="utility-toggle-label">
            <div class="utility-toggle" id="limitDailyBalanceToggle"></div>
            <span>Show unlimited future balance projections</span>
          </div>
          <p style="font-size:11px;color:var(--muted);margin:4px 0 0;font-style:italic;">Premium feature: See balance projections beyond 60 days.</p>
          <div class="hr" style="margin: 15px 0;"></div>
          <div class="utility-toggle-label">
            <div class="utility-toggle" id="enableCalendarPrintToggle"></div>
            <span>Enable calendar print functionality</span>
          </div>
          <p style="font-size:11px;color:var(--muted);margin:4px 0 0;font-style:italic;">Premium feature: Print your calendar view.</p>
        </div></div></div></details></div>
      <div class="sub-section"><details><summary>Date Override Tool</summary><div class="content"><div class="stack"><p style="font-size:12px;color:var(--muted);margin:4px 0 0;">Override the current date for testing purposes. This affects all date-dependent features including payday advancement, calendar calculations, and bill due dates.</p><div style="margin-top: 10px;">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <input type="date" id="dateOverrideInput" style="flex: 1; padding: 8px; border: 1px solid var(--border); border-radius: var(--border-radius); background: var(--bg); color: var(--text);">
            <button id="setDateOverrideBtn" class="ctrl-btn" style="padding: 8px 16px;">Set</button>
            <button id="resetDateOverrideBtn" class="ctrl-btn" style="padding: 8px 16px;">Reset</button>
          </div>
          <div id="dateOverrideStatus" style="font-size: 11px; color: var(--muted); padding: 5px; background: var(--surface); border-radius: var(--border-radius);">
            <span id="currentDateDisplay">Current date: <span id="currentDateValue"></span></span>
            <div id="overrideDateDisplay" style="display: none; margin-top: 5px;">
              <span style="color: var(--accent); display: flex; align-items: center; gap: 4px;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>
                </svg>
                Override active: <span id="overrideDateValue"></span>
              </span>
            </div>
          </div>
        </div></div></div></details></div>
      <div class="sub-section"><details><summary>Push Notification Test</summary><div class="content"><div class="stack"><p style="font-size:12px;color:var(--muted);margin:4px 0 0;">Test push notification functionality. This will send a test notification to verify the push notification system is working correctly.</p><div style="margin-top: 10px;">
          <button id="testNotificationBtn" class="ctrl-btn" style="width: 100%; height: auto; padding: 10px; background-color: var(--accent); color: white;">Send Test Notification</button>
          <div id="notificationStatus" style="font-size: 11px; color: var(--muted); padding: 5px; background: var(--surface); border-radius: var(--border-radius); margin-top: 10px; display: none;">
            <span id="notificationStatusText"></span>
          </div>
        </div></div></div></details></div>
      <div class="sub-section"><details><summary>Income System Migration</summary><div class="content"><div class="stack"><p style="font-size:12px;color:var(--muted);margin:4px 0 0;">Convert all legacy income entries to the modern immutable payday system. This will preserve all your income data while upgrading to the new system.</p><div style="margin-top: 10px;">
          <button id="convertLegacyIncomeBtn" class="ctrl-btn" style="width: 100%; height: auto; padding: 10px; background-color: var(--accent); color: white;">Convert Legacy Income to Modern</button>
          <div id="legacyConversionStatus" style="font-size: 11px; color: var(--muted); padding: 5px; background: var(--surface); border-radius: var(--border-radius); margin-top: 10px; display: none;">
            <span id="legacyConversionStatusText"></span>
          </div>
          <div class="hr" style="margin: 15px 0;"></div>
          <button id="testEmojiSupportBtn" class="ctrl-btn" style="width: 100%; height: auto; padding: 10px; background-color: var(--pending-text); color: var(--pending);">Test Emoji Support</button>
          <div id="emojiTestStatus" style="font-size: 11px; color: var(--muted); padding: 5px; background: var(--surface); border-radius: var(--border-radius); margin-top: 10px; display: none;">
            <span id="emojiTestStatusText"></span>
          </div>
        </div></div></div></details></div>
      <div class="sub-section"><details><summary>Data Management</summary><div class="content"><div class="stack"><p style="font-size:12px;color:var(--muted);margin:4px 0 0;">Import or export your full application profile. This includes all bills, settings, and appearance customizations.</p><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;"><button id="importProfileBtn" class="ctrl-btn" style="width:100%; height:auto; padding: 10px;">Import Profile</button><button id="exportProfileBtn" class="ctrl-btn" style="width:100%; height:auto; padding: 10px;">Export Profile</button></div></div></div></details></div>
      <div class="sub-section"><details><summary>Organizational Sections</summary><div class="content"><div class="stack"><p style="font-size:12px;color:var(--muted);margin:4px 0 0;">Organize your dashboard sections. Choose which sections to show and in what order they appear on mobile.</p><div id="dashboardSectionsList" class="stack" style="margin-top: 10px;"></div><div class="hr"></div><button id="resetDashboardOrderBtn" class="ctrl-btn" style="width: 100%; height: auto; padding: 10px; margin-top: 5px; background-color: var(--accent); color: white;">Reset to Default Order</button></div></div></details></div>
      <div class="sub-section"><details><summary>Appearance</summary><div class="content">
        <div class="sub-section"><details><summary>Theme & Colors</summary><div class="content">
          <div class="stack">
            <label for="themeSelect">Appearance</label>
            <select id="themeSelect" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text);">
              <option value="light">Light</option>
              <option value="dark">Dark</option>
              <option value="auto">Auto (System)</option>
            </select>
          </div>
        </div></details></div>
        <div class="sub-section"><details><summary>Advanced Settings</summary><div class="content">
          <div class="ios-toggle-row">
            <label for="dynamicAccentToggle">Dynamic Accent Color</label>
            <div class="ios-toggle">
              <input type="checkbox" id="dynamicAccentToggle" class="ios-toggle-input">
              <span class="ios-toggle-slider"></span>
            </div>
          </div>
          <p style="font-size: 12px; color: var(--muted); margin: 4px 0 0;">Use system accent color when available</p>
          
          <div class="ios-toggle-row">
            <label for="compactModeToggle">Compact Mode</label>
            <div class="ios-toggle">
              <input type="checkbox" id="compactModeToggle" class="ios-toggle-input">
              <span class="ios-toggle-slider"></span>
            </div>
          </div>
          <p style="font-size: 12px; color: var(--muted); margin: 4px 0 0;">Reduce spacing for power users</p>
          
          <div class="ios-toggle-row">
            <label for="motionControlToggle">Reduce Motion</label>
            <div class="ios-toggle">
              <input type="checkbox" id="motionControlToggle" class="ios-toggle-input">
              <span class="ios-toggle-slider"></span>
            </div>
          </div>
          <p style="font-size: 12px; color: var(--muted); margin: 4px 0 0;">Disable animations for accessibility</p>
          
        </div></details></div>
        <div class="sub-section"><details><summary>Accessibility</summary><div class="content">
          <div class="ios-toggle-row">
            <label for="reduceMotionToggle">Reduce Motion</label>
            <div class="ios-toggle">
              <input type="checkbox" id="reduceMotionToggle" class="ios-toggle-input">
              <span class="ios-toggle-slider"></span>
            </div>
          </div>
          <div class="ios-toggle-row">
            <label for="highContrastToggle">High Contrast</label>
            <div class="ios-toggle">
              <input type="checkbox" id="highContrastToggle" class="ios-toggle-input">
              <span class="ios-toggle-slider"></span>
            </div>
          </div>
          <div class="slider-row">
            <label for="textSizeSlider">Text Size</label>
            <input type="range" id="textSizeSlider" min="12" max="20" value="16" style="width: 100%;" />
            <span class="pct" id="textSizePct">16px</span>
          </div>
        </div></details></div>
        <div class="sub-section"><details><summary>User Interface</summary><div class="content"><div class="stack"><label for="uiStyleSelect">Style</label><select id="uiStyleSelect"></select></div><div class="slider-row"><label for="glassOpacity">Opacity</label><input type="range" id="glassOpacity" min="10" max="100" value="80" /><span class="pct" id="glassOpacityPct"></span></div><div class="slider-row"><label for="glassBlurSlider">Blur</label><input type="range" id="glassBlurSlider" min="0" max="20" value="8" /><span class="pct" id="glassBlurPct"></span></div><div class="slider-row"><label for="cornerRadiusSlider">Corner Radius</label><input type="range" id="cornerRadiusSlider" min="0" max="32" value="20" /><span class="pct" id="cornerRadiusPct"></span></div><div class="slider-row"><label for="glassShadowSlider">Glass Shadow</label><input type="range" id="glassShadowSlider" min="0" max="100" value="50" /><div id="shadowCue" class="shadow-cue"></div></div></div></details></div>
        <div class="sub-section"><details><summary>Animations</summary><div class="content"><label><input type="checkbox" id="enableNaturalSlide"> Natural Slide Animation</label><div class="slider-row"><label for="slideSpeed">Animation Speed</label><input type="range" id="slideSpeed" min="100" max="1500" value="1000"><span class="pct" id="slideSpeedPct"></span></div></div></details></div>
        <div class="sub-section"><details><summary>Background</summary><div class="content"><div class="stack"><label><input type="checkbox" id="enableCustomBackground">Enable Custom Background</label></div><div id="customBackgroundOptions" class="stack" style="display:none;"><div class="hr"></div><div class="stack"><label for="backgroundType">Type</label><select id="backgroundType"><option value="theme" selected>Theme</option><option value="image">Image</option><option value="color">Gradient</option></select></div><div id="imageWallpaperControls" style="display:none; margin-top: 10px;"><input type="file" id="wallpaperFile" accept="image/*" /></div><div id="colorWallpaperControls" class="stack" style="display:none; margin-top: 10px;"><label>Start Color: <input type="color" id="wallpaperColor3" value="#1e1b4b"></label><label>End Color: <input type="color" id="wallpaperColor2" value="#4c1d95"></label><div class="slider-row"><label for="gradientAngle">Angle</label><input type="range" id="gradientAngle" min="0" max="360" value="145"><span class="pct" id="gradientAnglePct"></span></div><div class="stack"><label><input type="checkbox" id="gradientSpinToggle">Enable Spinning</label><div class="slider-row" id="gradientSpinControls" style="display:none;"><label for="gradientSpinSpeed">Speed</label><input type="range" id="gradientSpinSpeed" min="1" max="100" value="10"><span class="pct" id="gradientSpinSpeedPct"></span></div></div></div></div><div class="hr"></div><div class="stack"><label><input type="checkbox" id="enableAmbiance">Enable Live Effects</label><div id="ambianceSettings" class="stack" style="display:none; margin-top: 10px;"><select id="ambianceSelect"><option value="none" selected>None</option><option value="snowflakes">Snowflakes</option><option value="orbs">Orbs</option><option value="starfield">Starfield</option></select><div id="ambianceControls" class="stack" style="display:none; border:1px solid var(--border); border-radius:8px; padding:10px; gap: 10px;"><div id="snowControls" class="stack" style="display:none;"><div class="slider-row"><label>Density</label><input type="range" id="snowDensity" min="0" max="300" value="100"><span class="pct" id="snowDensityPct"></span></div><div class="slider-row"><label>Size</label><input type="range" id="snowSize" min="10" max="40" value="20"><span class="pct" id="snowSizePct"></span></div><div class="slider-row"><label>Speed</label><input type="range" id="snowSpeed" min="10" max="100" value="30"><span class="pct" id="snowSpeedPct"></span></div></div><div id="orbsControls" class="stack" style="display:none;"><div class="slider-row"><label>Density</label><input type="range" id="orbsDensity" min="10" max="150" value="40"><span class="pct" id="orbsDensityPct"></span></div><div class="slider-row"><label>Size</label><input type="range" id="orbsSize" min="20" max="150" value="70"><span class="pct" id="orbsSizePct"></span></div><div class="slider-row"><label>Speed</label><input type="range" id="orbsSpeed" min="5" max="100" value="20"><span class="pct" id="orbsSpeedPct"></span></div><label>Color: <input type="color" id="orbsColor" value="#9aa4b2"></label></div><div id="starfieldControls" class="stack" style="display:none;"><div class="slider-row"><label>Density</label><input type="range" id="starfieldDensity" min="50" max="1500" value="500"><span class="pct" id="starfieldDensityPct"></span></div><div class="slider-row"><label>Speed</label><input type="range" id="starfieldSpeed" min="1" max="100" value="25"><span class="pct" id="starfieldSpeedPct"></span></div></div></div>        </div></div></div></details></div>
      <div class="sub-section"><details><summary>Debug Tools</summary><div class="content"><div class="stack"><p style="font-size:12px;color:var(--muted);margin:4px 0 0;">Debug tools for testing and development. Use with caution as these actions affect your data.</p><div style="margin-top: 10px;">
          <button id="clearIncomeFromCalendarBtn" class="ctrl-btn" style="width: 100%; height: auto; padding: 10px; background-color: var(--danger); color: white; display: flex; align-items: center; justify-content: center; gap: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
            </svg>
            Delete All Income From Calendar
          </button>
          <div id="clearCalendarStatus" style="font-size: 11px; color: var(--muted); padding: 5px; background: var(--surface); border-radius: var(--border-radius); margin-top: 10px; display: none;">
            <span id="clearCalendarStatusText"></span>
          </div>
        </div></div></div></details></div>
      </div></details></div>
    </div></details></div>
    <div class="menu-notch">
      <button id="closeMenuNotch" aria-controls="menuPanel" aria-label="Close menu">Close menu</button>
      <div class="menu-footnote" id="menuFootnote" aria-hidden="true">Designed for productivity. Made by Noa.</div>
    </div>
  </div>

  <!-- iOS-style Bottom Navigation -->
  <nav class="bottom-nav" id="bottomNav">
    <button class="nav-item active" data-section="dashboard">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"/>
      </svg>
      <span>Dashboard</span>
    </button>
    <button class="nav-item" data-section="bills">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
      </svg>
      <span>Bills</span>
    </button>
    <button class="nav-item" data-section="calendar">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/>
      </svg>
      <span>Calendar</span>
    </button>
    <button class="nav-item" data-section="expenses">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z"/>
      </svg>
      <span>Expenses</span>
    </button>
    <button class="nav-item" data-section="settings">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.82,11.69,4.82,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
      </svg>
      <span>Settings</span>
    </button>
  </nav>

  <div id="genericModal" class="modal-overlay">
    <div class="modal-content glass">
      <h2 id="genericModalTitle"></h2>
      <div id="genericModalContent">
        <p id="genericModalText" style="line-height: 1.5; margin: 16px 0;"></p>
      </div>
      <div class="modal-buttons" id="genericModalButtons"></div>
    </div>
  </div>

  <div id="tabArchiveModal" class="modal-overlay">
    <div class="modal-content glass">
      <h2>Tab Archive</h2>
      <div id="tabArchiveModalContent" class="bill-table-wrapper" style="max-height: 400px; overflow-y: auto;">
        <table class="bill-table">
          <thead>
            <tr>
              <th class="bill-name">Name</th>
              <th class="bill-amount">Amount</th>
              <th class="bill-date">Paid Date</th>
              <th class="bill-notes">Notes</th>
            </tr>
          </thead>
          <tbody id="tabArchiveModalListBody"></tbody>
        </table>
        <div class="no-bills-message" id="noArchivedTabsModalMessage" style="display: none;"><p>No archived tabs found.</p></div>
      </div>
      <div class="modal-buttons">
        <button type="button" class="cancel-btn" id="closeTabArchiveModalBtn">Close</button>
      </div>
    </div>
  </div>

  <div class="bottom-nav">
    <button id="dashboardTabBtn" class="bottom-nav-btn active">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M13,3V9H21V3M13,15H21V21H13M3,21H11V11H3M3,3H11V9H3"/></svg>
      <span>Dashboard</span>
    </button>
    <button id="goalsTabBtn" class="bottom-nav-btn">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>
      <span>Goals</span>
    </button>
    <button id="statisticsTabBtn" class="bottom-nav-btn">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3.5 18.5C4.22 18.5 4.85 18.22 5.33 17.74L17.74 5.33C18.22 4.85 18.5 4.22 18.5 3.5C18.5 2.67 17.83 2 17 2C16.17 2 15.5 2.67 15.5 3.5C15.5 4.22 15.78 4.85 16.26 5.33L3.85 17.74C3.37 18.22 3 18.83 3 19.5V20H10V18.5H3.5M19 12V15L22 12L19 9V12M17 16V19L20 16L17 13V16M13 16H15V18H13V16M9 12H11V14H9V12M5 8H7V10H5V8Z"/></svg>
      <span>Statistics</span>
    </button>
    
  </div>


<script>
// IFFE to encapsulate the entire application
(function(){
    "use strict";

    // ========== Font Size Control Functions ==========
    function updateCalendarFontSize(size) {
        // Update CSS custom property
        document.documentElement.style.setProperty('--calendar-balance-font-size', size + 'px');

        // Update display values
        const desktopValue = document.getElementById('fontSizeValue');
        const mobileValue = document.querySelector('.mobile-font-size-control .font-size-display');

        if (desktopValue) desktopValue.textContent = size + 'px';
        if (mobileValue) mobileValue.textContent = size + 'px';

        // Update slider values to stay in sync
        const desktopSlider = document.getElementById('calendarFontSize');
        const mobileSlider = document.getElementById('mobileCalendarFontSize');

        if (desktopSlider) desktopSlider.value = size;
        if (mobileSlider) mobileSlider.value = size;

        // Store preference in localStorage
        localStorage.setItem('calendarFontSize', size);
    }

    // Initialize font size controls
    function initFontSizeControls() {
        // Get stored preference or default to 6px
        const storedSize = localStorage.getItem('calendarFontSize') || 6;
        updateCalendarFontSize(storedSize);

        // Desktop control
        const desktopSlider = document.getElementById('calendarFontSize');
        if (desktopSlider) {
            desktopSlider.value = storedSize;
            desktopSlider.addEventListener('input', function(e) {
                updateCalendarFontSize(parseInt(e.target.value));
            });
        }

        // Mobile control
        const mobileSlider = document.getElementById('mobileCalendarFontSize');
        if (mobileSlider) {
            mobileSlider.value = storedSize;
            mobileSlider.addEventListener('input', function(e) {
                updateCalendarFontSize(parseInt(e.target.value));
            });
        }
    }

    // Initialize on DOM ready
    document.addEventListener('DOMContentLoaded', initFontSizeControls);
    // --- All JavaScript logic is included below ---

    // --- STATE & DOM ---
    let bills = [], debts = [], archivedDebts = [], userFinances = {}, currentView = 'list', calendarDate = new Date(), activeModalResolve = null, isAnimationRunning = true, carriedBalance = null;
    
    // Immutable Payday System
    let incomeSchedules = []; // ScheduleVersion objects
    let paydayMarkers = [];   // PaydayMarker objects  
    let paydayRecords = [];   // PaydayRecord objects
    let adjustments = [];     // Adjustment objects
    
    // Date override functionality for testing
    let dateOverride = null; // null means use real date, string means override date

    // Function to reset calendar to current month
    function resetCalendarToCurrentMonth() {
        calendarDate = new Date();
    }
    let touchStartX = 0, touchEndX = 0, touchStartY = 0, touchEndY = 0; // For swipe gestures
    const $ = (s) => document.getElementById(s);
    const billTrackerCard = $('billTrackerCard'), pastBillsCard = $('pastBillsCard'), calendarView = $('calendarView'), calendarToggleBtn = $('calendarToggleBtn'), billListBody = $('billListBody'), pastBillsListBody = $('pastBillsListBody');
    const addBillForm = $('addBillForm');
    const splitBillInputs = $('splitBillInputs');
    const addBtn = $('addBtn'), noBillsMessage = $('noBillsMessage'), noPastBillsMessage = $('noPastBillsMessage'), menuBtn = $('menuBtn'), menuPanel = $('menuPanel'), closeMenuNotch = $('closeMenuNotch');
    const totalAmountEl = $('totalAmount'), totalDueNext10DaysEl = $('totalDueNext10Days');
    const pendingBillsList = $('pendingBillsList'), next30DaysList = $('next30DaysList');
    const currentBalance = $('currentBalance'), primaryIncomeName = $('primaryIncomeName'), paycheckAmount = $('paycheckAmount'), nextPayday = $('nextPayday'), payFrequency = $('payFrequency'), submitIncomeBtn = $('submitIncomeBtn');
    const profilesList = $('profilesList');
    const addProfileBtn = $('addProfileBtn');
    const profileCreationOptions = $('profileCreationOptions');
    const dashboardSectionsList = $('dashboardSectionsList'), resetDashboardOrderBtn = $('resetDashboardOrderBtn');
    const recurringPaymentList = $('recurringPaymentList'), recurringTotalCount = $('recurringTotalCount'), recurringMonthlyTotal = $('recurringMonthlyTotal'), recurringYearlyTotal = $('recurringYearlyTotal');

    // Profile Management System
    let profiles = [];
    let currentProfileId = null;
    
    // Profile data structure
    function createProfile(name, isDefault = false, isPrimary = false) {
        const profileId = 'profile_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        return {
            id: profileId,
            name: name,
            createdDate: new Date().toISOString(),
            isDefault: isDefault,
            isPrimary: isPrimary
        };
    }
    
    // Get profile-specific localStorage key
    function getProfileKey(key, profileId = currentProfileId) {
        return `sum-it-forecast.${profileId}.${key}`;
    }
    
    // Save data to current profile
    function saveProfileData(key, data) {
        if (!currentProfileId) {
            console.warn('Cannot save profile data: currentProfileId is null');
            return;
        }
        localStorage.setItem(getProfileKey(key), JSON.stringify(data));
    }
    
    // Load data from current profile
    function loadProfileData(key, defaultValue = null) {
        if (!currentProfileId) {
            console.warn('Cannot load profile data: currentProfileId is null, trying fallback to legacy storage');
            // Fallback to legacy storage for backward compatibility
            const legacyData = localStorage.getItem(`sum-it-forecast.${key}`);
            return legacyData ? JSON.parse(legacyData) : defaultValue;
        }
        
        const profileKey = getProfileKey(key);
        const data = localStorage.getItem(profileKey);
        
        if (!data) {
            console.log(`No data found for key: ${profileKey}, using default value`);
            return defaultValue;
        }
        
        try {
            return JSON.parse(data);
        } catch (error) {
            console.error(`Error parsing data for key ${profileKey}:`, error);
            return defaultValue;
        }
    }
    
    // Initialize profiles system
    function initializeProfiles() {
        try {
            console.log('Initializing profiles system...');
            
            // Load profiles list
            const savedProfiles = localStorage.getItem('sum-it-forecast.profiles');
            if (savedProfiles) {
                profiles = JSON.parse(savedProfiles);
                console.log('Loaded existing profiles:', profiles);
                
                // Ensure at least one profile is marked as primary
                const hasPrimary = profiles.some(p => p.isPrimary);
                if (!hasPrimary && profiles.length > 0) {
                    // Mark the first profile as primary
                    profiles[0].isPrimary = true;
                    saveProfilesList();
                    console.log('Marked first profile as primary:', profiles[0].name);
                }
                
                // Ensure only one profile is marked as primary
                const primaryProfiles = profiles.filter(p => p.isPrimary);
                if (primaryProfiles.length > 1) {
                    // Keep only the first one as primary
                    profiles.forEach((p, index) => {
                        p.isPrimary = index === 0;
                    });
                    saveProfilesList();
                    console.log('Fixed multiple primary profiles - kept first one as primary');
                }
            } else {
                // Create default primary profile
                const defaultProfile = createProfile('Profile 1', true, true);
                profiles = [defaultProfile];
                saveProfilesList();
                console.log('Created default primary profile:', defaultProfile);
                
                // Migrate existing data to the default profile
                migrateLegacyDataToProfile(defaultProfile.id);
            }
            
            // Load current profile ID
            currentProfileId = localStorage.getItem('sum-it-forecast.currentProfileId') || profiles[0].id;
            console.log('Current profile ID:', currentProfileId);
            
            // Ensure current profile exists
            if (!profiles.find(p => p.id === currentProfileId)) {
                currentProfileId = profiles[0].id;
                localStorage.setItem('sum-it-forecast.currentProfileId', currentProfileId);
                console.log('Reset to default profile:', currentProfileId);
            }
            
            // Check if profilesList element exists
            if (!profilesList) {
                console.error('profilesList element not found!');
                return;
            }
            
            renderProfilesList();
            console.log('Profiles system initialized successfully');
        } catch (error) {
            console.error('Error initializing profiles system:', error);
        }
    }
    
    // Save profiles list
    function saveProfilesList() {
        localStorage.setItem('sum-it-forecast.profiles', JSON.stringify(profiles));
    }
    
    // Migrate legacy data to a profile
    function migrateLegacyDataToProfile(profileId) {
        console.log('Migrating legacy data to profile:', profileId);
        
        const dataKeys = ['bills', 'debts', 'archivedDebts', 'goals', 'incomeSchedules', 'paydayMarkers', 'paydayRecords', 'adjustments', 'settings', 'incomes'];
        
        dataKeys.forEach(key => {
            const legacyData = localStorage.getItem(`sum-it-forecast.${key}`);
            if (legacyData) {
                const profileKey = `sum-it-forecast.${profileId}.${key}`;
                localStorage.setItem(profileKey, legacyData);
                console.log(`Migrated ${key} to profile ${profileId}`);
            }
        });
    }
    
    // Load profile data for export (secure, profile-specific)
    function loadProfileDataForExport(key, profileId) {
        try {
            const profileKey = `sum-it-forecast.${profileId}.${key}`;
            const data = localStorage.getItem(profileKey);
            
            if (!data) {
                console.log(`No data found for profile ${profileId}, key: ${key}`);
                return getDefaultValueForKey(key);
            }
            
            return JSON.parse(data);
        } catch (error) {
            console.error(`Error loading profile data for export - Profile: ${profileId}, Key: ${key}:`, error);
            return getDefaultValueForKey(key);
        }
    }
    
    // Get default values for different data types
    function getDefaultValueForKey(key) {
        switch (key) {
            case 'bills':
            case 'debts':
            case 'archivedDebts':
            case 'goals':
            case 'incomeSchedules':
            case 'paydayMarkers':
            case 'paydayRecords':
            case 'adjustments':
                return [];
            case 'settings':
            case 'incomes':
                return {};
            default:
                return null;
        }
    }
    
    // Render profiles list
    function renderProfilesList() {
        try {
            console.log('Rendering profiles list...', profiles);
            
            if (!profilesList) {
                console.error('profilesList element not found in renderProfilesList!');
                return;
            }
            
        profilesList.innerHTML = '';
        
        // Sort profiles with primary first, then by creation date
        const sortedProfiles = [...profiles].sort((a, b) => {
            if (a.isPrimary && !b.isPrimary) return -1;
            if (!a.isPrimary && b.isPrimary) return 1;
            return new Date(a.createdDate) - new Date(b.createdDate);
        });
        
        sortedProfiles.forEach(profile => {
            const isCurrent = profile.id === currentProfileId;
            const profileItem = document.createElement('div');
            profileItem.className = `profile-item ${isCurrent ? 'profile-current' : ''}`;
            profileItem.dataset.profileId = profile.id;
            
            console.log(`Rendering profile: ${profile.name}, isPrimary: ${profile.isPrimary}, isCurrent: ${isCurrent}`);
            
            profileItem.innerHTML = `
                <div class="profile-info" ${!isCurrent ? 'style="cursor: pointer;"' : ''}>
                    <div class="profile-name-container">
                        <span class="profile-name">${profile.name}${profile.isPrimary ? ' (Primary)' : ''}</span>
                    </div>
                    <button class="profile-menu-btn" title="Profile options"></button>
                    ${isCurrent ? '<div class="profile-active-indicator">Active</div>' : ''}
                </div>
                <div class="profile-options" style="display: none;">
                    <button class="profile-option-btn" data-action="switch" ${isCurrent ? 'disabled' : ''}>
                        <span class="option-icon"></span>
                        <span class="option-text">${isCurrent ? 'Current Profile' : 'Switch to Profile'}</span>
                    </button>
                    <button class="profile-option-btn" data-action="rename">
                        <span class="option-icon"></span>
                        <span class="option-text">Rename Profile</span>
                    </button>
                    <button class="profile-option-btn" data-action="export">
                        <span class="option-icon"></span>
                        <span class="option-text">Export Profile</span>
                    </button>
                    <button class="profile-option-btn" data-action="info">
                        <span class="option-icon"></span>
                        <span class="option-text">Profile Info</span>
                    </button>
                    ${!profile.isPrimary ? `<button class="profile-option-btn" data-action="setPrimary">
                        <span class="option-icon"></span>
                        <span class="option-text">Set as Primary</span>
                    </button>` : ''}
                    ${!profile.isPrimary ? `<button class="profile-option-btn profile-delete-btn" data-action="delete">
                        <span class="option-icon"></span>
                        <span class="option-text">Delete Profile</span>
                    </button>` : ''}
                </div>
            `;
            
            profilesList.appendChild(profileItem);
            
            // Verify the profile item was created correctly
            const menuBtn = profileItem.querySelector('.profile-menu-btn');
            const options = profileItem.querySelector('.profile-options');
            console.log(`Created profile item for ${profile.name}:`, {
                hasMenuBtn: !!menuBtn,
                hasOptions: !!options,
                isCurrent: isCurrent
            });
            
            // Add click handler for direct profile switching
            if (!isCurrent) {
                const profileInfo = profileItem.querySelector('.profile-info');
                if (profileInfo) {
                    profileInfo.addEventListener('click', (e) => {
                        // Don't trigger if clicking on the menu button
                        if (e.target.closest('.profile-menu-btn')) return;
                        switchToProfile(profile.id);
                    });
                }
            }
        });
        
        // Add event listeners to new profile items
        addProfileEventListeners();
        console.log('Profiles list rendered successfully');
        } catch (error) {
            console.error('Error rendering profiles list:', error);
        }
    }
    
    // Add event listeners to profile items
    function addProfileEventListeners() {
        // Only select actual profile items, not the "Add Profile" button
        const profileItems = document.querySelectorAll('.profile-item:not(.add-profile)');
        console.log('Adding event listeners to', profileItems.length, 'profile items');
        
        profileItems.forEach((item, index) => {
            const menuBtn = item.querySelector('.profile-menu-btn');
            const options = item.querySelector('.profile-options');
            
            console.log(`Profile item ${index}:`, {
                hasMenuBtn: !!menuBtn,
                hasOptions: !!options,
                profileId: item.dataset.profileId
            });
            
            // Add null checks to prevent errors
            if (!menuBtn || !options) {
                console.warn('Missing menu button or options element for profile item:', item);
                return;
            }
            
            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Close other profile options
                document.querySelectorAll('.profile-options').forEach(opt => {
                    if (opt !== options) opt.style.display = 'none';
                });
                
                // Toggle current options
                if (options.style.display === 'none' || options.style.display === '') {
                    options.style.display = 'flex';
                } else {
                    options.style.display = 'none';
                }
            });
            
            options.addEventListener('click', (e) => {
                const action = e.target.closest('.profile-option-btn')?.dataset.action;
                if (!action) return;
                
                const profileId = item.dataset.profileId;
                handleProfileAction(action, profileId);
                options.style.display = 'none';
            });
        });
        
        // Profile creation options event listeners are added when the options are shown
    }
    
    // Handle profile actions
    async function handleProfileAction(action, profileId) {
        const profile = profiles.find(p => p.id === profileId);
        if (!profile) return;
        
        switch (action) {
            case 'switch':
                await switchToProfile(profileId);
                break;
            case 'rename':
                await renameProfile(profileId);
                break;
            case 'export':
                await exportProfile(profileId);
                break;
            case 'info':
                await showProfileInfo(profileId);
                break;
            case 'delete':
                await deleteProfile(profileId);
                break;
        }
    }
    
    // Switch to a different profile
    async function switchToProfile(profileId) {
        if (profileId === currentProfileId) return;
        
        console.log('Switching to profile:', profileId);
        
        // Save current profile data before switching
        saveData();
        
        // Switch profile
        currentProfileId = profileId;
        localStorage.setItem('sum-it-forecast.currentProfileId', currentProfileId);
        
        console.log('Profile switched, loading data for profile:', currentProfileId);
        
        // Load new profile data
        console.log('Loading data for profile:', currentProfileId);
        loadData();
        
        // Update UI after a short delay to ensure data is loaded
        setTimeout(() => {
            console.log('Updating UI after profile switch');
            renderProfilesList();
            renderCalendar();
            updateSummary();
        }, 100);
        
        // Profile switched silently - no modal needed
    }
    
    // Rename profile
    async function renameProfile(profileId) {
        const profile = profiles.find(p => p.id === profileId);
        if (!profile) return;
        
        const newName = prompt('Enter new profile name:', profile.name);
        if (newName && newName.trim() && newName !== profile.name) {
            profile.name = newName.trim();
            saveProfilesList();
            renderProfilesList();
        }
    }
    
    // Export profile
    async function exportProfile(profileId) {
        const profile = profiles.find(p => p.id === profileId);
        if (!profile) return;
        
        console.log('Exporting profile:', profile.name, 'with ID:', profileId);
        
        try {
            // Export data directly from the specific profile's localStorage keys
            const profileData = {
                profileName: profile.name,
                profileCreatedDate: profile.createdDate,
                bills: loadProfileDataForExport('bills', profileId),
                debts: loadProfileDataForExport('debts', profileId),
                archivedDebts: loadProfileDataForExport('archivedDebts', profileId),
                goals: loadProfileDataForExport('goals', profileId),
                incomeSchedules: loadProfileDataForExport('incomeSchedules', profileId),
                paydayMarkers: loadProfileDataForExport('paydayMarkers', profileId),
                paydayRecords: loadProfileDataForExport('paydayRecords', profileId),
                adjustments: loadProfileDataForExport('adjustments', profileId),
                settings: loadProfileDataForExport('settings', profileId),
                incomes: loadProfileDataForExport('incomes', profileId)
            };
            
            // Generate filename with profile name and current date
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const defaultFilename = `${profile.name.replace(/[^a-zA-Z0-9]/g, '_')}_${dateStr}.json`;
            
            const customFilename = prompt('Enter filename for export:', defaultFilename);
            if (customFilename === null) return;
            
            const finalFilename = customFilename.trim() || defaultFilename;
            
            // Export the profile data
            if (window.cordova && window.cordova.platformId) {
                exportProfileCordova(profileData, finalFilename);
            } else {
                exportProfileBrowser(profileData, finalFilename);
            }
            
            console.log('Profile exported successfully:', profile.name);
            
        } catch (error) {
            console.error('Error exporting profile:', error);
            showModal({
                title: 'Export Failed',
                text: 'Failed to export profile. Please try again.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
        }
    }
    
    // Show profile info
    async function showProfileInfo(profileId) {
        const profile = profiles.find(p => p.id === profileId);
        if (!profile) return;
        
        const createdDate = new Date(profile.createdDate).toLocaleDateString();
        const isCurrent = profile.id === currentProfileId;
        
        showModal('Profile Information', `
            <div style="text-align: left;">
                <p><strong>Name:</strong> ${profile.name}</p>
                <p><strong>Created:</strong> ${createdDate}</p>
                <p><strong>Status:</strong> ${isCurrent ? 'Current Profile' : 'Available Profile'}</p>
                <p><strong>Type:</strong> ${profile.isDefault ? 'Default Profile' : 'User Created'}</p>
            </div>
        `, {
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
    }
    
    // Delete profile
    async function deleteProfile(profileId) {
        const profile = profiles.find(p => p.id === profileId);
        if (!profile || profile.isDefault) return;
        
        const confirmDelete = confirm(`Are you sure you want to delete "${profile.name}"? This will permanently remove all data associated with this profile.`);
        if (!confirmDelete) return;
        
        // Remove profile from list
        profiles = profiles.filter(p => p.id !== profileId);
        saveProfilesList();
        
        // If deleting current profile, switch to default
        if (profileId === currentProfileId) {
            currentProfileId = profiles[0].id;
            localStorage.setItem('sum-it-forecast.currentProfileId', currentProfileId);
            await loadData();
        }
        
        // Clear profile data from localStorage
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(`sum-it-forecast.${profileId}.`)) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        
        renderProfilesList();
        renderCalendar();
        updateSummary();
        
        showModal({
            title: 'Profile Deleted',
            text: `Profile "${profile.name}" has been deleted.`,
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
    }

    // Dashboard sections configuration
    let dashboardSections = [
        { id: 'balanceSummaryCard', name: 'Available Balance', description: 'Your current available balance', visible: true, order: 1, required: true },
        { id: 'dueSummaryCard', name: 'Your Share', description: 'Your share of upcoming bills', visible: true, order: 2, required: false },
        { id: 'pendingBillsCard', name: 'Pending', description: 'Bills pending payment', visible: true, order: 3, required: false },
        { id: 'next30DaysCard', name: 'Next 30 Days', description: 'Bills due in the next 30 days', visible: true, order: 4, required: false },
        { id: 'recurringPaymentManagerCard', name: 'Recurring Payment Manager', description: 'Manage and analyze recurring payments', visible: true, order: 5, required: false },
        { id: 'financeCard', name: 'My Finances', description: 'Financial management tools', visible: true, order: 6, required: true },
        { id: 'theTabCard', name: 'The Tab', description: 'Track shared expenses and debts', visible: true, order: 7, required: true },
        { id: 'expenseTrackerCard', name: 'Log Expense', description: 'Quick expense logging', visible: true, order: 8, required: false },
        { id: 'billTrackerCard', name: 'Upcoming Bills', description: 'All upcoming bills', visible: true, order: 9, required: false },
        { id: 'pastBillsCard', name: 'Past Bills', description: 'Previously paid bills', visible: true, order: 10, required: false }
    ];

    // Income management variables
    let incomes = [
        {
            id: 'primary',
            name: 'Primary Income',
            amount: '',
            payday: '',
            frequency: 'Bi-Weekly',
            isPrimary: true,
            createdDate: new Date().toISOString().split('T')[0]
        }
    ];
    const expenseForm = $('expenseForm');
    const editModal = $('editModal'), closeModalBtn = $('closeModalBtn'), saveEditBtn = $('saveEditBtn');
    const addBillModal = $('addBillModal'), closeAddBillModalBtn = $('closeAddBillModalBtn');
    const editSplitBillInputs = $('editSplitBillInputs');
    const addBillBtnHeader = $('addBillBtnHeader');
    const archiveView = $('archiveView'), appView = $('app'), archiveBtn = $('archiveBtn'), backFromArchiveBtn = $('backFromArchiveBtn');
    const archiveBillsListBody = $('archiveBillsListBody'), noArchivedBillsMessage = $('noArchivedBillsMessage');
    const ambianceCanvas = $('ambianceCanvas'), ctxAmbiance = ambianceCanvas.getContext('2d');
    const uiStyleSelect = $('uiStyleSelect'), glassOpacity = $('glassOpacity'), glassBlurSlider = $('glassBlurSlider');
    const enableNaturalSlide = $('enableNaturalSlide'), slideSpeed = $('slideSpeed');
    const enableCustomBackground = $('enableCustomBackground'), customBackgroundOptions = $('customBackgroundOptions'), backgroundType = $('backgroundType');
    const wallpaperFile = $('wallpaperFile'), wallpaperColor2 = $('wallpaperColor2'), wallpaperColor3 = $('wallpaperColor3');
    const gradientAngle = $('gradientAngle'), gradientSpinToggle = $('gradientSpinToggle'), gradientSpinControls = $('gradientSpinControls'), gradientSpinSpeed = $('gradientSpinSpeed');
    const enableAmbiance = $('enableAmbiance'), ambianceSettings = $('ambianceSettings'), ambianceControls = $('ambianceControls'), ambianceSelect = $('ambianceSelect');
    const snowDensity = $('snowDensity'), snowSize = $('snowSize'), snowSpeed = $('snowSpeed');
    const orbsDensity = $('orbsDensity'), orbsSize = $('orbsSize'), orbsSpeed = $('orbsSpeed'), orbsColor = $('orbsColor');
    const starfieldDensity = $('starfieldDensity'), starfieldSpeed = $('starfieldSpeed');
    const dontAutoDeductToggle = $('dontAutoDeductToggle');
    const cornerRadiusSlider = $('cornerRadiusSlider');
    const glassShadowSlider = $('glassShadowSlider');
    const genericModal = $('genericModal'), genericModalTitle = $('genericModalTitle'), genericModalContent = $('genericModalContent'), genericModalText = $('genericModalText'), genericModalButtons = $('genericModalButtons');
    const filterSearchTerm = $('filterSearchTerm'), filterStartDate = $('filterStartDate'), filterEndDate = $('filterEndDate'), filterCategory = $('filterCategory'), clearFiltersBtn = $('clearFiltersBtn');
    const disableAutoOpenCurrentBillsToggle = $('disableAutoOpenCurrentBillsToggle');
    const expenseModal = $('expenseModal');
    const theTabRow = $('theTabRow'), addDebtForm = $('addDebtForm'), debtList = $('debtList');
    const dailyBalanceInCalendarToggle = $('dailyBalanceInCalendarToggle'), disableBackMonthNavToggle = $('disableBackMonthNavToggle');
    const disableLandscapeModeToggle = $('disableLandscapeModeToggle');
    const dateOverrideInput = $('dateOverrideInput'), setDateOverrideBtn = $('setDateOverrideBtn'), resetDateOverrideBtn = $('resetDateOverrideBtn');
    const currentDateValue = $('currentDateValue'), overrideDateValue = $('overrideDateValue'), overrideDateDisplay = $('overrideDateDisplay');
    const testNotificationBtn = $('testNotificationBtn'), notificationStatus = $('notificationStatus'), notificationStatusText = $('notificationStatusText');
    const convertLegacyIncomeBtn = $('convertLegacyIncomeBtn'), legacyConversionStatus = $('legacyConversionStatus'), legacyConversionStatusText = $('legacyConversionStatusText');
    const testEmojiSupportBtn = $('testEmojiSupportBtn'), emojiTestStatus = $('emojiTestStatus'), emojiTestStatusText = $('emojiTestStatusText');
    const clearIncomeFromCalendarBtn = $('clearIncomeFromCalendarBtn'), clearCalendarStatus = $('clearCalendarStatus'), clearCalendarStatusText = $('clearCalendarStatusText');
    const statisticsView = $('statisticsView'), dashboardTabBtn = $('dashboardTabBtn'), statisticsTabBtn = $('statisticsTabBtn');
    const statsFilterBtn = $('statsFilterBtn'), statsFilterModal = $('statsFilterModal'), closeModalStatsFilterBtn = $('closeStatsFilterModalBtn');
    const modalStatsTimeRange = $('modalStatsTimeRange'), modalStatsCategory = $('modalStatsCategory');
    const goalsView = $('goalsView'), goalsTabBtn = $('goalsTabBtn');
    const activeGoalsCount = $('activeGoalsCount'), totalSaved = $('totalSaved'), totalGoalAmount = $('totalGoalAmount');
    const activeGoalsList = $('activeGoalsList'), noGoalsMessage = $('noGoalsMessage');
    const goalCreationModal = $('goalCreationModal'), goalCreationForm = $('goalCreationForm');
    const addGoalBtn = $('addGoalBtn'), createFirstGoalBtn = $('createFirstGoalBtn');
    const cancelGoalBtn = $('cancelGoalBtn');
    const goalName = $('goalName'), goalAmount = $('goalAmount'), goalEndDate = $('goalEndDate'), goalNotes = $('goalNotes');
    const feasibilityCheck = $('feasibilityCheck');
    const paymentSchedulePreview = $('paymentSchedulePreview'), scheduleList = $('scheduleList');
    const previewGoalBtn = $('previewGoalBtn'), createGoalBtn = $('createGoalBtn');
    const scheduleTotalAmount = $('scheduleTotalAmount'), scheduleTotalPayments = $('scheduleTotalPayments');
    const makeDownPayment = $('makeDownPayment'), downPaymentAmount = $('downPaymentAmount'), downPaymentInput = $('downPaymentInput');
    const statsTimeRange = $('statsTimeRange'), statsCategory = $('statsCategory');
    const blurSummaryToggle = $('blurSummaryToggle');
    const enablePremiumToggle = $('enablePremiumToggle');
    const enableMultipleIncomeToggle = $('enableMultipleIncomeToggle');
    const limitDailyBalanceToggle = $('limitDailyBalanceToggle');
    const enableCalendarPrintToggle = $('enableCalendarPrintToggle');
    let charts = {}, goals = [];

    let ambianceParticles = [], gradientAnimationAngle = 0;
    const materialPresets = { glass: { styles: { 'default': { name: 'Default', light: '255,255,255', dark: '15,20,24' }, 'twilight': { name: 'Twilight', light: '235, 230, 255', dark: '30, 25, 45' }, 'graphite': { name: 'Graphite', light: '240,240,245', dark: '35,35,40' }, 'emerald': { name: 'Emerald', light: '240,255,245', dark: '20,40,30' }, 'blue': { name: 'Blue', light: '235,245,255', dark: '20,30,45' }, }}};

    // --- UTILITY ---
    const formatCurrency = (amount) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
    const formatDate = (dateStr) => { const d = parseDateLocal(dateStr); return { month: d.toLocaleString('default', { month: 'short' }).toUpperCase(), day: d.getDate() }; };
    const formatPaymentDateTime = (timestamp) => {
        if (!timestamp) return 'Unknown';
        const date = new Date(timestamp);
        return date.toLocaleString('en-US', { 
            year: 'numeric',
            month: 'short', 
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
        });
    };
    const getCountdown = (dateStr) => {
        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        const dueDate = parseDateLocal(dateStr);
        const diffTime = dueDate.getTime() - today.getTime();
        const diffDays = Math.round(diffTime / 864e5);

        if (diffDays > 1) return `${diffDays} days left`;
        if (diffDays === 1) return 'Due tomorrow';
        if (diffDays === 0) return 'Due today';
        return `${Math.abs(diffDays)} days overdue`;
    };
    const resizeCanvas = (cv) => { 
        const dpr = window.devicePixelRatio || 1; 
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Set canvas internal dimensions (for drawing)
        cv.width = width * dpr; 
        cv.height = height * dpr; 
        
        // Set canvas CSS dimensions (for display)
        cv.style.width = width + 'px';
        cv.style.height = height + 'px';
        
        // Set transform for high-DPI displays
        cv.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0); 
    };
    const getUserShare = bill => (bill.isSplit && bill.splitWithAmount) ? bill.amount - bill.splitWithAmount : bill.amount;
    
    // Emoji support detection and fallback for APK compatibility
    let emojiSupportCache = null;
    
    function detectEmojiSupport() {
        if (emojiSupportCache !== null) {
            return emojiSupportCache;
        }
        
        // Multiple detection methods for better APK compatibility
        const testEmoji = '';
        
        // Method 1: Canvas measurement
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = '16px Arial';
            const emojiWidth = ctx.measureText(testEmoji).width;
            const textWidth = ctx.measureText('M').width;
            
            if (Math.abs(emojiWidth - textWidth) > 2) {
                emojiSupportCache = true;
                return true;
            }
        } catch (e) {
            console.log('Canvas emoji detection failed:', e);
        }
        
        // Method 2: DOM element test
        try {
            const testDiv = document.createElement('div');
            testDiv.style.fontSize = '16px';
            testDiv.style.fontFamily = 'Arial';
            testDiv.style.position = 'absolute';
            testDiv.style.left = '-9999px';
            testDiv.textContent = testEmoji;
            document.body.appendChild(testDiv);
            
            const emojiWidth = testDiv.offsetWidth;
            testDiv.textContent = 'M';
            const textWidth = testDiv.offsetWidth;
            
            document.body.removeChild(testDiv);
            
            if (Math.abs(emojiWidth - textWidth) > 2) {
                emojiSupportCache = true;
                return true;
            }
        } catch (e) {
            console.log('DOM emoji detection failed:', e);
        }
        
        // Method 3: User agent detection for known problematic environments
        const userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.includes('cordova') || userAgent.includes('webview')) {
            // In Cordova/WebView, assume limited emoji support
            emojiSupportCache = false;
            return false;
        }
        
        // Default to true if we can't determine
        emojiSupportCache = true;
        return true;
    }
    
    function getEmojiOrFallback(emoji, fallbackText = '$') {
        if (detectEmojiSupport()) {
            return emoji;
        } else {
            return `<span class="emoji-fallback" title="Money icon">${fallbackText}</span>`;
        }
    }
    
    function updateStaticEmojis() {
        // Update the "Manage Additional Income" button
        const manageIncomeBtn = $('manageIncomeBtn');
        if (manageIncomeBtn) {
            const moneyIcon = getEmojiOrFallback('', '$');
            manageIncomeBtn.innerHTML = `${moneyIcon} Manage Additional Income`;
        }
        
        // Update any other static emoji elements as needed
        const paymentScheduleTitle = document.querySelector('#paymentSchedulePreview h4');
        if (paymentScheduleTitle) {
            const calendarIcon = getEmojiOrFallback('', '');
            paymentScheduleTitle.innerHTML = `${calendarIcon} Proposed Payment Schedule (Based on Your Paydays)`;
        }
    }

    // --- INCOME SYSTEM AUDIT & MANAGEMENT ---
    
    /**
     * Self-audit function to ensure system integrity
     */
    function auditIncomeSystem() {
        console.log(' Starting income system audit...');
        
        // 1. Ensure only one primary income exists
        const primarySchedules = incomeSchedules.filter(s => s.isPrimary && !s.isDeleted);
        if (primarySchedules.length > 1) {
            console.warn(' Multiple primary incomes detected! Fixing...');
            // Keep the most recent one, mark others as non-primary
            primarySchedules.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
            for (let i = 1; i < primarySchedules.length; i++) {
                primarySchedules[i].isPrimary = false;
                console.log(` Fixed: Marked ${primarySchedules[i].name} as non-primary`);
            }
        }
        
        // 2. Clean up orphaned PaydayMarkers
        const validScheduleIds = incomeSchedules.map(s => s.id);
        const orphanedMarkers = paydayMarkers.filter(m => !validScheduleIds.includes(m.scheduleId));
        if (orphanedMarkers.length > 0) {
            console.warn(` Found ${orphanedMarkers.length} orphaned PaydayMarkers. Cleaning up...`);
            paydayMarkers = paydayMarkers.filter(m => validScheduleIds.includes(m.scheduleId));
        }
        
        // 3. Ensure PaydayMarkers have valid status
        paydayMarkers.forEach(marker => {
            if (!['planned', 'issued', 'canceled', 'failed'].includes(marker.status)) {
                marker.status = 'planned';
                console.log(` Fixed: Reset invalid status for marker ${marker.id}`);
            }
        });
        
        // 4. Validate schedule consistency
        incomeSchedules.forEach(schedule => {
            if (!schedule.createdDate) {
                schedule.createdDate = getCurrentDateString();
                console.log(` Fixed: Added missing createdDate to schedule ${schedule.id}`);
            }
            if (schedule.isDeleted && !schedule.deletedDate) {
                schedule.deletedDate = getCurrentDateString();
                console.log(` Fixed: Added missing deletedDate to schedule ${schedule.id}`);
            }
        });
        
        console.log(' Income system audit complete');
        return {
            primaryCount: primarySchedules.length,
            orphanedMarkers: orphanedMarkers.length,
            totalSchedules: incomeSchedules.length,
            totalMarkers: paydayMarkers.length
        };
    }
    
    /**
     * Delete all occurrences of an income (complete removal)
     */
    function deleteIncomeCompletely(scheduleId) {
        console.log(` Deleting income completely: ${scheduleId}`);
        
        // 1. Mark schedule as deleted
        const schedule = incomeSchedules.find(s => s.id === scheduleId);
        if (schedule) {
            schedule.isDeleted = true;
            schedule.deletedDate = getCurrentDateString();
            schedule.deletedReason = 'User deleted';
        }
        
        // 2. Cancel ALL PaydayMarkers for this schedule (past and future)
        const allMarkers = paydayMarkers.filter(marker => marker.scheduleId === scheduleId);
        allMarkers.forEach(marker => {
            marker.status = 'canceled';
            marker.canceledDate = getCurrentDateString();
            marker.canceledReason = 'Income deleted';
        });
        
        // 3. Remove from legacy incomes array
        incomes = incomes.filter(income => income.id !== scheduleId);
        
        console.log(` Deleted ${allMarkers.length} PaydayMarkers and schedule ${scheduleId}`);
        
        // 4. Run audit to ensure system integrity
        auditIncomeSystem();
        
        return allMarkers.length;
    }
    
    /**
     * Debug function: Clear all income from calendar while preserving form data
     */
    function clearIncomeFromCalendar() {
        console.log(' Clearing all income from calendar (debug mode)...');
        
        // Show status
        clearCalendarStatus.style.display = 'block';
        clearCalendarStatusText.textContent = 'Clearing income from calendar...';
        clearCalendarStatusText.style.color = 'var(--accent)';
        
        // Count current PaydayMarkers
        const currentMarkers = paydayMarkers.length;
        const currentSchedules = incomeSchedules.length;
        
        // Clear all PaydayMarkers (both past and future)
        paydayMarkers = [];
        
        // Mark all income schedules as deleted (but keep them for form data)
        incomeSchedules.forEach(schedule => {
            schedule.isDeleted = true;
            schedule.deletedDate = getCurrentDateString();
            schedule.deletedReason = 'Debug: Cleared from calendar';
        });
        
        // Clear legacy incomes array (but this will be repopulated when user submits forms)
        incomes = [];
        
        // Save the cleared state
        saveData();
        
        // Re-render to show empty calendar
        renderApp(true);
        renderCalendar();
        updateSummary();
        renderIncomeList();
        
        // Show success message
        clearCalendarStatusText.textContent = ` Cleared ${currentMarkers} payday markers and ${currentSchedules} schedules from calendar. Income forms preserved - submit to restore.`;
        clearCalendarStatusText.style.color = 'var(--ok)';
        
        // Show detailed success modal
        showModal({
            title: 'Calendar Cleared (Debug Mode)',
            text: `Successfully cleared all income from the calendar:\n\n ${currentMarkers} PaydayMarkers removed\n ${currentSchedules} income schedules cleared\n All income forms preserved\n\nTo restore income to calendar:\n1. Go to "My Finances" and hit "Submit"\n2. Go to "Manage Additional Income" and submit each income\n\nThis is a debug tool for testing purposes.`,
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
        
        // Reset status after 5 seconds
        setTimeout(() => {
            clearCalendarStatus.style.display = 'none';
        }, 5000);
        
        console.log(` Debug: Cleared ${currentMarkers} PaydayMarkers and ${currentSchedules} schedules from calendar`);
    }
    
    /**
     * Enhanced adaptive pay function for any income (primary or secondary)
     */
    function updateIncomeAdaptively(scheduleId, newAmount, newFrequency, newPayday, newName = null) {
        const existingSchedule = incomeSchedules.find(s => s.id === scheduleId);
        if (!existingSchedule) {
            console.error(` Schedule not found: ${scheduleId}`);
            return false;
        }
        
        const today = getCurrentDateString();
        const todayDate = getCurrentDate();
        
        // Mark old schedule as deleted (preserve for history)
        existingSchedule.isDeleted = true;
        existingSchedule.deletedDate = today;
        existingSchedule.deletedReason = 'Amount/frequency updated';
        
        // Cancel only FUTURE PaydayMarkers (preserve historical ones)
        const futureMarkers = paydayMarkers.filter(marker => 
            marker.scheduleId === scheduleId && 
            marker.status === 'planned' &&
            new Date(marker.occurrenceDate) > todayDate
        );
        
        futureMarkers.forEach(marker => {
            marker.status = 'canceled';
            marker.canceledDate = today;
            marker.canceledReason = 'Amount/frequency updated';
        });
        
        // Create new ScheduleVersion
        const newScheduleVersion = {
            id: 'schedule_' + Date.now(),
            name: newName || existingSchedule.name, // Use new name if provided, otherwise keep existing
            amount: newAmount,
            frequency: newFrequency,
            effectiveFromDate: today,
            createdDate: today,
            isPrimary: existingSchedule.isPrimary,
            isDeleted: false,
            previousScheduleId: existingSchedule.id
        };
        
        // Add new schedule
        incomeSchedules.push(newScheduleVersion);
        
        // Generate new PaydayMarkers
        const newMarkers = generatePaydayMarkers(newScheduleVersion, newPayday, 24);
        paydayMarkers.push(...newMarkers);
        
        console.log(` Adaptive update for ${existingSchedule.name}:`);
        console.log(` Old: $${existingSchedule.amount}  New: $${newAmount}`);
        console.log(` Preserved ${paydayMarkers.filter(m => m.scheduleId === existingSchedule.id && m.status !== 'canceled').length} historical PaydayMarkers`);
        console.log(` Generated ${newMarkers.length} new PaydayMarkers`);
        
        return true;
    }

    // --- DATA & STATE ---
    function saveData() {
        try {
            saveProfileData('bills', bills);
            saveProfileData('debts', debts);
            saveProfileData('archivedDebts', archivedDebts);
            saveProfileData('goals', goals);
            saveProfileData('incomeSchedules', incomeSchedules);
            saveProfileData('paydayMarkers', paydayMarkers);
            saveProfileData('paydayRecords', paydayRecords);
            saveProfileData('adjustments', adjustments);

            // Update primary income from current UI values
            const primaryIncome = incomes.find(inc => inc.isPrimary);
            if (primaryIncome) {
                primaryIncome.amount = paycheckAmount.value;
                primaryIncome.payday = nextPayday.value;
                primaryIncome.frequency = payFrequency.value;
            }

            saveProfileData('incomes', incomes);

            const settings = { darkMode: document.documentElement.classList.contains('dark'), dontAutoDeduct: dontAutoDeductToggle.classList.contains('active'), finances: { balance: currentBalance.value, paycheck: paycheckAmount.value, payday: nextPayday.value, frequency: payFrequency.value }, incomes: incomes, financesBlurred: $('financeCard').querySelector('.stack').classList.contains('blurred'), naturalSlide: { enabled: enableNaturalSlide.checked, speed: slideSpeed.value }, uiStyle: uiStyleSelect.value, glassOpacity: glassOpacity.value, glassBlur: glassBlurSlider.value, cornerRadius: cornerRadiusSlider.value, glassShadow: glassShadowSlider.value, customBg: enableCustomBackground.checked, bgType: backgroundType.value, bgColor2: wallpaperColor2.value, bgColor3: wallpaperColor3.value, bgGradientAngle: gradientAngle.value, bgGradientSpin: gradientSpinToggle.checked, bgGradientSpinSpeed: gradientSpinSpeed.value, ambiance: enableAmbiance.checked, ambianceEffect: ambianceSelect.value, snowDensity: snowDensity.value, snowSize: snowSize.value, snowSpeed: snowSpeed.value, orbsDensity: orbsDensity.value, orbsSize: orbsSize.value, orbsSpeed: orbsSpeed.value, orbsColor: orbsColor.value, starfieldDensity: starfieldDensity.value, starfieldSpeed: starfieldSpeed.value, disableAutoOpenCurrentBills: disableAutoOpenCurrentBillsToggle.classList.contains('active'), blurSummary: blurSummaryToggle.classList.contains('active'), dailyBalanceInCalendar: dailyBalanceInCalendarToggle.classList.contains('active'), disableBackMonthNav: disableBackMonthNavToggle.classList.contains('active'), disableLandscapeMode: disableLandscapeModeToggle.classList.contains('active'), enablePremium: enablePremiumToggle.classList.contains('active'), enableMultipleIncome: enableMultipleIncomeToggle.classList.contains('active'), limitDailyBalance: limitDailyBalanceToggle.classList.contains('active'), enableCalendarPrint: enableCalendarPrintToggle.classList.contains('active') };
            saveProfileData('settings', settings);
        } catch (error) { console.error("Failed to save data:", error); }
    }

    function archiveOldDebts() {
        const oneDay = 24 * 60 * 60 * 1000;
        const now = getCurrentDate();
        const debtsToKeep = [];
        debts.forEach(debt => {
            if (debt.status === 'satisfied' && debt.paidTimestamp) {
                const satisfiedDate = new Date(debt.paidTimestamp);
                if (now.getTime() - satisfiedDate.getTime() > oneDay) {
                    archivedDebts.push(debt);
                } else {
                    debtsToKeep.push(debt);
                }
            } else {
                debtsToKeep.push(debt);
            }
        });
        debts = debtsToKeep;
        saveData();
    }
    function loadData() {
        try {
            // Load date override from localStorage
            dateOverride = localStorage.getItem('sum-it-forecast.dateOverride');
            if (dateOverride) {
                console.log('Date override loaded from localStorage:', dateOverride);
            }
            
            const oldKeys = ['summitForecast.bills', 'summitForecast.debts', 'summitForecast.goals', 'summitForecast.settings', 'summitForecast.wallpaper'];
            const newKeys = ['sum-it-forecast.bills', 'sum-it-forecast.debts', 'sum-it-forecast.goals', 'sum-it-forecast.settings', 'sum-it-forecast.wallpaper'];

            for (let i = 0; i < oldKeys.length; i++) {
                const oldKey = oldKeys[i];
                const newKey = newKeys[i];
                const data = localStorage.getItem(oldKey);
                if (data) {
                    localStorage.setItem(newKey, data);
                    localStorage.removeItem(oldKey);
                }
            }
            bills = loadProfileData('bills', []);
            debts = loadProfileData('debts', []);
            archivedDebts = loadProfileData('archivedDebts', []);
            goals = loadProfileData('goals', []);
            incomeSchedules = loadProfileData('incomeSchedules', []);
            paydayMarkers = loadProfileData('paydayMarkers', []);
            paydayRecords = loadProfileData('paydayRecords', []);
            adjustments = loadProfileData('adjustments', []);
        
        // Update editability for existing goals
        goals.forEach(goal => {
            updateGoalPaymentEditability(goal.id);
        });
            bills.forEach(bill => {
                if (typeof bill.paid === 'boolean' && !bill.status) {
                    bill.status = bill.paid ? 'paid' : 'unpaid';
                    delete bill.paid;
                } else if (!bill.status) { bill.status = 'unpaid'; }
                if (bill.status === 'paid' && !bill.paidTimestamp) {
                    bill.paidTimestamp = new Date(bill.date + 'T12:00:00Z').toISOString();
                }
            });

            const settings = loadProfileData('settings', {});
            if (settings.darkMode) { document.documentElement.classList.add('dark'); }
            dontAutoDeductToggle.classList.toggle('active', settings.dontAutoDeduct || false);
            userFinances = settings.finances || {};
            currentBalance.value = userFinances.balance || ''; paycheckAmount.value = userFinances.paycheck || ''; nextPayday.value = userFinances.payday || ''; payFrequency.value = userFinances.frequency || 'Bi-Weekly';
            
            // Populate primary income name from existing schedule
            const existingPrimarySchedule = incomeSchedules.find(schedule => schedule.isPrimary && !schedule.isDeleted);
            if (existingPrimarySchedule) {
                primaryIncomeName.value = existingPrimarySchedule.name;
            }
            
            // Profile name and creation date are now managed by the profiles system
            
            // Load incomes data
            const incomesData = loadProfileData('incomes', null);
            if (incomesData) {
                incomes = incomesData;
                
                // Add createdDate to any income entries that don't have it (legacy data)
                let needsSave = false;
                incomes.forEach(income => {
                    if (!income.createdDate) {
                        income.createdDate = new Date().toISOString().split('T')[0];
                        needsSave = true;
                    }
                });
                
                // Save updated incomes if we added createdDate to any entries
                if (needsSave) {
                    saveProfileData('incomes', incomes);
                }
                
                // Ensure we have a primary income
                const primaryIncome = incomes.find(inc => inc.isPrimary);
                if (!primaryIncome) {
                    incomes.unshift({
                        id: 'primary',
                        name: 'Primary Income',
                        amount: paycheckAmount.value,
                        payday: nextPayday.value,
                        frequency: payFrequency.value,
                        isPrimary: true,
                        createdDate: new Date().toISOString().split('T')[0] // Track when primary income was created
                    });
                } else if (!primaryIncome.createdDate) {
                    // Add createdDate to existing primary income that doesn't have it
                    primaryIncome.createdDate = new Date().toISOString().split('T')[0];
                }
            } else {
                // Initialize with primary income from legacy data
                const primaryIncome = incomes.find(inc => inc.isPrimary);
                if (primaryIncome) {
                    primaryIncome.amount = paycheckAmount.value;
                    primaryIncome.payday = nextPayday.value;
                    primaryIncome.frequency = payFrequency.value;
                    if (!primaryIncome.createdDate) {
                        primaryIncome.createdDate = new Date().toISOString().split('T')[0];
                    }
                } else {
                    // Create primary income if none exists
                    incomes.unshift({
                        id: 'primary',
                        name: 'Primary Income',
                        amount: paycheckAmount.value,
                        payday: nextPayday.value,
                        frequency: payFrequency.value,
                        isPrimary: true,
                        createdDate: new Date().toISOString().split('T')[0]
                    });
                }
                
                // Add createdDate to any additional income entries that don't have it
                let needsSave = false;
                incomes.forEach(income => {
                    if (!income.createdDate) {
                        income.createdDate = new Date().toISOString().split('T')[0];
                        needsSave = true;
                    }
                });
                
                // Save updated incomes if we added createdDate to any entries
                if (needsSave) {
                    saveProfileData('incomes', incomes);
                }
            }
            
            // Audit and update primary payday if it's in the past (after incomes are loaded)
            auditPrimaryPayday();
            
            const slideSettings = settings.naturalSlide || {};
            enableNaturalSlide.checked = slideSettings.enabled === false ? false : true; slideSpeed.value = slideSettings.speed || 1000;
            populateStyleSelector();
            uiStyleSelect.value = settings.uiStyle || 'twilight';
            glassOpacity.value = settings.glassOpacity || 80; glassBlurSlider.value = settings.glassBlur || 8;
            cornerRadiusSlider.value = settings.cornerRadius || 16;
            glassShadowSlider.value = settings.glassShadow || 50;
            enableCustomBackground.checked = settings.customBg || false; backgroundType.value = settings.bgType || 'theme';
            wallpaperColor2.value = settings.bgColor2 || '#1e1b4b'; wallpaperColor3.value = settings.bgColor3 || '#4c1d95';
            gradientAngle.value = settings.bgGradientAngle || 145; gradientSpinToggle.checked = settings.bgGradientSpin || false; gradientSpinSpeed.value = settings.bgGradientSpinSpeed || '10';
            enableAmbiance.checked = settings.ambiance || false; ambianceSelect.value = settings.ambianceEffect || 'none';
            disableAutoOpenCurrentBillsToggle.classList.toggle('active', settings.disableAutoOpenCurrentBills || false);
            blurSummaryToggle.classList.toggle('active', settings.blurSummary || false);
            dailyBalanceInCalendarToggle.classList.toggle('active', settings.dailyBalanceInCalendar || false);
            disableBackMonthNavToggle.classList.toggle('active', settings.disableBackMonthNav || false);
            disableLandscapeModeToggle.classList.toggle('active', settings.disableLandscapeMode || false);
            enablePremiumToggle.classList.toggle('active', settings.enablePremium || false);
            enableMultipleIncomeToggle.classList.toggle('active', settings.enableMultipleIncome === true);
            // Default to inactive (60-day limit) if not set - unlimited projections are premium
            limitDailyBalanceToggle.classList.toggle('active', settings.limitDailyBalance === true);
            // Default to inactive - calendar print is premium
            enableCalendarPrintToggle.classList.toggle('active', settings.enableCalendarPrint === true);
            
            // Always audit premium features after loading settings
            // This will only disable features if premium is off - restore only happens when user enables premium
            auditPremiumFeatures();
            const ambiance = settings.ambianceSettings || {};
            snowDensity.value = ambiance.snowDensity || 100;
            snowSize.value = ambiance.snowSize || 20;
            snowSpeed.value = ambiance.snowSpeed || 30;
            orbsDensity.value = ambiance.orbsDensity || 40;
            orbsSize.value = ambiance.orbsSize || 70;
            orbsSpeed.value = ambiance.orbsSpeed || 20;
            orbsColor.value = ambiance.orbsColor || '#9aa4b2';
            starfieldDensity.value = settings.starfieldDensity || 500;
            starfieldSpeed.value = settings.starfieldSpeed || 25;

            if (settings.financesBlurred) {
                const financeStack = $('financeCard').querySelector('.stack');
                financeStack.classList.add('blurred');
                $('actualBalance').classList.add('privacy-blurred');
                $('projected10Day').classList.add('privacy-blurred');
                const privacyBtn = $('privacyToggleBtn');
                if (privacyBtn) {
                    privacyBtn.querySelector('.eye-open').style.display = 'none';
                    privacyBtn.querySelector('.eye-closed').style.display = 'block';
                }
            }

        } catch (error) { console.error("Failed to load data:", error); }
        $('billDate').value = getCurrentDate().toISOString().split('T')[0];
        $('debtDate').value = getCurrentDate().toISOString().split('T')[0];
        applyAllAppearance(); 
        applyLandscapeMode();
        archiveOldDebts();
        renderApp(true);
        if (window.innerWidth > 768) {
            $('financeCard').setAttribute('open', '');
        }
        if (!disableAutoOpenCurrentBillsToggle.classList.contains('active')) {
            billTrackerCard.setAttribute('open', '');
        }
        
        // Initialize date override display
        updateDateOverrideDisplay();
        
        // Process PaydayMarkers to add money to balance for any due paydays
        processPaydayMarkers();
    }

    // --- RENDERING ---
    function renderApp(isInitialLoad = false) {
        const dashboardContainer = document.querySelector('.dashboard-container');
        const addBillContainer = document.querySelector('.add-bill-container');

        if (currentView === 'list') {
            dashboardContainer.style.display = 'flex';
            billTrackerCard.style.display = 'flex';
            addBillContainer.style.display = 'flex';
            pastBillsCard.style.display = 'block';
            calendarView.style.display = 'none';
            calendarToggleBtn.classList.remove('active');
            renderLists(isInitialLoad);
        } else { // calendar view
            dashboardContainer.style.display = 'none';
            billTrackerCard.style.display = 'none';
            addBillContainer.style.display = 'none';
            pastBillsCard.style.display = 'none';
            calendarView.style.display = 'block';
            calendarToggleBtn.classList.add('active');
            // Clear the carried-over balance when toggling calendar view to ensure fresh calculation
            delete window.lastCalculatedBalanceFromPreviousMonth;
            renderCalendar();
        }
        updateSummary(); renderPendingBills(); renderNext30Days(); renderRecurringPayments();
        // The Tab is now always enabled - always render it
        renderTheTab();
        
        // Always audit premium features on app render
        auditPremiumFeatures();
    }
    function renderLists(isInitialLoad = false) {
        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        const thirtyDaysAgo = new Date(today);
        thirtyDaysAgo.setDate(today.getDate() - 30);

        const tenDaysFromNow = new Date(today);
        tenDaysFromNow.setDate(today.getDate() + 10);

        const activeBills = bills.filter(b => {
            if (b.status === 'paid') return false;
            if (b.status === 'pending') return true;
            const billDate = new Date(b.date + 'T00:00:00');
            return billDate <= tenDaysFromNow;
        }).sort((a, b) => new Date(a.date) - new Date(b.date));

        const pastBills = bills.filter(b => {
            if (b.status !== 'paid' || !b.paidTimestamp) return false;
            const paidDate = new Date(b.paidTimestamp);
            return paidDate >= thirtyDaysAgo;
        }).sort((a, b) => new Date(b.paidTimestamp) - new Date(a.paidTimestamp));

        billListBody.innerHTML = ''; noBillsMessage.style.display = activeBills.length === 0 ? 'block' : 'none';
        pastBillsListBody.innerHTML = ''; noPastBillsMessage.style.display = pastBills.length === 0 ? 'block' : 'none';

        activeBills.forEach(bill => billListBody.appendChild(createBillRow(bill, isInitialLoad)));
        pastBills.forEach(bill => pastBillsListBody.appendChild(createBillRow(bill, isInitialLoad)));

        const applyScrollable = (tbody, threshold) => {
            const wrapper = tbody.closest('.bill-table-wrapper');
            if (!wrapper) return;
            const isMobile = document.body.classList.contains('mobile-view');
            wrapper.classList.toggle('scrollable', !isMobile && tbody.children.length > threshold);
        };
        applyScrollable(billListBody, 3);
        applyScrollable(pastBillsListBody, 3);
    }
    function renderArchive() {
        archiveBillsListBody.innerHTML = '';

        const searchTerm = filterSearchTerm.value.toLowerCase();
        const startDate = filterStartDate.value;
        const endDate = filterEndDate.value;
        const category = filterCategory.value;

        let filteredBills = bills.filter(b => b.status === 'paid');

        if (searchTerm) {
            filteredBills = filteredBills.filter(b =>
                b.name.toLowerCase().includes(searchTerm) ||
                (b.notes && b.notes.toLowerCase().includes(searchTerm))
            );
        }
        if (startDate) {
            filteredBills = filteredBills.filter(b => b.date >= startDate);
        }
        if (endDate) {
            filteredBills = filteredBills.filter(b => b.date <= endDate);
        }
        if (category) {
            filteredBills = filteredBills.filter(b => b.category === category);
        }

        const sortedBills = filteredBills.sort((a, b) => new Date(b.date) - new Date(a.date));
        noArchivedBillsMessage.style.display = sortedBills.length === 0 ? 'block' : 'none';
        sortedBills.forEach(bill => archiveBillsListBody.appendChild(createBillRow(bill, true)));
    }

    function renderTabArchive() {
        const tabArchiveBillsListBody = $('tabArchiveModalListBody');
        tabArchiveBillsListBody.innerHTML = '';
        const sortedDebts = archivedDebts.sort((a, b) => new Date(b.date) - new Date(a.date));
        $('noArchivedTabsModalMessage').style.display = sortedDebts.length === 0 ? 'block' : 'none';
        sortedDebts.forEach(debt => {
            const row = document.createElement('tr');
            row.className = 'bill-row satisfied';
            row.dataset.id = debt.id;
            const paidDate = debt.paidTimestamp ? formatPaymentDateTime(debt.paidTimestamp) : debt.date;
            const amountText = `Paid: ${formatCurrency(debt.amount)}`;
            row.innerHTML = `
                <td class="bill-name">${debt.name}</td>
                <td class="bill-amount">${formatCurrency(debt.amount)}</td>
                <td class="bill-date">${paidDate}</td>
                <td class="bill-notes">${debt.notes || 'No notes'}</td>
            `;
            tabArchiveBillsListBody.appendChild(row);
        });
    }
    function createBillRow(bill, isInitialLoad = false) {
        const tr = document.createElement('tr');
        tr.dataset.id = bill.id;
        if (bill.status === 'paid') tr.classList.add('paid');
        else if (bill.status === 'pending') tr.classList.add('pending');
        else tr.classList.add('unpaid');
        
        // Add goal payment specific styling
        if (bill.isGoalPayment) {
            tr.classList.add('goal-payment');
            if (bill.isGrayedOut) tr.classList.add('grayed-out');
            if (bill.isLocked) tr.classList.add('locked');
        }

        const { month, day } = formatDate(bill.date);
        const yourShare = getUserShare(bill);
        const amountDisplay = bill.isSplit ? `<span class="bill-amount">${formatCurrency(yourShare)}</span><span class="split-info-total">Total: ${formatCurrency(bill.amount)}</span>` : `<span class="bill-amount">${formatCurrency(bill.amount)}</span>`;
        let nameHtml = `<span class="bill-name">${bill.name}</span>`;
        if(bill.isSplit) { nameHtml += `<span class="split-info-icon" title="Split with ${bill.splitWithName}"></span>`; }
        let countdownHtml;
        if (bill.status === 'paid') {
            const paymentDateTime = bill.paidTimestamp ? formatPaymentDateTime(bill.paidTimestamp) : 'Paid';
            countdownHtml = `<span class="countdown paid" title="Paid on ${paymentDateTime}">Paid</span>`;
        } else if (bill.status === 'pending') {
            countdownHtml = `<span class="countdown pending">Pending</span>`;
        } else {
            const countdownText = getCountdown(bill.date);
            const isOverdueClass = countdownText.includes('overdue') ? 'overdue' : '';
            countdownHtml = `<span class="countdown ${isOverdueClass}">${countdownText}</span>`;
        }

        const isMobile = document.body.classList.contains('mobile-view');

        if (isMobile) {
            let actionsHTML = `<button class="details-btn">Details</button>`;
            if (bill.status === 'unpaid') {
                actionsHTML += `<button class="pay-btn">Paid </button><button class="pending-btn">Pending</button>`;
            } else if (bill.status === 'pending') {
                actionsHTML += `<button class="pay-btn">Paid </button><button class="unpay-btn">Unpaid </button>`;
            } else if (bill.status === 'paid') {
                actionsHTML += `<button class="unpay-btn">Unpaid </button>`;
            }
            
            // Add goal payment specific buttons
            if (bill.isGoalPayment) {
                if (bill.canEdit && !bill.isGrayedOut) {
                    actionsHTML += `<button class="edit-goal-payment-btn" onclick="editGoalPayment(${bill.id})"> Edit</button>`;
                    const lockIcon = bill.isLocked ? '' : '';
                    const lockText = bill.isLocked ? 'Unlock' : 'Lock';
                    actionsHTML += `<button class="lock-goal-payment-btn" onclick="toggleGoalPaymentLock(${bill.id})">${lockIcon} ${lockText}</button>`;
                }
            }
            
            actionsHTML += `<button class="remove-btn"></button>`;

            tr.innerHTML = `
                <td colspan="5">
                    <div class="mobile-bill-layout">
                        <div class="mobile-bill-date">
                             <div class="date-box">
                                <span class="month">${month}</span>
                                <span class="day">${day}</span>
                            </div>
                        </div>
                        <div class="mobile-bill-info">
                            ${nameHtml}
                            <div class="bill-status">${countdownHtml}</div>
                        </div>
                        <div class="mobile-bill-amount">${amountDisplay}</div>
                        <div class="mobile-bill-actions">${actionsHTML}</div>
                    </div>
                </td>`;
        } else {
            tr.innerHTML = `
                <td><div class="due-date-cell"><div class="date-box"><span class="month">${month}</span><span class="day">${day}</span></div><div class="date-info">${countdownHtml}</div></div></td>
                <td class="bill-details-cell">${nameHtml}<div class="bill-sub-details"><span class="bill-category-badge">${bill.category}</span><span class="bill-frequency-badge">${bill.frequency}</span></div></td>
                <td><div class="bill-notes">${bill.notes || '-'}</div></td>
                <td class="bill-amount-cell">${amountDisplay}</td>
                <td class="actions-cell">
                    <button class="details-btn">Details</button>
                    <button class="pay-btn">Paid </button>
                    <button class="pending-btn">Pending</button>
                    <button class="unpay-btn">Unpaid </button>
                    ${bill.isGoalPayment && bill.canEdit && !bill.isGrayedOut ? `
                        <button class="edit-goal-payment-btn" onclick="editGoalPayment(${bill.id})"> Edit</button>
                        <button class="lock-goal-payment-btn" onclick="toggleGoalPaymentLock(${bill.id})">${bill.isLocked ? ' Unlock' : ' Lock'}</button>
                    ` : ''}
                    <button class="remove-btn"></button>
                </td>`;
        }

        if (!isInitialLoad && bill.justAdded) {
            animateEnter(tr);
            delete bill.justAdded;
        }
        return tr;
    }
    function getPaydaysForMonth(year, month) {
        const paydays = [];
        
        // Check premium status for additional income filtering
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        const isMultipleIncomeEnabled = enableMultipleIncomeToggle.classList.contains('active');
        
        // Add PaydayMarkers for this month
        paydayMarkers.forEach(marker => {
            // Parse the date string directly to avoid timezone issues
            const paydayDate = parseDateLocal(marker.occurrenceDate);
            if (paydayDate.getFullYear() === year && paydayDate.getMonth() === month) {
                // Get the schedule version to get name and amount
                const schedule = getActiveScheduleVersion(marker.scheduleId, marker.occurrenceDate);
                const scheduleName = schedule ? schedule.name : 'Unknown Schedule';
                const scheduleAmount = schedule ? schedule.amount : 0;
                const isPrimary = schedule ? schedule.isPrimary : false;
                
                // Only show additional incomes if premium and multiple income feature is enabled
                if (!isPrimary && (!isPremiumEnabled || !isMultipleIncomeEnabled)) {
                    return; // Skip additional incomes when premium feature is disabled
                }
                
                console.log(` Calendar: Found PaydayMarker for ${scheduleName} ${isPrimary ? '(Primary)' : '(Secondary)'} on day ${paydayDate.getDate()} with status ${marker.status}`);
                
                paydays.push({
                    day: paydayDate.getDate(),
                    name: scheduleName,
                    amount: scheduleAmount,
                    status: marker.status, // 'planned', 'issued', 'canceled', 'failed'
                    isSchedule: true,
                    markerId: marker.id,
                    occurrenceNumber: marker.occurrenceNumber
                });
            }
        });
        
        // Add primary paycheck paydays if configured
        if (nextPayday.value) {
            // Parse the date string directly to avoid timezone issues
            let currentPayday = parseDateLocal(nextPayday.value);
            const frequency = payFrequency.value || 'Bi-Weekly';
            const initialPayday = parseDateLocal(nextPayday.value);

            while (currentPayday.getFullYear() > year || (currentPayday.getFullYear() === year && currentPayday.getMonth() > month)) {
                let tempDate = new Date(currentPayday);
                if (frequency === 'Weekly') tempDate.setDate(tempDate.getDate() - 7);
                else if (frequency === 'Bi-Weekly') tempDate.setDate(tempDate.getDate() - 14);
                else if (frequency === 'Monthly') {
                    let d = tempDate.getDate();
                    tempDate.setMonth(tempDate.getMonth() - 1);
                    if (tempDate.getDate() !== d) tempDate.setDate(0);
                }
                else break;

                if (tempDate < initialPayday) break;
                currentPayday = tempDate;
            }

            while (currentPayday.getFullYear() < year || (currentPayday.getFullYear() === year && currentPayday.getMonth() <= month)) {
                if (currentPayday.getFullYear() === year && currentPayday.getMonth() === month) {
                    paydays.push({
                        day: currentPayday.getDate(),
                        name: 'Primary Income',
                        amount: parseFloat(paycheckAmount.value) || 0,
                        status: 'scheduled',
                        isSchedule: false
                    });
                }
                if (frequency === 'Weekly') currentPayday.setDate(currentPayday.getDate() + 7);
                else if (frequency === 'Bi-Weekly') currentPayday.setDate(currentPayday.getDate() + 14);
                else if (frequency === 'Monthly') {
                     let d = currentPayday.getDate();
                    currentPayday.setMonth(currentPayday.getMonth() + 1);
                    if (currentPayday.getDate() !== d) currentPayday.setDate(0);
                }
                else break;
            }
        }

        // Add additional income stream paydays
        incomes.forEach(income => {
            if (!income.payday || !income.amount || parseFloat(income.amount) <= 0 || income.isPrimary) return;

            // Parse the date string directly to avoid timezone issues
            let currentPayday = parseDateLocal(income.payday);
            const frequency = income.frequency || 'Bi-Weekly';
            const initialPayday = parseDateLocal(income.payday);

            // Rewind to before the target month
            while (currentPayday.getFullYear() > year || (currentPayday.getFullYear() === year && currentPayday.getMonth() > month)) {
                let tempDate = new Date(currentPayday);
                if (frequency === 'Weekly') tempDate.setDate(tempDate.getDate() - 7);
                else if (frequency === 'Bi-Weekly') tempDate.setDate(tempDate.getDate() - 14);
                else if (frequency === 'Monthly') {
                    let d = tempDate.getDate();
                    tempDate.setMonth(tempDate.getMonth() - 1);
                    if (tempDate.getDate() !== d) tempDate.setDate(0);
                }
                else break;

                if (tempDate < initialPayday) break;
                currentPayday = tempDate;
            }
            
            // Fast-forward through the target month
            while (currentPayday.getFullYear() < year || (currentPayday.getFullYear() === year && currentPayday.getMonth() <= month)) {
                 if (currentPayday.getFullYear() === year && currentPayday.getMonth() === month) {
                    paydays.push({
                        day: currentPayday.getDate(),
                        name: income.name,
                        amount: parseFloat(income.amount) || 0,
                        status: 'scheduled',
                        isSchedule: false
                    });
                }
                if (frequency === 'Weekly') currentPayday.setDate(currentPayday.getDate() + 7);
                else if (frequency === 'Bi-Weekly') currentPayday.setDate(currentPayday.getDate() + 14);
                else if (frequency === 'Monthly') {
                    let d = currentPayday.getDate();
                    currentPayday.setMonth(currentPayday.getMonth() + 1);
                    if (currentPayday.getDate() !== d) currentPayday.setDate(0);
                }
                else break;
            }
        });

        // Remove duplicates and sort
        return [...new Set(paydays)].sort((a, b) => a - b);
    }

    // Helper function to calculate total income for a date range
    function getTotalIncomeInRange(startDate, endDate) {
        const paydaysInRange = getPaydaysInRange(startDate, endDate);
        return paydaysInRange.reduce((total, payday) => total + payday.amount, 0);
    }

    // Function to calculate the exact balance for a specific date using calendar logic
    function getBalanceForDate(targetDate) {
        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        targetDate.setHours(0, 0, 0, 0);
        
        // Start with current balance
        let balance = parseFloat(currentBalance.value) || 0;
        
        // Calculate balance day by day from today to target date
        const currentDate = new Date(today);
        
        while (currentDate <= targetDate) {
            if (currentDate.getTime() >= today.getTime()) {
                // Calculate income and expenses for this day
                const incomeToday = getIncomesForDate(currentDate).reduce((sum, income) => sum + income.amount, 0);
                const expensesToday = getNotPaidTotalForDate(currentDate);
                
                // Update balance
                balance = balance + incomeToday - expensesToday;
            }
            
            // Move to next day
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        return balance;
    }

    // Improved function to get balance for 10-day projection using calendar logic
    function getBalanceFor10DayProjection(today) {
        const tenDaysFromNow = new Date(today);
        tenDaysFromNow.setDate(today.getDate() + 10);
        
        const balanceAt10Days = getBalanceForDate(tenDaysFromNow);
        
        console.log(` 10-day projection using calendar balance: ${formatCurrency(balanceAt10Days)}`);
        
        return {
            amount: balanceAt10Days,
            source: 'calendar',
            date: tenDaysFromNow
        };
    }

    // Helper function to get all incomes for a specific date
    function getIncomesForDate(targetDate) {
        const incomesForDate = [];
        const targetDateOnly = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
        const targetDateStr = targetDateOnly.toISOString().split('T')[0];

        // Add PaydayRecords for this date (issued income)
        paydayRecords.forEach(record => {
            if (record.occurrenceDate === targetDateStr && record.status === 'issued') {
                incomesForDate.push({
                    incomeId: record.id,
                    incomeName: record.name,
                    amount: parseFloat(record.amount),
                    frequency: record.frequency,
                    status: 'issued',
                    occurrenceNumber: record.occurrenceNumber
                });
            }
        });

        // Add PaydayMarkers for this date (planned income)
        // Check if multiple income feature is enabled
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        const isMultipleIncomeEnabled = enableMultipleIncomeToggle.classList.contains('active');
        
        paydayMarkers.forEach(marker => {
            if (marker.occurrenceDate === targetDateStr && marker.status === 'planned') {
                // Find the corresponding schedule to check if it's primary
                const schedule = incomeSchedules.find(s => s.id === marker.scheduleId);
                const isPrimaryIncome = schedule && schedule.isPrimary;
                
                // Only show additional incomes if premium and multiple income feature is enabled
                if (!isPrimaryIncome && (!isPremiumEnabled || !isMultipleIncomeEnabled)) {
                    return; // Skip additional incomes when premium feature is disabled
                }
                
                incomesForDate.push({
                    incomeId: marker.id,
                    incomeName: marker.scheduleName || 'Income',
                    amount: parseFloat(marker.amount || 0),
                    frequency: 'Planned',
                    status: 'planned',
                    occurrenceNumber: marker.occurrenceNumber
                });
            }
        });

        // Add regular income streams (for backward compatibility with legacy primary income only)
        // Skip additional incomes since they're now handled by PaydayMarkers
        incomes.forEach(income => {
            if (!income.payday || !income.amount || parseFloat(income.amount) <= 0) return;
            
            // Skip primary income if we already have PaydayMarkers for it
            if (income.isPrimary) {
                const hasPaydayMarkers = paydayMarkers.some(marker => 
                    marker.occurrenceDate === targetDateStr && marker.status === 'planned'
                );
                if (hasPaydayMarkers) {
                    return; // Skip to avoid duplicate
                }
            }
            
            // Skip all additional incomes - they're now handled by PaydayMarkers only
            if (!income.isPrimary) {
                return; // Skip additional incomes - use PaydayMarkers instead
            }

            let isPayday = false;
            let currentPayday = parseDateLocal(income.payday);
            const frequency = income.frequency || 'Bi-Weekly';

            // Move payday forward until it's on or after the target date
            while(currentPayday < targetDateOnly) {
                if (frequency === 'Weekly') currentPayday.setDate(currentPayday.getDate() + 7);
                else if (frequency === 'Bi-Weekly') currentPayday.setDate(currentPayday.getDate() + 14);
                else if (frequency === 'Monthly') {
                    let d = currentPayday.getDate();
                    currentPayday.setMonth(currentPayday.getMonth() + 1);
                    if (currentPayday.getDate() !== d) currentPayday.setDate(0);
                }
                else break; // Should not happen
            }

            if (currentPayday.getTime() === targetDateOnly.getTime()) {
                isPayday = true;
            }

            if (isPayday) {
                incomesForDate.push({
                    incomeId: income.id,
                    incomeName: income.name,
                    amount: parseFloat(income.amount),
                    frequency: income.frequency,
                    status: 'legacy'
                });
            }
        });
        return incomesForDate;
    }

    function getPrepaymentsMadeOnDate(targetDate) {
        const targetDayStart = new Date(targetDate);
        targetDayStart.setHours(0,0,0,0);
        const targetDayEnd = new Date(targetDate);
        targetDayEnd.setHours(23,59,59,999);

        return bills.filter(bill => {
            if (bill.status !== 'paid' || !bill.paidTimestamp) return false;
            
            const paidDate = new Date(bill.paidTimestamp);
            const dueDate = parseDateLocal(bill.date);

            const paidOnDate = paidDate >= targetDayStart && paidDate <= targetDayEnd;
            const isPrepaid = paidDate.toDateString() !== dueDate.toDateString() && paidDate < dueDate;

            return paidOnDate && isPrepaid;
        });
    }

    function getPaydaysInRange(startDate, endDate) {
        const allPaydays = [];

        // Calculate paydays for all incomes
        incomes.forEach(income => {
            if (!income.payday || !income.amount || parseFloat(income.amount) <= 0) return;

            const paydays = [];
            let currentPayday = parseDateLocal(income.payday);
            const frequency = income.frequency || 'Bi-Weekly';

            // Rewind to before the start date
            while (currentPayday > startDate) {
                if (frequency === 'Weekly') currentPayday.setDate(currentPayday.getDate() - 7);
                else if (frequency === 'Bi-Weekly') currentPayday.setDate(currentPayday.getDate() - 14);
                else if (frequency === 'Monthly') {
                    let d = currentPayday.getDate();
                    currentPayday.setMonth(currentPayday.getMonth() - 1);
                    if (currentPayday.getDate() !== d) currentPayday.setDate(0); // handle end of month
                }
                else break;
            }

            // Fast-forward through the range
            while (currentPayday <= endDate) {
                if (currentPayday >= startDate) {
                    paydays.push({
                        date: new Date(currentPayday),
                        amount: parseFloat(income.amount),
                        incomeId: income.id,
                        incomeName: income.name
                    });
                }
                if (frequency === 'Weekly') currentPayday.setDate(currentPayday.getDate() + 7);
                else if (frequency === 'Bi-Weekly') currentPayday.setDate(currentPayday.getDate() + 14);
                else if (frequency === 'Monthly') {
                    let d = currentPayday.getDate();
                    currentPayday.setMonth(currentPayday.getMonth() + 1);
                    if (currentPayday.getDate() !== d) currentPayday.setDate(0); // handle end of month
                }
                else break;
            }

            allPaydays.push(...paydays);
        });

        // Sort by date and return the full payday objects with amounts
        return allPaydays.sort((a, b) => a.date - b.date);
    }

    function getBillsForDate(targetDate) {
        const targetYear = targetDate.getFullYear();
        const targetMonth = targetDate.getMonth();
        const targetDay = targetDate.getDate();

        return bills.filter(bill => {
            const billDate = new Date(bill.date + 'T00:00:00');
            const billYear = billDate.getFullYear();
            const billMonth = billDate.getMonth();
            const billDay = billDate.getDate();

            if (billDate > targetDate && bill.frequency === 'One-Time') {
                return false;
            }

            switch (bill.frequency) {
                case 'One-Time':
                    return targetYear === billYear && targetMonth === billMonth && targetDay === billDay;
                case 'Weekly': {
                    if (targetDate < billDate) return false;
                    const diffTime = targetDate.getTime() - billDate.getTime();
                    const diffDays = Math.round(diffTime / 864e5);
                    return diffDays >= 0 && diffDays % 7 === 0;
                }
                case 'Bi-Weekly': {
                    if (targetDate < billDate) return false;
                    const diffTime = targetDate.getTime() - billDate.getTime();
                    const diffDays = Math.round(diffTime / 864e5);
                    return diffDays >= 0 && diffDays % 14 === 0;
                }
                case 'Monthly':
                    return billDay === targetDay && targetDate >= billDate;
                case 'Quarterly':
                    {
                        if (billDay !== targetDay || targetDate < billDate) return false;
                        const monthDiff = (targetYear - billYear) * 12 + (targetMonth - billMonth);
                        return monthDiff >= 0 && monthDiff % 3 === 0;
                    }
                case 'Annually':
                    return billMonth === targetMonth && billDay === targetDay && targetDate >= billDate;
                case 'Custom': {
                    if (targetDate < billDate || !bill.customFrequencyDays || bill.customFrequencyDays <= 0) return false;
                    const diffTime = targetDate.getTime() - billDate.getTime();
                    const diffDays = Math.round(diffTime / 864e5);
                    return diffDays >= 0 && diffDays % bill.customFrequencyDays === 0;
                }
                default:
                    return false;
            }
        });
    }

    // Helper functions for consistent effective bill logic
    function getEffectiveBillsForDate(date) {
        const allBillsForDay = getBillsForDate(date);
        const oneTimeInstances = bills.filter(b => b.frequency === 'One-Time');
        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        
        // First, check if there are any paid instances that were paid on this date
        const paidInstancesForToday = oneTimeInstances.filter(inst => {
            if (inst.status !== 'paid' || !inst.paidTimestamp) return false;
            const paidDate = new Date(inst.paidTimestamp);
            paidDate.setHours(0, 0, 0, 0);
            return paidDate.getTime() === date.getTime();
        });
        
        // Add paid instances that were paid on this date
        const result = [...paidInstancesForToday.map(inst => ({ ...inst, displayStatus: 'paid' }))];
        
        // Get IDs of paid instances to avoid duplicates
        const paidInstanceIds = new Set(paidInstancesForToday.map(inst => inst.id));
        
        return result.concat(allBillsForDay.map(bill => {
            // Skip if this bill is already included as a paid instance to prevent duplicates
            if (paidInstanceIds.has(bill.id)) {
                return { ...bill, displayStatus: 'hidden' };
            }
            
            if (bill.frequency === 'One-Time') {
                // For one-time bills, check if it's pending and not today
                if (bill.status === 'pending' && date.getTime() !== today.getTime()) {
                    // Pending bills should not appear on future dates, only on today
                    return { ...bill, displayStatus: 'hidden' };
                }
                return { ...bill, displayStatus: bill.status };
            }
            
            const inst = oneTimeInstances.find(p => {
                const instDate = new Date(p.date + 'T00:00:00');
                return p.name === bill.name && p.amount === bill.amount && instDate.getTime() === date.getTime();
            });
            
            if (inst) {
                // If there's a one-time instance for this date, use its status
                if (inst.status === 'pending' && date.getTime() !== today.getTime()) {
                    // Pending instances should not appear on future dates, only on today
                    return { ...bill, displayStatus: 'hidden' };
                }
                return { ...bill, displayStatus: inst.status };
            }
            
            // For recurring bills without instances, check if there's a pending instance for today
            const pendingInstance = oneTimeInstances.find(p => {
                const instDate = new Date(p.date + 'T00:00:00');
                return p.name === bill.name && p.amount === bill.amount && 
                       p.status === 'pending' && instDate.getTime() === today.getTime();
            });
            
            if (pendingInstance && date.getTime() !== today.getTime()) {
                // If there's a pending instance for today, don't show the recurring bill on other dates
                return { ...bill, displayStatus: 'hidden' };
            }
            
            return { ...bill, displayStatus: 'unpaid' };
        })).filter(bill => bill.displayStatus !== 'hidden');
    }

    function getNotPaidTotalForDate(date) {
        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        
        // For today, include all pending bills regardless of their scheduled date
        if (date.getTime() === today.getTime()) {
            const allPendingBills = bills.filter(b => b.status === 'pending');
            const pendingTotal = allPendingBills.reduce((sum, b) => sum + getUserShare(b), 0);
            
            // Also include unpaid bills for today
            const todayUnpaidBills = getEffectiveBillsForDate(date)
                .filter(b => b.displayStatus !== 'paid')
                .reduce((sum, b) => sum + getUserShare(b), 0);
            
            return pendingTotal + todayUnpaidBills;
        }
        
        // For other dates, use the normal logic (pending bills are already filtered out in getEffectiveBillsForDate)
        return getEffectiveBillsForDate(date)
            .filter(b => b.displayStatus !== 'paid')
            .reduce((sum, b) => sum + getUserShare(b), 0);
    }

    function renderCalendar() {
        // Process any due paydays before rendering the calendar
        processPaydayMarkers();
        
        calendarView.innerHTML = '';
        const year = calendarDate.getFullYear();
        const month = calendarDate.getMonth();
        const monthName = calendarDate.toLocaleString('default', { month: 'long' });

    const header = document.createElement('div');
    header.className = 'calendar-header';
    header.innerHTML = `
        <button id="prevMonthBtn" title="Previous Month" class="ctrl-btn"></button>
        <h2>${monthName} ${year}</h2>
        <span style="display: flex; gap: 8px;">
            <button id="printCalendarBtn" title="Print Calendar" class="ctrl-btn"></button>
            <button id="nextMonthBtn" title="Next Month" class="ctrl-btn"></button>
        </span>
    `;
    calendarView.appendChild(header);

    const prevMonthBtn = header.querySelector('#prevMonthBtn');
    if (disableBackMonthNavToggle.classList.contains('active')) {
        prevMonthBtn.disabled = true;
        prevMonthBtn.style.opacity = '0.3';
        prevMonthBtn.style.cursor = 'not-allowed';
        prevMonthBtn.title = 'Back month navigation disabled';
    } else {
        prevMonthBtn.disabled = false;
        prevMonthBtn.style.opacity = '1';
        prevMonthBtn.style.cursor = 'pointer';
        prevMonthBtn.title = 'Previous Month';
    }

    const grid = document.createElement('div');
    grid.className = 'calendar-grid-container';
    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    grid.innerHTML += weekdays.map(day => `<div class="calendar-day-name">${day}</div>`).join('');

    const firstDayOfMonth = new Date(year, month, 1).getDay();
    for (let i = 0; i < firstDayOfMonth; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'calendar-day other-month';
        grid.appendChild(emptyCell);
    }

    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const today = getCurrentDate();
    today.setHours(0, 0, 0, 0);
    
    let lastCalculatedBalance;
    let useCarriedBalance = false;

    if (carriedBalance) {
        const nextMonthFromCarried = new Date(carriedBalance.year, carriedBalance.month, 1);
        nextMonthFromCarried.setMonth(nextMonthFromCarried.getMonth() + 1);
        if (nextMonthFromCarried.getFullYear() === year && nextMonthFromCarried.getMonth() === month) {
            useCarriedBalance = true;
        }
    }

    if (useCarriedBalance) {
        lastCalculatedBalance = carriedBalance.balance;
    } else {
        // Use the raw current balance without subtracting pending bills
        // Pending bills will be handled in the daily calculation
        lastCalculatedBalance = parseFloat(currentBalance.value) || 0;
    }

    for (let day = 1; day <= daysInMonth; day++) {
        const dayCell = document.createElement('div');
        dayCell.className = 'calendar-day';
        const currentDate = new Date(year, month, day);
        currentDate.setHours(0, 0, 0, 0);

        if (currentDate.getTime() === today.getTime()) {
            dayCell.classList.add('today');
        }

        const paydays = getPaydaysForMonth(year, month);
        const effectiveBills = getEffectiveBillsForDate(currentDate);
        
        // For calendar display, also include pending bills that were originally scheduled for this date
        const pendingBillsForThisDate = bills.filter(b => {
            if (b.status !== 'pending') return false;
            const billDate = new Date(b.date + 'T00:00:00');
            return billDate.getTime() === currentDate.getTime();
        });
        
        // Combine effective bills with pending bills for display purposes
        const allBillsForDisplay = [...effectiveBills, ...pendingBillsForThisDate.map(b => ({ ...b, displayStatus: 'pending' }))];
        
        let balanceHTML = '';
        let billsHTML = '';

        const prepaymentsMadeToday = getPrepaymentsMadeOnDate(currentDate);
        const prepaidBillsDueToday = effectiveBills.filter(b => 
            b.status === 'paid' && 
            b.paidTimestamp && 
            new Date(b.paidTimestamp).setHours(0,0,0,0) < new Date(b.date + 'T00:00:00').setHours(0,0,0,0)
        );

        if (prepaymentsMadeToday.length > 0 || prepaidBillsDueToday.length > 0) {
            billsHTML += `<div class="day-bill-count prepaid-indicator" title="Prepaid Activity">P</div>`;
        }

        // Check if daily balance should be calculated
        const dailyBalanceEnabled = dailyBalanceInCalendarToggle.classList.contains('active');
        const unlimitedProjectionsEnabled = limitDailyBalanceToggle.classList.contains('active');
        
        // Calculate 60 days from today for the free tier limit
        const sixtyDaysFromNow = new Date(today);
        sixtyDaysFromNow.setDate(today.getDate() + 60);
        sixtyDaysFromNow.setHours(0, 0, 0, 0);
        
        const shouldCalculate = dailyBalanceEnabled && 
                                currentDate >= today &&
                                (unlimitedProjectionsEnabled || currentDate <= sixtyDaysFromNow);

        if (shouldCalculate) {
            const incomeToday = getIncomesForDate(currentDate).reduce((sum, income) => sum + income.amount, 0);
            const expensesToday = getNotPaidTotalForDate(currentDate);

            if (incomeToday > 0 || expensesToday > 0 || currentDate.getTime() === today.getTime()) {
                const previousBalance = lastCalculatedBalance;
                const newBalance = previousBalance + incomeToday - expensesToday;

                const topBalanceClass = previousBalance < 0 ? 'negative' : 'positive';
                const topBalanceHTML = `<div class="day-balance ${topBalanceClass}" style="font-weight: bold; font-size: var(--calendar-balance-font-size);">${formatCurrency(previousBalance)}</div>`;
                let middleActivityHTML = '';
                if (expensesToday > 0) {
                    middleActivityHTML += `<div class="day-balance negative" style="color: #ef4444; font-size: var(--calendar-balance-font-size);">-${formatCurrency(expensesToday)}</div>`;
                }
                if (incomeToday > 0) {
                    middleActivityHTML += `<div class="day-balance positive" style="color: #16a34a; font-size: var(--calendar-balance-font-size);">+${formatCurrency(incomeToday)}</div>`;
                }
                const bottomBalanceClass = newBalance < 0 ? 'negative' : 'positive';
                const bottomBalanceHTML = `<div class="day-balance ${bottomBalanceClass}" style="font-size: var(--calendar-balance-font-size); border-top: 1px solid #ccc; padding-top: 2px; margin-top: 2px; font-weight: bold;">${formatCurrency(newBalance)}</div>`;
                balanceHTML = `${topBalanceHTML}${middleActivityHTML}${bottomBalanceHTML}`;
                
                lastCalculatedBalance = newBalance;
            }
        }

        // Check if there are paydays for this day
        const paydaysForThisDay = paydays.filter(p => p.day === day);
        const hasPaydays = paydaysForThisDay.length > 0;
        
        if (allBillsForDisplay.length > 0 || hasPaydays) {
            // Check if there are any prepaid bills for this date
            const prepaidBillsForThisDate = allBillsForDisplay.filter(bill => 
                bill.status === 'paid' && 
                bill.paidTimestamp && 
                new Date(bill.paidTimestamp).setHours(0,0,0,0) < new Date(bill.date + 'T00:00:00').setHours(0,0,0,0)
            );
            
            // Check for all bills due this day (including paid bills and expenses, but excluding prepaid and pending)
            const regularBillsForThisDate = allBillsForDisplay.filter(bill => {
                // Exclude prepaid bills
                const isPrepaid = bill.status === 'paid' && bill.paidTimestamp && 
                    new Date(bill.paidTimestamp).setHours(0,0,0,0) < new Date(bill.date + 'T00:00:00').setHours(0,0,0,0);
                
                // Exclude pending bills
                const isPending = bill.status === 'pending';
                
                // Exclude income
                const isIncome = bill.category === 'Income';
                
                return !isPrepaid && !isPending && !isIncome;
            });
            
            let bubbleHTML = '';
            
            // Add purple bubble for prepaid bills
            if (prepaidBillsForThisDate.length > 0) {
                bubbleHTML += `<div class="day-bill-count prepaid">${prepaidBillsForThisDate.length}</div>`;
            }
            
            // Add green bubble for regular bills (all bills due this day except prepaid and pending)
            if (regularBillsForThisDate.length > 0) {
                bubbleHTML += `<div class="day-bill-count">${regularBillsForThisDate.length}</div>`;
            }
            
            // Add payment day indicators
            if (hasPaydays) {
                paydaysForThisDay.forEach(payday => {
                    if (payday.status === 'planned') {
                        // Planned payday - gold bubble with money emoji or fallback
                        const moneyIcon = getEmojiOrFallback('', '$');
                        bubbleHTML += `<div class="day-bill-count payment-notification" title="${payday.name}: $${payday.amount} (Planned - #${payday.occurrenceNumber})">${moneyIcon}</div>`;
                    } else if (payday.status === 'issued') {
                        // Issued payday - green bubble with checkmark
                        bubbleHTML += `<div class="day-bill-count issued-payment" title="${payday.name}: $${payday.amount} (Issued - #${payday.occurrenceNumber})" style="background: linear-gradient(135deg, #16a34a 0%, #15803d 100%); box-shadow: 0 3px 6px rgba(22, 163, 74, 0.4);"></div>`;
                    } else if (payday.status === 'canceled') {
                        // Canceled payday - don't show anything (as requested)
                        // bubbleHTML += `<div class="day-bill-count canceled-payment" title="${payday.name}: $${payday.amount} (Canceled - #${payday.occurrenceNumber})" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); box-shadow: 0 3px 6px rgba(107, 114, 128, 0.4);"></div>`;
                    } else if (payday.status === 'failed') {
                        // Failed payday - red bubble with !
                        bubbleHTML += `<div class="day-bill-count failed-payment" title="${payday.name}: $${payday.amount} (Failed - #${payday.occurrenceNumber})" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); box-shadow: 0 3px 6px rgba(239, 68, 68, 0.4);">!</div>`;
                    }
                });
            }
            
            billsHTML = bubbleHTML;
        }

        dayCell.innerHTML = `
            <div class="day-number">${day}</div>
            <div class="bills-on-day">${billsHTML}</div>
            <div class="day-balance-container">${balanceHTML}</div>
        `;
        grid.appendChild(dayCell);
    }
    calendarView.appendChild(grid);
    carriedBalance = { balance: lastCalculatedBalance, year: year, month: month };
}
    function renderPendingBills() {
        pendingBillsList.innerHTML = '';
        const pending = bills.filter(b => b.status === 'pending')
                               .sort((a, b) => new Date(a.date) - new Date(b.date));

        if (pending.length === 0) {
            pendingBillsList.innerHTML = '<p style="font-size:12px; color: var(--muted); text-align:center; margin-top:10px;">No pending bills.</p>';
            return;
        }

        pending.forEach(bill => {
            const item = document.createElement('div');
            item.className = 'upcoming-item';
            item.innerHTML = `
                <div class="name">${bill.name}</div>
                <div class="details">
                    <div class="amount">${formatCurrency(getUserShare(bill))}</div>
                    <div class="countdown">${getCountdown(bill.date)}</div>
                </div>
            `;
            pendingBillsList.appendChild(item);
        });
    }
    function renderNext30Days() {
        next30DaysList.innerHTML = '';
        const today = getCurrentDate();
        today.setHours(0,0,0,0);
        const thirtyDaysFromNow = new Date(today);
        thirtyDaysFromNow.setDate(today.getDate() + 30);

        const next30 = bills.filter(b => {
            const billDate = new Date(b.date + 'T00:00:00');
            return b.status !== 'paid' && billDate >= today && billDate <= thirtyDaysFromNow;
        }).sort((a, b) => new Date(a.date) - new Date(b.date));

        if (next30.length === 0) {
            next30DaysList.innerHTML = '<p style="font-size:12px; color: var(--muted); text-align:center; margin-top:10px;">No bills due in the next 30 days.</p>';
            return;
        }

        next30.forEach(bill => {
            const item = document.createElement('div');
            item.className = 'upcoming-item';
            item.innerHTML = `
                <div class="name">${bill.name}</div>
                <div class="details">
                    <div class="amount">${formatCurrency(getUserShare(bill))}</div>
                    <div class="countdown">${getCountdown(bill.date)}</div>
                </div>
            `;
            next30DaysList.appendChild(item);
        });
    }
    function renderTheTab() {
        debtList.innerHTML = '';
        const sortedDebts = [...debts].sort((a, b) => (a.status === 'satisfied' ? 1 : -1) || new Date(b.date) - new Date(a.date));

        if (sortedDebts.length === 0) {
            debtList.innerHTML = '<p style="font-size:12px; color: var(--muted); text-align:center; margin-top:10px;">No outstanding debts owed to you.</p>';
            return;
        }

        sortedDebts.forEach(debt => {
            const item = document.createElement('div');
            item.className = 'debt-item';
            item.dataset.id = debt.id;
            
            const paidAmount = debt.paidAmount || 0;
            const remainingAmount = debt.amount - paidAmount;
            
            if (remainingAmount <= 0) {
                debt.status = 'satisfied';
            }

            if (debt.status === 'satisfied') {
                item.classList.add('satisfied');
            }

            

            const amountText = debt.status === 'satisfied' 
                ? `Paid: ${formatCurrency(debt.amount)} ${debt.paidTimestamp ? `on ${formatPaymentDateTime(debt.paidTimestamp)}` : ''}` 
                : `Remaining: ${formatCurrency(remainingAmount)} of ${formatCurrency(debt.amount)}`;

            item.innerHTML = `
                <div class="debt-details">
                    <span class="debt-name">${debt.name}</span>
                    <span class="debt-subtext">${amountText}</span>
                    <span class="debt-subtext">On ${debt.date} - ${debt.notes || 'No notes'}</span>
                </div>
                <div class="debt-actions">
                    <button class="pay-btn make-payment-btn" title="Make Payment">Pay</button>
                    <button class="unpaid-btn" title="Mark as Unpaid">Unpaid </button>
                    <button class="remove-btn dismiss-debt-btn" title="${debt.status === 'satisfied' ? 'Archive or Remove' : 'Dismiss Debt'}"></button>
                </div>
            `;
            debtList.appendChild(item);
        });
    }
    function updateSummary() {
        // Process any due paydays before updating summary
        processPaydayMarkers();
        
        const balance = parseFloat(currentBalance.value) || 0;
        const pendingTotal = bills.filter(b => b.status === 'pending').reduce((sum, bill) => sum + getUserShare(bill), 0);
        const availableBalance = balance - pendingTotal;
        console.log('DASHBOARD - Balance:', balance, 'Pending:', pendingTotal, 'Available:', availableBalance);

        $('totalAmountLabel').textContent = 'Available Balance';
        totalAmountEl.textContent = formatCurrency(availableBalance);

        const actualBalanceEl = $('actualBalance');
        actualBalanceEl.textContent = `Actual: ${formatCurrency(balance)}`;
        actualBalanceEl.style.display = 'block';

        // Update Android widget with new balance
        updateAndroidWidget(availableBalance);

        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        const tenDaysFromNow = new Date(today);
        tenDaysFromNow.setDate(today.getDate() + 10);

        const dueInNext10Days = bills.filter(b => {
            const billDate = new Date(b.date + 'T00:00:00');
            return b.status === 'unpaid' && billDate >= today && billDate <= tenDaysFromNow;
        });

        const totalDue = dueInNext10Days.reduce((sum, bill) => sum + getUserShare(bill), 0);
        totalDueNext10DaysEl.textContent = formatCurrency(totalDue);

        // Projected balance calculation using calendar balance
        const projectedBalanceEl = $('projected10Day');
        const balanceData = getBalanceFor10DayProjection(today);
        const projectedBalance = balanceData.amount;
        
        // Create projection message using calendar balance
        const projectionMessage = `Est. balance after 10 days: ${formatCurrency(projectedBalance)}`;
        
        projectedBalanceEl.textContent = projectionMessage;
        projectedBalanceEl.style.display = 'block';
    }

    // --- MODAL & EDITING ---
    function resolveModal(value) {
        if (activeModalResolve) {
            let returnValue = value;
            const modalInput = $('modal-input');
            if (modalInput) {
                returnValue = (value !== 'cancel') ? modalInput.value : 'cancel';
            }
            activeModalResolve(returnValue);
            activeModalResolve = null;
        }
        genericModal.classList.remove('visible');
    }

    function showModal({ title, text, customHTML = '', input = null, buttons = [] }) {
        genericModalTitle.textContent = title;

        if (customHTML) {
            genericModalContent.innerHTML = customHTML;
        } else {
            let contentHTML = `<p id="genericModalText" style="line-height: 1.5; margin: 16px 0; white-space: pre-wrap;">${text}</p>`;
            if (input) {
                contentHTML += `<input id="modal-input" type="${input.type || 'text'}" placeholder="${input.placeholder || ''}" min="${input.min || ''}" step="${input.step || ''}" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; margin-top: 10px;">`;
            }
            genericModalContent.innerHTML = contentHTML;
        }

        genericModalButtons.innerHTML = '';
        buttons.forEach(btnInfo => {
            const button = document.createElement('button');
            button.textContent = btnInfo.text;
            button.className = btnInfo.class || 'save-btn';
            button.addEventListener('click', () => resolveModal(btnInfo.value));
            genericModalButtons.appendChild(button);
        });

        genericModal.classList.add('visible');

        // Improved mobile focus handling
        const modalInput = $('modal-input');
        if (modalInput) {
            // Use setTimeout to ensure modal is fully rendered before focusing
            setTimeout(() => {
                modalInput.focus();

                // Additional mobile-specific handling
                if (window.innerWidth <= 768) {
                    // On mobile, also trigger input mode and scroll into view
                    modalInput.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // Force keyboard to appear on mobile devices
                    modalInput.setAttribute('inputmode', 'decimal');

                    // Additional focus attempt after a longer delay for mobile
                    setTimeout(() => {
                        modalInput.focus();
                        modalInput.click(); // Sometimes helps trigger keyboard on mobile
                    }, 100);
                }
            }, 100); // Small delay to let modal animation complete
        }

        return new Promise(resolve => {
            activeModalResolve = resolve;
        });
    }

    function openEditModal(billId) {
        const bill = bills.find(b => b.id === billId);
        if (!bill) return;
        $('editModalTitle').textContent = 'Edit Bill'; // Set title for clarity
        editModal.dataset.editingId = billId;
        $('editBillName').value = bill.name;
        $('editBillAmount').value = bill.amount;
        $('editBillDate').value = bill.date;
        $('editBillCategory').innerHTML = $('billCategory').innerHTML;
        $('editBillCategory').value = bill.category;
        $('editBillFrequency').innerHTML = $('billFrequency').innerHTML;
        $('editBillFrequency').value = bill.frequency;
        $('editCustomFrequencyWrapper').style.display = bill.frequency === 'Custom' ? 'grid' : 'none';
        $('editBillCustomFrequency').value = bill.customFrequencyDays || '';
        $('editBillNotes').value = bill.notes || '';
        editSplitBillInputs.style.display = 'block';
        $('editBillSplitName').value = bill.splitWithName || '';
        $('editBillSplitAmount').value = bill.splitWithAmount || '';
        editModal.classList.add('visible');
    }
    function closeEditModal() { editModal.classList.remove('visible'); }
    function handleSaveEdit() {
        const billId = Number(editModal.dataset.editingId);
        const bill = bills.find(b => b.id === billId);
        if (!bill) return;
        bill.name = $('editBillName').value.trim();
        bill.amount = parseFloat($('editBillAmount').value) || 0;
        bill.date = $('editBillDate').value;
        bill.category = $('editBillCategory').value;
        bill.frequency = $('editBillFrequency').value;
        if (bill.frequency === 'Custom') {
            bill.customFrequencyDays = parseInt($('editBillCustomFrequency').value, 10) || 0;
        } else {
            delete bill.customFrequencyDays;
        }
        bill.notes = $('editBillNotes').value.trim();
        const splitName = $('editBillSplitName').value.trim();
        const splitAmount = parseFloat($('editBillSplitAmount').value) || 0;
        if (splitName && splitAmount > 0) {
            bill.isSplit = true;
            bill.splitWithName = splitName;
            bill.splitWithAmount = splitAmount;
        } else {
            bill.isSplit = false;
            bill.splitWithName = '';
            bill.splitWithAmount = 0;
        }
        saveData();
        renderApp(true);
        closeEditModal();
    }

    function showDayBreakdown(date) {
        const dayBreakdownModal = $('dayBreakdownModal');
        const dayBreakdownTitle = $('dayBreakdownTitle');
        const dayBreakdownContent = $('dayBreakdownContent');
        dayBreakdownTitle.textContent = `Breakdown for ${date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}`;

        // Use the same logic as getEffectiveBillsForDate for consistency
        const effectiveBills = getEffectiveBillsForDate(date);

        const incomesOnDay = getIncomesForDate(date);
        const prepaymentsMadeOnDay = getPrepaymentsMadeOnDate(date);

        const billsTotal = effectiveBills.reduce((sum, bill) => sum + getUserShare(bill), 0);
        const incomeTotal = incomesOnDay.reduce((sum, income) => sum + income.amount, 0);
        
        // Check if this is today's date to include pending bills in totals
        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        const isToday = date.getTime() === today.getTime();
        
        // Get pending bills for this date (needed for both totals and display)
        const allPendingBills = bills.filter(b => b.status === 'pending');
        const pendingBillsForThisDate = allPendingBills.filter(bill => {
            const billDate = new Date(bill.date + 'T00:00:00');
            return billDate.getTime() === date.getTime();
        });
        
        let pendingTotal = 0;
        if (isToday) {
            // For today, include all pending bills in the total
            pendingTotal = allPendingBills.reduce((sum, bill) => sum + getUserShare(bill), 0);
        } else {
            // For other dates, include pending bills that were originally scheduled for this date
            pendingTotal = pendingBillsForThisDate.reduce((sum, bill) => sum + getUserShare(bill), 0);
        }
        
        const totalBillsAndPending = billsTotal + pendingTotal;

        let contentHTML = `
            <div id="dayBreakdownTotals" style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 10px; background: rgba(128,128,128,0.05); border-radius: 8px; margin-bottom: 16px;">
                <div>
                    <h4 style="margin: 0 0 5px; font-size: 12px; color: var(--muted);">Total Income</h4>
                    <p style="margin: 0; font-size: 20px; font-weight: 700; color: var(--ok);">${formatCurrency(incomeTotal)}</p>
                </div>
                <div>
                    <h4 style="margin: 0 0 5px; font-size: 12px; color: var(--muted);">${pendingTotal > 0 ? (isToday ? 'Total Bills & Pending' : 'Total Bills & Originally Scheduled Pending') : 'Total Bills Due'}</h4>
                    <p style="margin: 0; font-size: 20px; font-weight: 700; color: var(--danger);">${formatCurrency(totalBillsAndPending)}</p>
                </div>
            </div>
        `;
        
        // Show pending bills section for today OR for the original scheduled date
        
        if (isToday) {
            // For today, show ALL pending bills regardless of their scheduled date
            if (allPendingBills.length > 0) {
                contentHTML += '<h3>Pending Bills</h3>';
                contentHTML += '<ul class="day-breakdown-list">';
                allPendingBills.sort((a,b) => a.name.localeCompare(b.name)).forEach(bill => {
                    const dueDate = new Date(bill.date + 'T00:00:00');
                    const isExpense = bill.category === 'Expense';
                    let statusClass = 'pending';
                    if (isExpense) { statusClass = 'expense'; }

                    contentHTML += `
                        <li data-bill-id="${bill.id}">
                            <span class="modal-bill-details">
                                <span class="status-indicator status-${statusClass}"></span>
                                <div>
                                    <span>${bill.name}</span>
                                    <small style="display: block; color: var(--muted);">Status: Pending (Due: ${dueDate.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric' })})</small>
                                </div>
                            </span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span class="modal-bill-amount">${formatCurrency(getUserShare(bill))}</span>
                            </div>
                        </li>`;
                });
                contentHTML += '</ul>';
            }
        } else if (pendingBillsForThisDate.length > 0) {
            // For other dates, show pending bills that were originally scheduled for this date
            contentHTML += '<h3>Pending Bills (Originally Scheduled)</h3>';
            contentHTML += '<ul class="day-breakdown-list">';
            pendingBillsForThisDate.sort((a,b) => a.name.localeCompare(b.name)).forEach(bill => {
                const isExpense = bill.category === 'Expense';
                let statusClass = 'pending';
                if (isExpense) { statusClass = 'expense'; }

                contentHTML += `
                    <li data-bill-id="${bill.id}">
                        <span class="modal-bill-details">
                            <span class="status-indicator status-${statusClass}"></span>
                            <div>
                                <span>${bill.name}</span>
                                <small style="display: block; color: var(--muted);">Status: Pending (Affects today's balance)</small>
                            </div>
                        </span>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="modal-bill-amount">${formatCurrency(getUserShare(bill))}</span>
                        </div>
                    </li>`;
            });
            contentHTML += '</ul>';
        }

        contentHTML += '<h3>Bills & Expenses Due</h3>';

        if (effectiveBills.length > 0) {
            contentHTML += '<ul class="day-breakdown-list">';
            effectiveBills.sort((a,b) => a.name.localeCompare(b.name)).forEach(bill => {
                const isExpense = bill.category === 'Expense';
                let statusClass = bill.displayStatus.toLowerCase();
                
                // Check if this is a prepaid bill
                const dueDate = new Date(bill.date + 'T00:00:00');
                const isPrepaid = bill.displayStatus === 'paid' && bill.paidTimestamp && 
                    new Date(bill.paidTimestamp).setHours(0,0,0,0) < dueDate.setHours(0,0,0,0);
                
                if (isPrepaid) {
                    statusClass = 'prepaid';
                } else if (isExpense && statusClass === 'paid') { 
                    statusClass = 'expense'; 
                } else if (statusClass === 'paid') {
                    statusClass = 'paid'; // Keep green for regular paid bills
                }

                let actionId = bill.id;
                if (bill.frequency !== 'One-Time' && (bill.displayStatus === 'paid' || bill.displayStatus === 'pending')) {
                    const instance = oneTimeInstances.find(p => {
                        const instanceDate = new Date(p.date + 'T00:00:00');
                        return p.name === bill.name && p.amount === bill.amount && instanceDate.getTime() === date.getTime() && p.status === bill.displayStatus;
                    });
                    if (instance) actionId = instance.id;
                }

                let statusText = `Status: ${bill.displayStatus.charAt(0).toUpperCase() + bill.displayStatus.slice(1)}`;
                if (bill.displayStatus === 'paid' && bill.paidTimestamp) {
                    const paidDate = new Date(bill.paidTimestamp);
                    if (paidDate.toDateString() !== dueDate.toDateString() && paidDate < dueDate) {
                        statusText = `Status: Paid (Prepaid on ${formatPaymentDateTime(bill.paidTimestamp)})`;
                    } else {
                        statusText = `Status: Paid on ${formatPaymentDateTime(bill.paidTimestamp)}`;
                    }
                }

                contentHTML += `
                    <li data-bill-id="${bill.id}">
                        <span class="modal-bill-details">
                            <span class="status-indicator status-${statusClass}"></span>
                            <div>
                                <span>${bill.name}</span>
                                <small style="display: block; color: var(--muted);">${statusText}</small>
                            </div>
                        </span>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="modal-bill-amount">${formatCurrency(getUserShare(bill))}</span>
                        </div>
                    </li>`;
            });
            contentHTML += '</ul>';
        } else {
            contentHTML += '<p style="font-size: 13px; color: var(--muted); text-align: center; padding: 10px 0;">No bills or expenses due on this day.</p>';
        }

        if (prepaymentsMadeOnDay.length > 0) {
            contentHTML += '<h3 style="margin-top: 20px;">Prepayments Made</h3>';
            contentHTML += '<ul class="day-breakdown-list">';
            prepaymentsMadeOnDay.forEach(bill => {
                contentHTML += `
                    <li data-bill-id="${bill.id}">
                        <span class="modal-bill-details">
                            <span class="status-indicator status-prepaid"></span>
                            <div>
                                <span>${bill.name}</span>
                                <small style="display: block; color: var(--muted);">Due: ${new Date(bill.date + 'T00:00:00').toLocaleDateString()}</small>
                            </div>
                        </span>
                        <span class="modal-bill-amount">${formatCurrency(getUserShare(bill))}</span>
                    </li>
                `;
            });
            contentHTML += '</ul>';
        }

        contentHTML += '<h3 style="margin-top: 20px;">Income</h3>';
        if (incomesOnDay.length > 0) {
            contentHTML += '<ul class="day-breakdown-list">';
            incomesOnDay.forEach(income => {
                const statusClass = income.status === 'issued' ? 'status-income' : 'status-pending';
                const statusText = income.status === 'issued' ? 'Received' : '';
                const statusIcon = income.status === 'issued' ? '' : '';
                
                contentHTML += `
                    <li>
                        <span class="modal-bill-details">
                            <span class="status-indicator ${statusClass}"></span>
                            ${statusIcon} ${income.incomeName}
                            ${statusText ? `<span style="font-size: 11px; color: var(--muted); margin-left: 8px;">(${statusText})</span>` : ''}
                        </span>
                        <span class="modal-bill-amount">${formatCurrency(income.amount)}</span>
                    </li>
                `;
            });
            contentHTML += '</ul>';
        } else {
            contentHTML += '<p style="font-size: 13px; color: var(--muted); text-align: center; padding: 10px 0;">No income on this day.</p>';
        }
        dayBreakdownContent.innerHTML = contentHTML;
        dayBreakdownModal.classList.add('visible');
    }

    function closeDayBreakdownModal() {
        $('dayBreakdownModal').classList.remove('visible');
    }

    // --- APPEARANCE & ANIMATIONS ---
    function applyLayoutMode() {
        const wasMobile = document.body.classList.contains('mobile-view');
        const isMobile = window.innerWidth <= 768;

        if (wasMobile !== isMobile) {
            document.body.classList.toggle('mobile-view', isMobile);
            
            // Reapply dashboard order when switching between mobile/desktop
            applyDashboardOrder();

            const addButtonText = addBillBtnHeader.querySelector('.add-bill-text');
            const financeCard = $('financeCard');
            const pastBillsCard = $('pastBillsCard'); 

            if (isMobile) {
                if (addButtonText) addButtonText.textContent = 'Bill / Expense';
            } else {
                financeCard.setAttribute('open', '');
                pastBillsCard.removeAttribute('open'); // Ensure it starts closed on desktop too
                if (addButtonText) addButtonText.textContent = 'Add Bill';
            }
            // The logic for opening/closing the current bills card is now universal
            if (disableAutoOpenCurrentBillsToggle.classList.contains('active')) {
                billTrackerCard.removeAttribute('open');
            } else {
                billTrackerCard.setAttribute('open', '');
            }
            // Re-render lists after layout change to apply correct template
            renderLists(true);
        }

        if (!isAnimationRunning) {
            isAnimationRunning = true;
            requestAnimationFrame(mainLoop);
        }
    }

    function applyTheTab() {
        // The Tab is now always enabled - always show it
        theTabRow.style.display = '';
            renderTheTab();
    }

    function applySummaryBlur() {
        const shouldBlur = blurSummaryToggle.classList.contains('active');
        [totalAmountEl, totalDueNext10DaysEl].forEach(el => {
            el.classList.toggle('privacy-blurred', shouldBlur);
        });
    }

    function applyAllAppearance() {
        applyMaterialStyle();
        applyGlassEffect();
        applyCornerRadius();
        applyGlassShadow();
        applySlideSpeed();
        updateWallpaper();
        applyAmbianceSettings();
        applyTheTab();
        applySummaryBlur();
        applyLayoutMode();
    }
    function populateStyleSelector() {
        uiStyleSelect.innerHTML = '';
        for (const key in materialPresets.glass.styles) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = materialPresets.glass.styles[key].name;
            uiStyleSelect.appendChild(option);
        }
    }
    function applyMaterialStyle() {
        const isDark = document.documentElement.classList.contains('dark');
        const selectedStyle = uiStyleSelect.value || 'twilight';
        if(materialPresets.glass.styles[selectedStyle]){
            const tint = materialPresets.glass.styles[selectedStyle][isDark ? 'dark' : 'light'];
            document.documentElement.style.setProperty('--glass-tint', tint);
        }
    }
    function applyGlassEffect() {
        const opacity = glassOpacity.value / 100;
        const blur = glassBlurSlider.value;
        document.documentElement.style.setProperty('--glass-alpha', opacity);

        // When opacity is 100%, neutralize backdrop-filter to prevent "see-through" effect
        if (parseInt(glassOpacity.value, 10) >= 100) {
            document.documentElement.style.setProperty('--glass-backdrop-blur', '0px');
            document.documentElement.style.setProperty('--glass-backdrop-sat', '100%');
        } else {
            // Restore user-defined blur and default saturation for the glass effect
            document.documentElement.style.setProperty('--glass-backdrop-blur', `${blur}px`);
            document.documentElement.style.setProperty('--glass-backdrop-sat', '150%');
        }

        $('glassOpacityPct').textContent = `${glassOpacity.value}%`;
        $('glassBlurPct').textContent = `${blur}px`;
    }
    function applyCornerRadius() {
        const radius = cornerRadiusSlider.value;
        document.documentElement.style.setProperty('--border-radius', `${radius}px`);
        $('cornerRadiusPct').textContent = `${radius}px`;
    }
    function applyGlassShadow() {
        const value = glassShadowSlider.value;
        const isDark = document.documentElement.classList.contains('dark');
        const blur = isDark ? 20 + (value / 100) * 60 : 10 + (value / 100) * 40;
        const alpha = isDark ? 0.2 + (value / 100) * 0.4 : 0.08 + (value / 100) * 0.2;
        document.documentElement.style.setProperty('--glass-shadow-blur', `${blur}px`);
        document.documentElement.style.setProperty('--glass-shadow-alpha', alpha.toFixed(3));
        const cue = $('shadowCue');
        const yOffset = isDark ? 18 : 8;
        cue.style.boxShadow = `0 ${yOffset}px ${blur}px rgba(0,0,0,${alpha})`;
    }

    function updateWallpaper() {
        customBackgroundOptions.style.display = enableCustomBackground.checked ? 'block' : 'none';
        if (!enableCustomBackground.checked) { document.body.style.backgroundImage = ''; return; }
        const type = backgroundType.value;
        $('imageWallpaperControls').style.display = type === 'image' ? 'block' : 'none';
        $('colorWallpaperControls').style.display = type === 'color' ? 'block' : 'none';
        gradientSpinControls.style.display = gradientSpinToggle.checked ? 'flex' : 'none';
        if (type === 'image') {
            const wallpaper = localStorage.getItem('sum-it-forecast.wallpaper');
            document.body.style.backgroundImage = wallpaper ? `url(${wallpaper})` : '';
        } else if (type === 'color') {
            document.body.style.backgroundImage = `linear-gradient(${gradientAngle.value}deg, ${wallpaperColor3.value}, ${wallpaperColor2.value})`;
        } else {
            document.body.style.backgroundImage = '';
        }
    }
    const applySlideSpeed = () => {
        $('slideSpeedPct').textContent = `${slideSpeed.value} px/s`;
    };
    function animateEnter(tr){ 
        if(!enableNaturalSlide.checked) return; 
        const speed = parseFloat(slideSpeed.value) || 1000;
        const duration = (tr.offsetHeight / speed) * 1000;
        document.documentElement.style.setProperty('--slide-duration', `${duration}ms`);
        tr.classList.add('slide-enter'); 
        requestAnimationFrame(() => { 
            tr.classList.add('slide-enter-active'); 
            setTimeout(() => tr.classList.remove('slide-enter','slide-enter-active'), duration); 
        }); 
    }
    function animateRemove(tr, callback){ 
        if(!enableNaturalSlide.checked){ tr.remove(); callback(); return; } 
        const speed = parseFloat(slideSpeed.value) || 1000;
        const duration = (tr.offsetHeight / speed) * 1000;
        document.documentElement.style.setProperty('--slide-duration', `${duration}ms`);
        tr.style.height = `${tr.offsetHeight}px`; 
        tr.classList.add('slide-out'); 
        requestAnimationFrame(() => { 
            tr.classList.add('collapsing'); 
        }); 
        setTimeout(() => { 
            if(tr.parentNode) { tr.remove(); } 
            callback(); 
        }, duration);
    }

    function applyAmbianceSettings() {
        ambianceSettings.style.display = enableAmbiance.checked ? 'block' : 'none';
        ambianceControls.style.display = enableAmbiance.checked && ambianceSelect.value !== 'none' ? 'block' : 'none';
        ['snowControls', 'orbsControls', 'starfieldControls'].forEach(c => $(c).style.display = 'none');
        ambianceParticles = [];
        ctxAmbiance.clearRect(0, 0, ambianceCanvas.width, ambianceCanvas.height);
        if (enableAmbiance.checked) {
            const effect = ambianceSelect.value;
            if (effect === 'none') return;
            $(effect + 'Controls').style.display = 'block';
            let density = 100;
            if (effect === 'snowflakes') density = snowDensity.value;
            else if (effect === 'orbs') density = orbsDensity.value;
            else if (effect === 'starfield') density = starfieldDensity.value;
            for (let i = 0; i < density; i++) {
                if (effect === 'snowflakes') ambianceParticles.push(createSnowflake(true));
                else if (effect === 'orbs') ambianceParticles.push(createOrb(true));
                else if (effect === 'starfield') ambianceParticles.push(createStar(true));
            }
        }
    }

    function createSnowflake(isInitial = false) {
        const size = (Math.random() * (snowSize.value / 10) + 1);
        return { x: Math.random() * ambianceCanvas.width, y: isInitial ? Math.random() * ambianceCanvas.height : -size, size: size, speed: (Math.random() * (snowSpeed.value / 20) + 0.5), opacity: Math.random() * 0.5 + 0.3, update: function() { this.y += this.speed; this.x += Math.sin(this.y/50)*0.5; }, draw: function() { ctxAmbiance.fillStyle = `rgba(255, 255, 255, ${this.opacity})`; ctxAmbiance.beginPath(); ctxAmbiance.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctxAmbiance.fill(); }, isOutOfBounds: function() { return this.y > ambianceCanvas.height + this.size; } };
    }

    function createOrb(isInitial = false) {
        const size = Math.random() * (orbsSize.value / 10) + 5;
        return { x: Math.random() * ambianceCanvas.width, y: isInitial ? Math.random() * ambianceCanvas.height : ambianceCanvas.height + size, size: size, speed: (Math.random() * (orbsSpeed.value / 20) + 0.1), color: orbsColor.value, update: function() { this.y -= this.speed; }, draw: function() { ctxAmbiance.fillStyle = this.color; ctxAmbiance.globalAlpha = 0.5; ctxAmbiance.beginPath(); ctxAmbiance.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctxAmbiance.fill(); ctxAmbiance.globalAlpha = 1; }, isOutOfBounds: function() { return this.y < -this.size; } };
    }

    function createStar(isInitial = false) {
        return { x: Math.random() * ambianceCanvas.width, y: isInitial ? Math.random() * ambianceCanvas.height: 0, size: Math.random() * 1.5 + 0.5, speed: (Math.random() * (starfieldSpeed.value / 10) + 0.1), update: function() { this.y += this.speed; if (this.y > ambianceCanvas.height) {this.y = 0; this.x = Math.random() * ambianceCanvas.width;} }, draw: function() { ctxAmbiance.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctxAmbiance.fillRect(this.x, this.y, this.size, this.size); }, isOutOfBounds: function() { return false; } };
    }

    function mainLoop() {
        if (!isAnimationRunning) return;

        if (gradientSpinToggle.checked && enableCustomBackground.checked && backgroundType.value === 'color') {
            const currentAngle = parseFloat(gradientAngle.value);
            gradientAnimationAngle = (gradientAnimationAngle + (parseFloat(gradientSpinSpeed.value) / 200)) % 360;
            document.body.style.backgroundImage = `linear-gradient(${currentAngle + gradientAnimationAngle}deg, ${wallpaperColor3.value}, ${wallpaperColor2.value})`;
        }

        if (enableAmbiance.checked && ambianceSelect.value !== 'none') {
            ctxAmbiance.clearRect(0, 0, ambianceCanvas.width, ambianceCanvas.height);
            ambianceParticles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.isOutOfBounds()) ambianceParticles.splice(index, 1);
            });
            const effect = ambianceSelect.value;
            let targetDensity = 0;
            if (effect === 'snowflakes') targetDensity = snowDensity.value;
            else if (effect === 'orbs') targetDensity = orbsDensity.value;
            else if (effect === 'starfield') targetDensity = starfieldDensity.value;
            if (ambianceParticles.length < targetDensity) {
                 if (effect === 'snowflakes') ambianceParticles.push(createSnowflake());
                 else if (effect === 'orbs') ambianceParticles.push(createOrb());
            }
        } else if (ambianceParticles.length > 0) {
            ambianceParticles = [];
            ctxAmbiance.clearRect(0, 0, ambianceCanvas.width, ambianceCanvas.height);
        }
        requestAnimationFrame(mainLoop);
    }

    // --- EVENT HANDLERS ---
    const handleAddBill = async () => {
        const name = $('billName').value.trim();
        if (!name) {
            await showModal({ title: 'Missing Information', text: 'Please enter at least a bill name.', buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]});
            return;
        }
        const amount = parseFloat($('billAmount').value) || 0;
        const date = $('billDate').value || new Date().toISOString().split('T')[0];
        
        // Check if we're editing an existing bill
        const editingBillId = addBillModal.dataset.editingBillId;
        let bill;
        
        if (editingBillId) {
            // Update existing bill
            bill = bills.find(b => b.id == editingBillId);
            if (bill) {
                bill.name = name;
                bill.amount = amount;
                bill.date = date;
                bill.category = $('billCategory').value;
                bill.frequency = $('billFrequency').value;
                bill.notes = $('billNotes').value.trim();
                bill.justAdded = false; // Remove justAdded flag when editing
            }
        } else {
            // Create new bill
            bill = { id: Date.now(), name, amount, date, category: $('billCategory').value, frequency: $('billFrequency').value, notes: $('billNotes').value.trim(), status: 'unpaid', isSplit: false, justAdded: true };
            bills.push(bill);
        }
        
        if (bill.frequency === 'Custom') {
            bill.customFrequencyDays = parseInt($('billCustomFrequency').value, 10) || 0;
        }
        
        const splitName = $('billSplitName').value.trim();
        const splitAmount = parseFloat($('billSplitAmount').value);
        if (splitName && splitAmount > 0) {
            bill.isSplit = true; 
            bill.splitWithName = splitName; 
            bill.splitWithAmount = splitAmount;
            if (bill.splitWithAmount >= amount && amount > 0) {
                await showModal({ title: 'Invalid Split', text: "The other person's share cannot be greater than or equal to the total amount.", buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]});
                return;
            }
        } else {
            bill.isSplit = false;
            bill.splitWithName = '';
            bill.splitWithAmount = 0;
        }
        
        addBillForm.reset(); 
        $('billDate').value = new Date().toISOString().split('T')[0];
        addBillModal.classList.remove('visible');
        delete addBillModal.dataset.editingBillId; // Clear editing flag
        saveData(); 
        renderApp();
    };

    const handleAddExpense = (desc, amount, modalToClose = null) => {
        if (desc && amount > 0) {
            // Get today's date in local timezone to avoid timezone issues
            const today = new Date();
            const localDate = today.getFullYear() + '-' + 
                String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                String(today.getDate()).padStart(2, '0');
            
            const newExpenseAsBill = { id: Date.now(), name: desc, amount: amount, date: localDate, category: 'Expense', frequency: 'One-Time', notes: 'Logged as a one-time expense.', status: 'paid', isSplit: false, justAdded: true, paidTimestamp: new Date().toISOString() };
            bills.push(newExpenseAsBill);
            if (!dontAutoDeductToggle.classList.contains('active')) {
                const currentBalanceVal = parseFloat(currentBalance.value) || 0;
                currentBalance.value = (currentBalanceVal - amount).toFixed(2);
            }
            saveData(); renderApp();
            expenseForm.reset();
            toggleExpenseView(false);

            if (modalToClose) {
                modalToClose.classList.remove('visible');
            }
        }
    };

    const handleCustomExpenseSubmit = (e) => { e.preventDefault(); const desc = $('expenseDescription').value.trim(); const amount = parseFloat($('expenseAmount').value); handleAddExpense(desc, amount); };
    const handleQuickExpense = async (e) => {
        const expenseType = e.target.closest('.quick-expense-btn').dataset.expense;
        const result = await showModal({
            title: `Log Expense: ${expenseType}`,
            customHTML: `<label for="modal-input" style="font-size: 14px; color: var(--muted);">Enter Amount:</label><input type="number" id="modal-input" placeholder="0.00" step="0.01" required>`,
            buttons: [
                { text: 'Log Expense', value: 'log', class: 'save-btn' },
                { text: 'Cancel', value: 'cancel', class: 'cancel-btn' },
            ]
        });

        const amount = parseFloat(result);
        if (result !== 'cancel' && amount > 0) {
            const modalToClose = e.target.closest('.modal-overlay');
            handleAddExpense(expenseType, amount, modalToClose);
        }
    };
    const toggleExpenseView = (showCustom, isModal = false) => {
        const quickOpts = isModal ? $('expenseModalQuickOptions') : $('expenseQuickOptions');
        const form = isModal ? $('expenseModalForm') : $('expenseForm');
        quickOpts.style.display = showCustom ? 'none' : 'grid';
        form.style.display = showCustom ? 'flex' : 'none';

        // Auto-focus first input when switching to custom form
        if (showCustom && isModal) {
            setTimeout(() => {
                const descriptionInput = $('expenseModalDescription');
                if (descriptionInput) {
                    descriptionInput.focus();
                    if (window.innerWidth <= 768) {
                        descriptionInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            }, 100);
        }
    };

    const handleListClick = async (e) => {
        const tr = e.target.closest('tr'); if (!tr) return;
        const billId = Number(tr.dataset.id);
        const bill = bills.find(b => b.id === billId);
        if (!bill) return;
        const target = e.target;

        if (target.matches('.details-btn')) {
            openEditModal(billId);
            return;
        }

        if (target.matches('.pay-btn')) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const dueDate = new Date(bill.date + 'T00:00:00');
            const diffDays = Math.round((dueDate.getTime() - today.getTime()) / 864e5);
            if (diffDays > 10) {
                await showModal({ title: 'Notice', text: 'Bills cannot be marked as paid more than 10 days in advance.', buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]});
                return;
            }
            const oldStatus = bill.status;
            const isRecurring = bill.frequency !== 'One-Time';
            const paidTimestamp = new Date().toISOString();

            if (!isRecurring) {
                bill.status = 'paid';
                bill.paidTimestamp = paidTimestamp;
            } else {
                const paidInstance = { ...bill, id: Date.now(), status: 'paid', frequency: 'One-Time', notes: bill.notes || 'Recurring payment.', paidTimestamp: paidTimestamp };
                bills.push(paidInstance);
                const nextDueDate = new Date(bill.date + 'T00:00:00');
                if (bill.frequency === 'Weekly') nextDueDate.setDate(nextDueDate.getDate() + 7);
                else if (bill.frequency === 'Bi-Weekly') nextDueDate.setDate(nextDueDate.getDate() + 14);
                else if (bill.frequency === 'Monthly') nextDueDate.setMonth(nextDueDate.getMonth() + 1);
                else if (bill.frequency === 'Quarterly') nextDueDate.setMonth(nextDueDate.getMonth() + 3);
                else if (bill.frequency === 'Annually') nextDueDate.setFullYear(nextDueDate.getFullYear() + 1);
                else if (bill.frequency === 'Custom' && bill.customFrequencyDays > 0) {
                    nextDueDate.setDate(nextDueDate.getDate() + bill.customFrequencyDays);
                }
                bill.date = nextDueDate.toISOString().split('T')[0];
                bill.status = 'unpaid';
            }
            if (!dontAutoDeduct.checked && oldStatus !== 'paid') {
                const share = getUserShare(bill);
                currentBalance.value = ((parseFloat(currentBalance.value) || 0) - share).toFixed(2);
            }
            
            // If this is a goal payment, update the goal's saved amount
            if (bill.isGoalPayment && bill.goalId) {
                const goal = goals.find(g => g.id === bill.goalId);
                if (goal) {
                    goal.savedAmount = (goal.savedAmount || 0) + bill.amount;
                    goal.lastPayment = { amount: bill.amount, date: new Date().toISOString() };
                    console.log(`Goal ${goal.name} updated: $${bill.amount} added`);
                }
                // Lock the bill when it's paid
                bill.isLocked = true;
                updateGoalPaymentEditability(bill.goalId);
            }
            
            saveData(); renderApp(true);
        } else if (target.matches('.pending-btn')) {
            const isRecurring = bill.frequency !== 'One-Time';

            // If it's a simple one-time bill, just change its status.
            if (!isRecurring) {
                bill.status = 'pending';
            } else {
                // *** START OF TEMPLATE AND INSTANCE MODEL FIX ***
                // This is a recurring bill. Do not change it directly.

                // 1. CREATE AN INSTANCE:
                // Create a new, separate, one-time bill for the current due date with a 'pending' status.
                const pendingInstance = {
                    ...bill,
                    id: Date.now(), // Give it a new unique ID
                    status: 'pending',
                    frequency: 'One-Time', // This is key: it's no longer a recurring rule
                    notes: bill.notes || 'Pending recurring payment.'
                };
                bills.push(pendingInstance);

                // 2. UPDATE THE TEMPLATE:
                // Advance the original recurring bill to its next due date.
                const nextDueDate = new Date(bill.date + 'T00:00:00');
                if (bill.frequency === 'Weekly') nextDueDate.setDate(nextDueDate.getDate() + 7);
                else if (bill.frequency === 'Bi-Weekly') nextDueDate.setDate(nextDueDate.getDate() + 14);
                else if (bill.frequency === 'Monthly') nextDueDate.setMonth(nextDueDate.getMonth() + 1);
                else if (bill.frequency === 'Quarterly') nextDueDate.setMonth(nextDueDate.getMonth() + 3);
                else if (bill.frequency === 'Annually') nextDueDate.setFullYear(nextDueDate.getFullYear() + 1);
                else if (bill.frequency === 'Custom' && bill.customFrequencyDays > 0) {
                    nextDueDate.setDate(nextDueDate.getDate() + bill.customFrequencyDays);
                }
                bill.date = nextDueDate.toISOString().split('T')[0];

                // Ensure the template's status is reset to 'unpaid' for the next cycle.
                bill.status = 'unpaid';
                // *** END OF TEMPLATE AND INSTANCE MODEL FIX ***
            }
            saveData(); renderApp(true);
        } else if (target.matches('.unpay-btn')) {
            if (bill.status === 'pending') { bill.status = 'unpaid'; saveData(); renderApp(true); return; }
            const share = getUserShare(bill);
            let reminderText = '';
            if (dontAutoDeductToggle.classList.contains('active')) {
                reminderText = `\n\n Auto-deduct is currently disabled, so this change won't affect your balance. If you enable auto-deduct later, the bill amount will be automatically deducted from your balance.`;
            }
            const choice = await showModal({
                title: 'Confirm Mark as Unpaid',
                text: `This will move "${bill.name}" back to your current bills section and add ${formatCurrency(share)} back to your balance (if auto-deduct is enabled).${reminderText}`,
                buttons: [
                    { text: 'Yes, Mark Unpaid', value: 'confirm', class: 'danger-btn' },
                    { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
                ]
            });

            if (choice === 'confirm') {
                // Add amount back to balance if auto-deduct is enabled
                if (!dontAutoDeductToggle.classList.contains('active')) {
                    currentBalance.value = ((parseFloat(currentBalance.value) || 0) + share).toFixed(2);
                }

                // If this is a goal payment, deduct from the goal's saved amount
                if (bill.isGoalPayment && bill.goalId) {
                    const goal = goals.find(g => g.id === bill.goalId);
                    if (goal) {
                        goal.savedAmount = Math.max(0, (goal.savedAmount || 0) - bill.amount);
                        console.log(`Goal ${goal.name} updated: $${bill.amount} deducted`);
                    }
                    // Unlock the bill when it's unpaid (if it was previously paid)
                    bill.isLocked = false;
                    updateGoalPaymentEditability(bill.goalId);
                }

                // Change status back to unpaid and remove paid timestamp instead of deleting
                bill.status = 'unpaid';
                delete bill.paidTimestamp;
                saveData();
                renderApp(true);
            }
        } else if (target.matches('.remove-btn')) {
            // Check if this is a goal payment
            if (bill.isGoalPayment && bill.goalId) {
                const goal = goals.find(g => g.id === bill.goalId);
                const goalName = goal ? goal.name : 'Unknown Goal';
                
                const result = await showModal({
                    title: `Manage Goal Payment`,
                    text: `This payment is part of your "${goalName}" goal. You can mark it as paid or pending, but to delete or modify the amount, please use the Goals tool where you can set it to $0 or make other adjustments.`,
                    buttons: [
                        { text: ' Open Goals Tool', value: 'goals', class: 'save-btn' },
                        { text: 'OK', value: 'ok', class: 'cancel-btn' },
                    ]
                });
                
                if (result === 'goals') {
                    // Switch to goals tab and open the goal edit modal
                    goalsTabBtn.click();
                    setTimeout(() => {
                        window.editGoal(bill.goalId);
                    }, 100);
                }
            } else {
                // Regular bill deletion logic
                const isRecurring = bill.frequency !== 'One-Time';
                const isOneTimeInstance = bill.frequency === 'One-Time' && bills.some(b => 
                    b.name === bill.name && b.amount === bill.amount && b.frequency !== 'One-Time'
                );
                
                let messageText;
                if (isRecurring || isOneTimeInstance) {
                    messageText = `Delete this bill permanently (including future occurrences), or dismiss this single occurrence as if it never existed?`;
                } else {
                    messageText = `Delete this bill permanently (amount will be restored to balance), or dismiss it as if it never existed?`;
                }
                
                const choice = await showModal({
                    title: `Manage "${bill.name}"`,
                    text: messageText,
                    buttons: [
                        { text: 'Delete Bill', value: 'delete', class: 'danger-btn' },
                        { text: 'Dismiss Bill', value: 'dismiss', class: 'special-btn' },
                        { text: 'Cancel', value: 'cancel', class: 'cancel-btn' },
                    ]
                });

                if (choice === 'delete') {
                    animateRemove(tr, () => {
                        bills = bills.filter(b => b.id !== billId);
                        saveData();
                        renderApp(true);
                    });
                } else if (choice === 'dismiss') {
                    // Dismiss means "pretend this bill never existed" - remove it completely without affecting balance
                    animateRemove(tr, () => {
                        bills = bills.filter(b => b.id !== billId);
                        saveData();
                        renderApp(true);
                    });
                }
            }
        }
    };

    const handleModalActionClick = async (e) => {
        const target = e.target.closest('.modal-bill-actions button');
        if (!target) return;

        const billId = Number(target.dataset.billId);
        const bill = bills.find(b => b.id === billId);
        if (!bill) return;

        if (target.matches('.details-btn')) {
            closeDayBreakdownModal();
            openEditModal(billId);
            return;
        }

        if (target.matches('.pay-btn')) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const dueDate = new Date(bill.date + 'T00:00:00');
            const diffDays = Math.round((dueDate.getTime() - today.getTime()) / 864e5);
            if (diffDays > 10) {
                await showModal({ title: 'Notice', text: 'Bills cannot be marked as paid more than 10 days in advance.', buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]});
                return;
            }
            const oldStatus = bill.status;
            const isRecurring = bill.frequency !== 'One-Time';
            const paidTimestamp = new Date().toISOString();

            if (!isRecurring) {
                bill.status = 'paid';
                bill.paidTimestamp = paidTimestamp;
            } else {
                const paidInstance = { ...bill, id: Date.now(), status: 'paid', frequency: 'One-Time', notes: bill.notes || 'Recurring payment.', paidTimestamp: paidTimestamp };
                bills.push(paidInstance);
                const nextDueDate = new Date(bill.date + 'T00:00:00');
                if (bill.frequency === 'Weekly') nextDueDate.setDate(nextDueDate.getDate() + 7);
                else if (bill.frequency === 'Bi-Weekly') nextDueDate.setDate(nextDueDate.getDate() + 14);
                else if (bill.frequency === 'Monthly') nextDueDate.setMonth(nextDueDate.getMonth() + 1);
                else if (bill.frequency === 'Quarterly') nextDueDate.setMonth(nextDueDate.getMonth() + 3);
                else if (bill.frequency === 'Annually') nextDueDate.setFullYear(nextDueDate.getFullYear() + 1);
                else if (bill.frequency === 'Custom' && bill.customFrequencyDays > 0) {
                    nextDueDate.setDate(nextDueDate.getDate() + bill.customFrequencyDays);
                }
                bill.date = nextDueDate.toISOString().split('T')[0];
                bill.status = 'unpaid';
            }
            if (!dontAutoDeduct.checked && oldStatus !== 'paid') {
                const share = getUserShare(bill);
                currentBalance.value = ((parseFloat(currentBalance.value) || 0) - share).toFixed(2);
            }
        } else if (target.matches('.pending-btn')) {
            const isRecurring = bill.frequency !== 'One-Time';
            if (!isRecurring) {
                bill.status = 'pending';
            } else {
                // For recurring bills, create a pending instance for the current occurrence
                const pendingInstance = { ...bill, id: Date.now(), status: 'pending', frequency: 'One-Time', notes: bill.notes || 'Pending recurring payment.' };
                bills.push(pendingInstance);
                // Update the original bill to the next occurrence
                const nextDueDate = new Date(bill.date + 'T00:00:00');
                if (bill.frequency === 'Weekly') nextDueDate.setDate(nextDueDate.getDate() + 7);
                else if (bill.frequency === 'Bi-Weekly') nextDueDate.setDate(nextDueDate.getDate() + 14);
                else if (bill.frequency === 'Monthly') nextDueDate.setMonth(nextDueDate.getMonth() + 1);
                else if (bill.frequency === 'Quarterly') nextDueDate.setMonth(nextDueDate.getMonth() + 3);
                else if (bill.frequency === 'Annually') nextDueDate.setFullYear(nextDueDate.getFullYear() + 1);
                else if (bill.frequency === 'Custom' && bill.customFrequencyDays > 0) {
                    nextDueDate.setDate(nextDueDate.getDate() + bill.customFrequencyDays);
                }
                bill.date = nextDueDate.toISOString().split('T')[0];
                bill.status = 'unpaid';
            }
        } else if (target.matches('.unpay-btn')) {
            if (bill.status === 'pending') {
                bill.status = 'unpaid';
            } else {
                const share = getUserShare(bill);
                let reminderText = '';
                if (dontAutoDeductToggle.classList.contains('active')) {
                    reminderText = `\n\n Auto-deduct is currently disabled, so this change won't affect your balance. If you enable auto-deduct later, the bill amount will be automatically deducted from your balance.`;
                }
                const choice = await showModal({
                    title: 'Confirm Mark as Unpaid',
                    text: `This will move "${bill.name}" back to your current bills section and add ${formatCurrency(share)} back to your balance (if auto-deduct is enabled).${reminderText}`,
                    buttons: [
                        { text: 'Yes, Mark Unpaid', value: 'confirm', class: 'danger-btn' },
                        { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
                    ]
                });

                if (choice === 'confirm') {
                    if (!dontAutoDeductToggle.classList.contains('active')) {
                        currentBalance.value = ((parseFloat(currentBalance.value) || 0) + share).toFixed(2);
                    }

                    // Change status back to unpaid and remove paid timestamp instead of deleting
                    bill.status = 'unpaid';
                    delete bill.paidTimestamp;
                } else {
                    return; // Do not re-render if cancelled
                }
            }
        }

        saveData();
        closeDayBreakdownModal();
        renderApp(true);
    };

    const handleListDoubleClick = (e) => { const tr = e.target.closest('tr[data-id]'); if (tr && !e.target.closest('.actions-cell, .mobile-bill-actions')) openEditModal(Number(tr.dataset.id)); };
    

    // Date override functionality
    function getCurrentDate() {
        return dateOverride ? new Date(dateOverride) : new Date();
    }

    /**
     * Gets the current date as a YYYY-MM-DD string using local timezone
     */
    function getCurrentDateString() {
        const currentDate = getCurrentDate();
        return formatDateLocal(currentDate);
    }

    /**
     * Formats a Date object to YYYY-MM-DD string using local timezone
     * Avoids timezone conversion issues that occur with toISOString()
     */
    function formatDateLocal(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    /**
     * Parses a YYYY-MM-DD date string to a Date object using local timezone
     * Avoids timezone conversion issues that occur with new Date(dateString + 'T00:00:00')
     */
    function parseDateLocal(dateString) {
        const [year, month, day] = dateString.split('-').map(Number);
        return new Date(year, month - 1, day); // month is 0-indexed
    }

    function setDateOverride() {
        const selectedDate = dateOverrideInput.value;
        if (!selectedDate) {
            showModal({
                title: 'Date Required',
                text: 'Please select a date to override with.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
            return;
        }

        dateOverride = selectedDate;
        // Persist the override in localStorage
        localStorage.setItem('sum-it-forecast.dateOverride', dateOverride);
        console.log(' Date override set to:', dateOverride);
        console.log(' getCurrentDate() now returns:', getCurrentDate());
        updateDateOverrideDisplay();
        
        // Perform complete application reload with new date context
        performCompleteDateReload();
        
        showModal({
            title: 'Date Override Set',
            text: `Current date is now ${new Date(dateOverride).toLocaleDateString()}. All features have been updated to reflect this date.`,
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
    }

    /**
     * Performs a complete application reload with the new date context
     * Processes all historical paydays and updates all date-dependent features
     */
    function performCompleteDateReload() {
        console.log(' Performing complete date reload...');
        
        // Step 1: Process all historical paydays from the beginning of time to the override date
        processHistoricalPaydays();
        
        // Step 2: Re-render all components with the new date context
        console.log(' Re-rendering all components...');
        renderApp(true);
        renderCalendar();
        updateSummary();
        renderIncomeList();
        renderLists();
        renderPendingBills();
        renderNext30Days();
        renderRecurringPayments();
        
        console.log(' Complete date reload finished');
    }

    /**
     * Processes all PaydayMarkers from the beginning of time up to the override date
     * This ensures no paydays are missed when jumping to a future date
     */
    function processHistoricalPaydays() {
        const overrideDate = getCurrentDate();
        const overrideDateStr = overrideDate.toISOString().split('T')[0];
        
        console.log(` Processing historical paydays up to ${overrideDateStr}...`);
        
        // Find all PaydayMarkers that should have been processed by now
        const historicalMarkers = paydayMarkers.filter(marker => {
            const markerDate = new Date(marker.occurrenceDate + 'T00:00:00');
            return markerDate <= overrideDate && marker.status === 'planned';
        });
        
        console.log(` Found ${historicalMarkers.length} historical paydays to process`);
        
        // Debug: Show which schedules are being processed
        const uniqueSchedules = [...new Set(historicalMarkers.map(m => m.scheduleId))];
        uniqueSchedules.forEach(scheduleId => {
            const schedule = incomeSchedules.find(s => s.id === scheduleId);
            const scheduleName = schedule ? schedule.name : 'Unknown';
            const isPrimary = schedule ? schedule.isPrimary : false;
            const markersForSchedule = historicalMarkers.filter(m => m.scheduleId === scheduleId);
            console.log(`   Schedule: ${scheduleName} ${isPrimary ? '(Primary)' : '(Secondary)'} - ${markersForSchedule.length} markers`);
        });
        
        if (historicalMarkers.length === 0) {
            console.log(' No historical paydays to process');
            return;
        }
        
        let totalProcessed = 0;
        let totalAmount = 0;
        
        // Process each historical marker
        historicalMarkers.forEach(marker => {
            try {
                // Check for idempotency - ensure no duplicate PaydayRecord exists
                const existingRecord = paydayRecords.find(record => 
                    record.scheduleId === marker.scheduleId && 
                    record.occurrenceDate === marker.occurrenceDate
                );

                if (existingRecord) {
                    console.log(` PaydayRecord already exists for ${marker.scheduleId} on ${marker.occurrenceDate}`);
                    return; // Skip - already processed
                }

                // Get the active schedule version for this marker
                const activeSchedule = getActiveScheduleVersion(marker.scheduleId, marker.occurrenceDate);
                if (!activeSchedule) {
                    console.error(` No active schedule found for marker ${marker.id}`);
                    marker.status = 'failed';
                    return;
                }

                // Create immutable PaydayRecord
                const paydayRecord = {
                    id: 'record_' + marker.id,
                    markerId: marker.id,
                    scheduleId: marker.scheduleId,
                    occurrenceDate: marker.occurrenceDate,
                    occurrenceNumber: marker.occurrenceNumber,
                    
                    // Snapshot of schedule parameters at time of issuance
                    amount: activeSchedule.amount,
                    frequency: activeSchedule.frequency,
                    name: activeSchedule.name,
                    
                    // Issuance metadata
                    issuedDate: marker.occurrenceDate, // Use the original occurrence date
                    issuedTimestamp: new Date().toISOString(),
                    
                    // Status
                    status: 'issued'
                };

                // Add to balance
                const currentBalanceValue = parseFloat(currentBalance.value) || 0;
                const newBalance = currentBalanceValue + parseFloat(paydayRecord.amount);
                currentBalance.value = newBalance.toFixed(2);

                // Commit the transaction
                paydayRecords.push(paydayRecord);
                marker.status = 'issued';
                
                totalProcessed++;
                totalAmount += parseFloat(paydayRecord.amount);
                
                console.log(` Historical PaydayRecord issued: ${paydayRecord.name} - $${paydayRecord.amount} (${paydayRecord.occurrenceDate})`);

            } catch (error) {
                console.error(` Error processing historical marker ${marker.id}:`, error);
                marker.status = 'failed';
            }
        });
        
        if (totalProcessed > 0) {
            saveData();
            console.log(` Processed ${totalProcessed} historical paydays totaling $${totalAmount.toFixed(2)}`);
            
            // Show notification
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--ok); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
            successMsg.textContent = ` Processed ${totalProcessed} historical paydays: +$${totalAmount.toFixed(2)}`;
            document.body.appendChild(successMsg);
            setTimeout(() => successMsg.remove(), 4000);
        }
    }

    function resetDateOverride() {
        dateOverride = null;
        // Remove the override from localStorage
        localStorage.removeItem('sum-it-forecast.dateOverride');
        console.log(' Date override reset to null');
        console.log(' getCurrentDate() now returns:', getCurrentDate());
        updateDateOverrideDisplay();
        
        // Perform complete application reload with real date context
        performCompleteDateReload();
        
        showModal({
            title: 'Date Override Reset',
            text: 'Now using standard time measurement. All features have been updated to use the real current date.',
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
    }

    function sendTestNotification() {
        // Show status
        notificationStatus.style.display = 'block';
        notificationStatusText.textContent = 'Sending test notification...';
        notificationStatusText.style.color = 'var(--accent)';
        
        // Check if we're in a Cordova environment
        if (!window.cordova || !window.PushNotification) {
            notificationStatusText.textContent = ' Push notifications not available (not in Cordova environment)';
            notificationStatusText.style.color = 'var(--danger)';
            return;
        }
        
        // For testing purposes, we'll simulate a notification
        // In a real implementation, you would send this to your server
        // which would then use FCM/APNS to send the actual push notification
        
        setTimeout(() => {
            // Simulate successful notification send
            notificationStatusText.textContent = ' Test notification sent! Check your device notifications.';
            notificationStatusText.style.color = 'var(--ok)';
            
            // Also show an in-app notification for immediate feedback
            showModal({
                title: 'Test Notification Sent',
                text: 'Hello from Sum-it, this is a test!\n\nNote: This is a simulated notification. In a real implementation, this would be sent via FCM/APNS to your device.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
            
            // Reset status after 3 seconds
            setTimeout(() => {
                notificationStatus.style.display = 'none';
            }, 3000);
        }, 1000);
    }

    function convertLegacyIncomeToModern() {
        // Show status
        legacyConversionStatus.style.display = 'block';
        legacyConversionStatusText.textContent = 'Converting legacy income entries...';
        legacyConversionStatusText.style.color = 'var(--accent)';
        
        // Find all legacy income entries
        const legacyIncomes = incomes.filter(income => !income.isPrimary && !income.createdDate);
        
        if (legacyIncomes.length === 0) {
            legacyConversionStatusText.textContent = ' No legacy income entries found to convert.';
            legacyConversionStatusText.style.color = 'var(--ok)';
            setTimeout(() => {
                legacyConversionStatus.style.display = 'none';
            }, 3000);
            return;
        }
        
        let convertedCount = 0;
        
        legacyIncomes.forEach(legacyIncome => {
            // Create a new ScheduleVersion for this legacy income
            const newScheduleVersion = {
                id: 'schedule_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: legacyIncome.name,
                amount: parseFloat(legacyIncome.amount || 0),
                frequency: legacyIncome.frequency || 'Bi-Weekly',
                isPrimary: false,
                isDeleted: false,
                createdDate: getCurrentDateString(),
                lastModified: getCurrentDateString()
            };
            
            // Add to incomeSchedules array
            incomeSchedules.push(newScheduleVersion);
            
            // Generate initial PaydayMarkers for this schedule
            generatePaydayMarkersForSchedule(newScheduleVersion);
            
            convertedCount++;
        });
        
        // Remove legacy income entries
        incomes = incomes.filter(income => income.isPrimary || income.createdDate);
        
        // Save the updated data
        saveData();
        
        // Update the display
        renderApp();
        
        // Show success message
        legacyConversionStatusText.textContent = ` Successfully converted ${convertedCount} legacy income entries to modern format.`;
        legacyConversionStatusText.style.color = 'var(--ok)';
        
        // Show detailed success modal
        showModal({
            title: 'Legacy Income Conversion Complete',
            text: `Successfully converted ${convertedCount} legacy income entries to the modern immutable payday system.\n\nAll your income data has been preserved and is now using the new system with better tracking and reliability.`,
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
        
        // Reset status after 5 seconds
        setTimeout(() => {
            legacyConversionStatus.style.display = 'none';
        }, 5000);
    }

    function testEmojiSupport() {
        // Show status
        emojiTestStatus.style.display = 'block';
        emojiTestStatusText.textContent = 'Testing emoji support...';
        emojiTestStatusText.style.color = 'var(--accent)';
        
        // Reset cache to force fresh test
        emojiSupportCache = null;
        
        const isSupported = detectEmojiSupport();
        
        // Update static emojis to reflect the current detection result
        updateStaticEmojis();
        const userAgent = navigator.userAgent;
        const isCordova = window.cordova ? 'Yes' : 'No';
        const isWebView = userAgent.includes('WebView') ? 'Yes' : 'No';
        
        let statusText = '';
        let statusColor = '';
        
        if (isSupported) {
            statusText = ` Emoji support detected!  should display correctly.`;
            statusColor = 'var(--ok)';
        } else {
            statusText = ` Emoji support not detected. Using fallback icons.`;
            statusColor = 'var(--danger)';
        }
        
        statusText += `\n\nEnvironment Info:\n Cordova: ${isCordova}\n WebView: ${isWebView}\n User Agent: ${userAgent.substring(0, 50)}...`;
        
        emojiTestStatusText.textContent = statusText;
        emojiTestStatusText.style.color = statusColor;
        
        // Show detailed modal
        showModal({
            title: 'Emoji Support Test Results',
            text: `Emoji Support: ${isSupported ? ' Supported' : ' Not Supported'}\n\nEnvironment Details:\n Cordova Environment: ${isCordova}\n WebView: ${isWebView}\n User Agent: ${userAgent}\n\n${isSupported ? 'The  emoji should display correctly in your app.' : 'The app will use fallback icons (like $) instead of emojis for better compatibility.'}`,
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
        
        // Reset status after 10 seconds
        setTimeout(() => {
            emojiTestStatus.style.display = 'none';
        }, 10000);
    }

    function updateDateOverrideDisplay() {
        const currentDate = getCurrentDate();
        currentDateValue.textContent = currentDate.toLocaleDateString();
        
        if (dateOverride) {
            overrideDateValue.textContent = new Date(dateOverride).toLocaleDateString();
            overrideDateDisplay.style.display = 'block';
            // Set the input field to show the current override date
            dateOverrideInput.value = dateOverride;
        } else {
            overrideDateDisplay.style.display = 'none';
            // Clear the input field when no override is active
            dateOverrideInput.value = '';
        }
    }

    // Immutable Payday System - Core Functions
    
    /**
     * Creates a new ScheduleVersion with PaydayMarkers for all future occurrences
     */
    function submitPrimaryIncome() {
        const name = primaryIncomeName.value.trim();
        const amount = parseFloat(paycheckAmount.value);
        const payday = nextPayday.value;
        const frequency = payFrequency.value;

        if (!name) {
            alert('Please enter an income name');
            primaryIncomeName.focus();
            return;
        }

        if (!amount || amount <= 0) {
            alert('Please enter a valid paycheck amount');
            paycheckAmount.focus();
            return;
        }

        if (!payday) {
            alert('Please select a payday date');
            nextPayday.focus();
            return;
        }

        const today = getCurrentDateString();
        const todayDate = getCurrentDate();
        
        // Check if there's an existing primary income schedule
        const existingPrimarySchedule = incomeSchedules.find(schedule => schedule.isPrimary && !schedule.isDeleted);
        
        if (existingPrimarySchedule) {
            // Check if this is a name-only update
            const isNameOnlyUpdate = (
                existingPrimarySchedule.amount === amount &&
                existingPrimarySchedule.frequency === frequency &&
                existingPrimarySchedule.name !== name
            );
            
            if (isNameOnlyUpdate) {
                // NAME-ONLY UPDATE: Just update the name without creating new versions
                console.log(` Name-only update: "${existingPrimarySchedule.name}"  "${name}"`);
                
                // Update the existing schedule name
                existingPrimarySchedule.name = name;
                existingPrimarySchedule.lastModified = today;
                
                // Update all future PaydayMarkers with the new name
                const futureMarkers = paydayMarkers.filter(marker => 
                    marker.scheduleId === existingPrimarySchedule.id && 
                    marker.status === 'planned' &&
                    new Date(marker.occurrenceDate) > todayDate
                );
                
                futureMarkers.forEach(marker => {
                    marker.scheduleName = name;
                });
                
                console.log(` Updated ${futureMarkers.length} future PaydayMarkers with new name`);
                
                // Show name update success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--ok); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
                successMsg.textContent = ` Name updated: "${name}" (${futureMarkers.length} future paydays updated)`;
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 3000);
                
            } else {
                // ADAPTIVE PAY CALCULATION: Update existing schedule for future paydays only
                
                // Mark the old schedule as deleted (but keep it for historical records)
                existingPrimarySchedule.isDeleted = true;
                existingPrimarySchedule.deletedDate = today;
                
                // Cancel all future PaydayMarkers from the old schedule
                const futureMarkers = paydayMarkers.filter(marker => 
                    marker.scheduleId === existingPrimarySchedule.id && 
                    marker.status === 'planned' &&
                    new Date(marker.occurrenceDate) > todayDate
                );
                
                futureMarkers.forEach(marker => {
                    marker.status = 'canceled';
                    marker.canceledDate = today;
                    marker.canceledReason = 'Amount/frequency updated';
                });
                
                console.log(` Canceled ${futureMarkers.length} future PaydayMarkers from old schedule`);
                
                // Create new ScheduleVersion with updated parameters
                const newScheduleVersion = {
                    id: 'schedule_' + Date.now(),
                    name: name,
                    amount: amount,
                    frequency: frequency,
                    effectiveFromDate: today,
                    createdDate: today,
                    isPrimary: true,
                    isDeleted: false,
                    previousScheduleId: existingPrimarySchedule.id // Link to previous version
                };
                
                // Add new schedule
                incomeSchedules.push(newScheduleVersion);
                
                // Generate new PaydayMarkers starting from the next payday
                const newMarkers = generatePaydayMarkers(newScheduleVersion, payday, 24);
                paydayMarkers.push(...newMarkers);
                
                console.log(` Updated Primary Income Schedule (Adaptive Pay)`);
                console.log(` Old amount: $${existingPrimarySchedule.amount}  New amount: $${amount}`);
                console.log(` Generated ${newMarkers.length} new PaydayMarkers starting from ${payday}`);
                console.log(` Preserved ${paydayMarkers.filter(m => m.scheduleId === existingPrimarySchedule.id && m.status !== 'canceled').length} historical PaydayMarkers`);
                
                // Show adaptive pay success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--accent); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
                successMsg.textContent = ` Adaptive Pay: Updated to $${amount.toFixed(2)} (preserved ${paydayMarkers.filter(m => m.scheduleId === existingPrimarySchedule.id && m.status !== 'canceled').length} historical paydays)`;
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 4000);
            }
            
        } else {
            // First time setup - create initial schedule
        const scheduleVersion = {
            id: 'schedule_' + Date.now(),
                name: name,
            amount: amount,
            frequency: frequency,
            effectiveFromDate: today,
            createdDate: today,
            isPrimary: true,
            isDeleted: false
        };

        // Add to schedules
        incomeSchedules.push(scheduleVersion);

        // Generate PaydayMarkers for the next 2 years (reasonable limit)
        const markers = generatePaydayMarkers(scheduleVersion, payday, 24); // 24 months
        paydayMarkers.push(...markers);

            console.log(` Created initial ScheduleVersion: ${scheduleVersion.id}`);
        console.log(` Generated ${markers.length} PaydayMarkers starting from ${payday}`);
        console.log(` First few markers:`, markers.slice(0, 3).map(m => `${m.occurrenceDate} (#${m.occurrenceNumber})`));

            // Show initial setup success message
        const successMsg = document.createElement('div');
        successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--ok); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
        successMsg.textContent = ` Income schedule created with ${markers.length} payday markers`;
        document.body.appendChild(successMsg);
        setTimeout(() => successMsg.remove(), 3000);
        }

        // Run system audit to ensure integrity
        auditIncomeSystem();

        // Re-render to show the new schedule
        renderApp(true);
        renderCalendar();
        updateSummary();
        renderIncomeList();
    }

    /**
     * Generates PaydayMarkers for a schedule version
     */
    function generatePaydayMarkers(scheduleVersion, startDate, monthsToGenerate = 24) {
        const markers = [];
        // Parse the date string directly to avoid timezone issues
        const start = parseDateLocal(startDate);
        const endDate = new Date(start);
        endDate.setMonth(endDate.getMonth() + monthsToGenerate);

        let currentDate = new Date(start);
        let occurrenceNumber = 1;

        while (currentDate <= endDate) {
            const marker = {
                id: 'marker_' + scheduleVersion.id + '_' + occurrenceNumber,
                scheduleId: scheduleVersion.id,
                scheduleName: scheduleVersion.name,
                amount: scheduleVersion.amount,
                occurrenceDate: formatDateLocal(currentDate),
                occurrenceNumber: occurrenceNumber,
                status: 'planned', // planned, issued, canceled, failed
                createdDate: getCurrentDateString()
            };

            markers.push(marker);

            // Calculate next occurrence
            if (scheduleVersion.frequency === 'Weekly') {
                currentDate.setDate(currentDate.getDate() + 7);
            } else if (scheduleVersion.frequency === 'Bi-Weekly') {
                currentDate.setDate(currentDate.getDate() + 14);
            } else if (scheduleVersion.frequency === 'Monthly') {
                currentDate.setMonth(currentDate.getMonth() + 1);
            }

            occurrenceNumber++;
        }

        return markers;
    }

    /**
     * Processes PaydayMarkers and issues PaydayRecords for today's paydays
     * Also handles unissuing payments when going back in time
     * Follows immutable principles with idempotency and transaction safety
     */
    function processPaydayMarkers() {
        const today = getCurrentDateString();
        let balanceUpdated = false;

        console.log(` Processing PaydayMarkers for date: ${today}`);
        console.log(` Total PaydayMarkers: ${paydayMarkers.length}`);
        console.log(` Total PaydayRecords: ${paydayRecords.length}`);

        // First, handle unissuing payments when going back in time
        const futureRecords = paydayRecords.filter(record => 
            new Date(record.occurrenceDate) > new Date(today) && record.status === 'issued'
        );

        if (futureRecords.length > 0) {
            console.log(` Unissuing ${futureRecords.length} payments that are now in the future`);
            
            futureRecords.forEach(record => {
                // Remove the amount from balance
                const currentBalanceValue = parseFloat(currentBalance.value) || 0;
                const newBalance = currentBalanceValue - parseFloat(record.amount);
                currentBalance.value = newBalance.toFixed(2);
                
                // Mark the record as reversed
                record.status = 'reversed';
                
                // Find and reset the corresponding PaydayMarker
                const marker = paydayMarkers.find(m => m.id === record.markerId);
                if (marker) {
                    marker.status = 'planned';
                    console.log(` Unissued payment: ${record.name} - $${record.amount}`);
                }
                
                balanceUpdated = true;
            });
        }

        // Find all PaydayMarkers for today with status 'planned'
        const todaysMarkers = paydayMarkers.filter(marker => 
            marker.occurrenceDate === today && marker.status === 'planned'
        );

        console.log(` PaydayMarkers for today (${today}): ${todaysMarkers.length}`);
        todaysMarkers.forEach(marker => {
            const schedule = getActiveScheduleVersion(marker.scheduleId, marker.occurrenceDate);
            const scheduleName = schedule ? schedule.name : 'Unknown';
            const isPrimary = schedule ? schedule.isPrimary : false;
            console.log(`  - ${marker.id}: ${marker.scheduleId} (${marker.occurrenceNumber}) - ${scheduleName} ${isPrimary ? '(Primary)' : '(Secondary)'}`);
        });

        if (todaysMarkers.length === 0) {
            console.log(' No paydays to process today');
            if (balanceUpdated) {
                saveData();
                updateSummary();
                renderCalendar();
            }
            return; // No paydays to process
        }

        // Process each marker in a transaction-like manner
        todaysMarkers.forEach(marker => {
            try {
                // Check for idempotency - ensure no duplicate PaydayRecord exists
                const existingRecord = paydayRecords.find(record => 
                    record.scheduleId === marker.scheduleId && 
                    record.occurrenceDate === marker.occurrenceDate
                );

                if (existingRecord) {
                    console.log(`PaydayRecord already exists for ${marker.scheduleId} on ${marker.occurrenceDate}`);
                    return; // Skip - already processed
                }

                // Get the active schedule version for this marker
                const activeSchedule = getActiveScheduleVersion(marker.scheduleId, marker.occurrenceDate);
                if (!activeSchedule) {
                    console.error(`No active schedule found for marker ${marker.id}`);
                    marker.status = 'failed';
                    return;
                }

                // Create immutable PaydayRecord
                const paydayRecord = {
                    id: 'record_' + marker.id,
                    markerId: marker.id,
                    scheduleId: marker.scheduleId,
                    occurrenceDate: marker.occurrenceDate,
                    occurrenceNumber: marker.occurrenceNumber,
                    
                    // Snapshot of schedule parameters at time of issuance
                    amount: activeSchedule.amount,
                    frequency: activeSchedule.frequency,
                    name: activeSchedule.name,
                    
                    // Issuance metadata
                    issuedDate: today,
                    issuedTimestamp: new Date().toISOString(),
                    
                    // Status
                    status: 'issued' // issued, reversed
                };

                // Add to balance
                const currentBalanceValue = parseFloat(currentBalance.value) || 0;
                const newBalance = currentBalanceValue + parseFloat(paydayRecord.amount);
                currentBalance.value = newBalance.toFixed(2);

                // Commit the transaction
                paydayRecords.push(paydayRecord);
                marker.status = 'issued';
                
                balanceUpdated = true;
                
                console.log(` PaydayRecord issued: ${paydayRecord.name} - $${paydayRecord.amount} added to balance`);

                // Generate next PaydayMarker if schedule is still active
                generateNextPaydayMarker(activeSchedule, marker);

            } catch (error) {
                console.error(`Error processing marker ${marker.id}:`, error);
                marker.status = 'failed';
            }
        });

        if (balanceUpdated) {
            saveData();
            updateSummary();
            renderCalendar();
            
            // Show notification
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--ok); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
            successMsg.textContent = ` ${todaysMarkers.length} payday(s) processed! Check your updated balance.`;
            document.body.appendChild(successMsg);
            setTimeout(() => successMsg.remove(), 3000);
        }
    }

    /**
     * Gets the active schedule version for a given date
     */
    function getActiveScheduleVersion(scheduleId, targetDate) {
        // Find all versions of this schedule
        const versions = incomeSchedules.filter(schedule => schedule.id === scheduleId);
        
        // Sort by effective date (most recent first)
        versions.sort((a, b) => new Date(b.effectiveFromDate) - new Date(a.effectiveFromDate));
        
        // Find the version that was active on the target date
        for (const version of versions) {
            if (new Date(targetDate) >= new Date(version.effectiveFromDate) && !version.isDeleted) {
                return version;
            }
        }
        
        return null;
    }

    /**
     * Generates the next PaydayMarker after issuing a PaydayRecord
     */
    function generateNextPaydayMarker(schedule, issuedMarker) {
        // Calculate next occurrence date
        const lastDate = new Date(issuedMarker.occurrenceDate + 'T00:00:00');
        let nextDate = new Date(lastDate);
        
        if (schedule.frequency === 'Weekly') {
            nextDate.setDate(nextDate.getDate() + 7);
        } else if (schedule.frequency === 'Bi-Weekly') {
            nextDate.setDate(nextDate.getDate() + 14);
        } else if (schedule.frequency === 'Monthly') {
            nextDate.setMonth(nextDate.getMonth() + 1);
        }

        // Create next marker
        const nextMarker = {
            id: 'marker_' + schedule.id + '_' + (issuedMarker.occurrenceNumber + 1),
            scheduleId: schedule.id,
            occurrenceDate: formatDateLocal(nextDate),
            occurrenceNumber: issuedMarker.occurrenceNumber + 1,
            status: schedule.isDeleted ? 'canceled' : 'planned',
            createdDate: getCurrentDate().toISOString().split('T')[0]
        };

        paydayMarkers.push(nextMarker);
    }
    const handleWallpaperFile = async (e) => {
        const file = e.target.files[0];
        if (file && file.size < 5*1024*1024) {
            const reader = new FileReader();
            reader.onload = (e) => {
                localStorage.setItem('sum-it-forecast.wallpaper', e.target.result);
                updateWallpaper();
                saveData();
            };
            reader.readAsDataURL(file);
        } else if (file) {
            await showModal({ title: 'File Too Large', text: 'Please select an image smaller than 5MB.', buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]});
        }
    };
    const handleCalendarNav = (e) => {
        const dayCell = e.target.closest('.calendar-day');
        if (dayCell && !dayCell.classList.contains('other-month')) {
            const day = dayCell.querySelector('.day-number').textContent;
            const date = new Date(calendarDate.getFullYear(), calendarDate.getMonth(), day);
            showDayBreakdown(date); 
            return;
        }
        let reRender = false;
        if (e.target.closest('#prevMonthBtn')) {
            if (!disableBackMonthNavToggle.classList.contains('active')) {
                calendarDate.setMonth(calendarDate.getMonth() - 1);
                reRender = true;
            }
        }
        else if (e.target.closest('#nextMonthBtn')) { calendarDate.setMonth(calendarDate.getMonth() + 1); reRender = true; }
        else if (e.target.closest('#printCalendarBtn')) { 
            handleCalendarPrint();
        }
        if (reRender) { renderCalendar(); }
    };

    function generateExportFilename() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');

        return `SF-Export-${year}-${month}-${day}-${hours}-${minutes}-${seconds}.json`;
    }

    // DEPRECATED: This function uses insecure localStorage keys and should not be used
    // Use exportProfile(profileId) instead for secure profile-specific exports
    function handleExportProfile() {
        console.warn('DEPRECATED: handleExportProfile() is insecure and should not be used. Use exportProfile(profileId) instead.');
        try {
            // Safely parse data from localStorage with error handling
            const profileData = {
                bills: JSON.parse(localStorage.getItem('sum-it-forecast.bills') || '[]'),
                debts: JSON.parse(localStorage.getItem('sum-it-forecast.debts') || '[]'),
                dashboardSections: JSON.parse(localStorage.getItem('sum-it-forecast.dashboardSections') || '[]'),
                incomes: JSON.parse(localStorage.getItem('sum-it-forecast.incomes') || '[]'),
                settings: JSON.parse(localStorage.getItem('sum-it-forecast.settings') || '{}'),
                wallpaper: localStorage.getItem('sum-it-forecast.wallpaper') || null
            };

            // Generate default filename and prompt user for custom filename
            const defaultFilename = generateExportFilename();
            const customFilename = prompt('Enter filename for export:', defaultFilename);

            // If user cancels the prompt, don't proceed with export
            if (customFilename === null) {
                return;
            }

            // Use custom filename or default if empty
            const finalFilename = customFilename.trim() || defaultFilename;

            // Check if we're running in Cordova with file plugin
            if (window.cordova && window.cordova.file && window.resolveLocalFileSystemURL) {
                // Cordova export method
                exportProfileCordova(profileData, finalFilename);
            } else {
                // Browser fallback method
                exportProfileBrowser(profileData, finalFilename);
            }
        } catch (error) {
            console.error("Failed to export profile:", error);
            showModal({
                title: 'Export Error',
                text: 'Could not export profile. There may be corrupted data in your local storage. Try resetting to factory defaults first.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
        }
    }

    function exportProfileBrowser(profileData, finalFilename) {
        const blob = new Blob([JSON.stringify(profileData, null, 2)], { type: 'application/json;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.setAttribute("download", finalFilename);
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        console.log("Profile exported successfully as:", finalFilename);
    }

    function exportProfileCordova(profileData, finalFilename) {
        const data = JSON.stringify(profileData, null, 2);

        // Request external storage permissions if needed
        if (window.cordova.plugins && window.cordova.plugins.permissions) {
            const permissions = window.cordova.plugins.permissions;
            
            // Check if we're on Android and need storage permissions
            if (cordova.platformId === 'android') {
                // For Android, request both read and write permissions
                const permissionList = [
                    permissions.WRITE_EXTERNAL_STORAGE,
                    permissions.READ_EXTERNAL_STORAGE
                ];
                
                permissions.requestPermissions(permissionList, function(status) {
                    if (status.hasPermission) {
                        saveFileToCordova(data, finalFilename);
                    } else {
                        showModal({
                            title: 'Permission Required',
                            text: 'Storage permissions are required to export files to your device. Please grant the requested permissions and try again.',
                            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                        });
                    }
                }, function() {
                    // Permission request failed, try to save anyway
                    console.log('Permission request failed, attempting to save anyway');
                    saveFileToCordova(data, finalFilename);
                });
            } else {
                // For other platforms, try to save directly
                saveFileToCordova(data, finalFilename);
            }
        } else {
            // No permissions plugin available, try to save directly
            console.log('No permissions plugin available, attempting to save directly');
            saveFileToCordova(data, finalFilename);
        }
    }

    function saveFileToCordova(data, finalFilename) {
        // Use Cordova file system to save to external storage
        // For Android, use external storage directory that's accessible to users
        let targetDirectory;
        
        if (cordova.platformId === 'android') {
            // For Android, try external storage first, then Documents directory
            targetDirectory = cordova.file.externalRootDirectory + 'Download/' || 
                             cordova.file.externalDataDirectory || 
                             cordova.file.dataDirectory;
        } else {
            // For other platforms, use external data directory
            targetDirectory = cordova.file.externalDataDirectory || 
                             cordova.file.dataDirectory;
        }
        
        console.log('Attempting to save to directory:', targetDirectory);
        
        window.resolveLocalFileSystemURL(targetDirectory, function(dirEntry) {
            dirEntry.getFile(finalFilename, { create: true, exclusive: false }, function(fileEntry) {
                fileEntry.createWriter(function(fileWriter) {
                    fileWriter.onwriteend = function() {
                        console.log("Profile exported successfully as:", finalFilename);
                        showModal({
                            title: 'Export Successful',
                            text: `Profile exported successfully to external storage!\n\nFile: ${finalFilename}\nLocation: ${fileEntry.nativeURL}\n\nYou can find this file in your device's file manager.`,
                            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                        });
                    };

                    fileWriter.onerror = function(e) {
                        console.error("Failed to write file:", e);
                        // Try fallback directory if the first attempt failed
                        if (targetDirectory !== cordova.file.dataDirectory) {
                            console.log('Primary directory failed, trying fallback to app data directory');
                            saveFileToCordovaFallback(data, finalFilename);
                        } else {
                            showModal({
                                title: 'Export Error',
                                text: 'Failed to write the export file. Please check storage permissions or try again.',
                                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                            });
                        }
                    };

                    // Create a blob and write it
                    const blob = new Blob([data], { type: 'application/json;charset=utf-8;' });
                    fileWriter.write(blob);
                }, function(error) {
                    console.error("Failed to create file writer:", error);
                    showModal({
                        title: 'Export Error',
                        text: 'Failed to create export file. Please check storage permissions.',
                        buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                    });
                });
            }, function(error) {
                console.error("Failed to get file:", error);
                showModal({
                    title: 'Export Error',
                    text: 'Failed to create export file. Please check storage permissions.',
                    buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                });
            });
        }, function(error) {
            console.error("Failed to resolve file system:", error);
            showModal({
                title: 'Export Error',
                text: 'Failed to access file system. Please check if external storage is available.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
        });
    }

    function saveFileToCordovaFallback(data, finalFilename) {
        // Fallback to app data directory if external storage fails
        console.log('Using fallback directory: app data directory');
        
        window.resolveLocalFileSystemURL(cordova.file.dataDirectory, function(dirEntry) {
            dirEntry.getFile(finalFilename, { create: true, exclusive: false }, function(fileEntry) {
                fileEntry.createWriter(function(fileWriter) {
                    fileWriter.onwriteend = function() {
                        console.log("Profile exported successfully to app data directory:", finalFilename);
                        showModal({
                            title: 'Export Successful',
                            text: `Profile exported successfully!\n\nFile: ${finalFilename}\nLocation: App Data Directory\n\nNote: This file is saved in the app's private storage. You may need to use a file manager with root access to access it, or the file will be available when you reinstall the app.`,
                            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                        });
                    };

                    fileWriter.onerror = function(e) {
                        console.error("Failed to write file to fallback directory:", e);
                        showModal({
                            title: 'Export Error',
                            text: 'Failed to export the file. Please check if the app has sufficient storage space and try again.',
                            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                        });
                    };

                    // Create a blob and write it
                    const blob = new Blob([data], { type: 'application/json;charset=utf-8;' });
                    fileWriter.write(blob);
                }, function(error) {
                    console.error("Failed to create file writer in fallback:", error);
                    showModal({
                        title: 'Export Error',
                        text: 'Failed to create export file. Please try again.',
                        buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                    });
                });
            }, function(error) {
                console.error("Failed to get file in fallback:", error);
                showModal({
                    title: 'Export Error',
                    text: 'Failed to create export file. Please try again.',
                    buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                });
            });
        }, function(error) {
            console.error("Failed to resolve file system in fallback:", error);
            showModal({
                title: 'Export Error',
                text: 'Failed to access file system. Please try again.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
        });
    }

    function handleImportProfile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json,.json';
        input.onchange = e => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = async function(event) {
                try {
                    const profileData = JSON.parse(event.target.result);
                    if (profileData && profileData.bills && profileData.settings) {
                        localStorage.setItem('sum-it-forecast.bills', JSON.stringify(profileData.bills));
                        localStorage.setItem('sum-it-forecast.settings', JSON.stringify(profileData.settings));
                    if (profileData.debts) {
                        localStorage.setItem('sum-it-forecast.debts', JSON.stringify(profileData.debts));
                    }
                    if (profileData.dashboardSections) {
                        localStorage.setItem('sum-it-forecast.dashboardSections', JSON.stringify(profileData.dashboardSections));
                    }
                    if (profileData.incomes) {
                        localStorage.setItem('sum-it-forecast.incomes', JSON.stringify(profileData.incomes));
                    }
                        if (profileData.wallpaper) { localStorage.setItem('sum-it-forecast.wallpaper', profileData.wallpaper); }
                        else { localStorage.removeItem('sum-it-forecast.wallpaper'); }
                        await showModal({ title: 'Success', text: 'Profile imported successfully! The application will now reload.', buttons: [{ text: 'Reload', value: 'ok', class: 'save-btn' }]});
                        location.reload();
                    } else {
                        await showModal({ title: 'Error', text: 'Invalid profile file.', buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]});
                    }
                } catch (error) {
                    console.error("Failed to import profile:", error);
                    await showModal({ title: 'Error', text: 'Could not import profile.', buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]});
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    async function handleUnpaidTool() {
        const days = parseInt($('unpaidDays').value, 10);
        if (isNaN(days) || days < 0) {
            await showModal({
                title: 'Invalid Input',
                text: 'Please enter a valid number of days.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
            return;
        }

        const confirmRes = await showModal({
            title: 'Confirm Action',
            text: `Are you sure? This will mark ALL bills due after ${days} day(s) from now as 'unpaid'. This includes recurring bills and cannot be easily undone.`,
            buttons: [
                { text: 'Yes, Mark as Unpaid', value: 'confirm', class: 'danger-btn' },
                { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
            ]
        });

        if (confirmRes === 'confirm') {
            const targetDate = new Date();
            targetDate.setDate(targetDate.getDate() + days);
            targetDate.setHours(0, 0, 0, 0);

            let changes = 0;
            bills.forEach(bill => {
                const billDate = new Date(bill.date + 'T00:00:00');
                if (billDate >= targetDate) {
                    if(bill.status !== 'unpaid') {
                        bill.status = 'unpaid';
                        delete bill.paidTimestamp;
                        changes++;
                    }
                }
            });
            saveData();
            renderApp(true);
            await showModal({
                title: 'Success',
                text: `${changes} bill(s) were marked as unpaid.`,
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
        }
    }

    function toggleProfileOptions(e) {
        e.stopPropagation();
        
        if (profileOptions.style.display === 'none' || profileOptions.style.display === '') {
            profileOptions.style.display = 'flex';
        } else {
            profileOptions.style.display = 'none';
        }
    }

    async function handleProfileOptionAction(e) {
        e.stopPropagation();
        const action = e.target.closest('.profile-option-btn')?.dataset.action;
        
        if (!action) return;
        
        // Close options
        profileOptions.style.display = 'none';
        
        if (action === 'rename') {
            await handleRenameProfile(profileId);
        } else if (action === 'export') {
            await exportProfile(profileId);
        } else if (action === 'info') {
            await showProfileInfo(profileId);
        } else if (action === 'setPrimary') {
            await setAsPrimary(profileId);
        }
    }

    async function showProfileInfo(profileId) {
        const profile = profiles.find(p => p.id === profileId);
        if (!profile) return;
        
        const createdDate = new Date(profile.createdDate).toLocaleDateString();
        
        await showModal({
            title: 'Profile Information',
            text: `Profile: ${profile.name}\nCreated: ${createdDate}`,
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
    }
    
    async function setAsPrimary(profileId) {
        const profile = profiles.find(p => p.id === profileId);
        if (!profile) return;
        
        // Remove primary status from current primary profile
        profiles.forEach(p => {
            if (p.isPrimary) {
                p.isPrimary = false;
            }
        });
        
        // Set new primary profile
        profile.isPrimary = true;
        
        // Save changes
        saveProfilesList();
        renderProfilesList();
        
        showModal({
            title: 'Primary Profile Set',
            text: `"${profile.name}" is now your primary profile.`,
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
        
        // Debug: Log all profiles after setting primary
        console.log('All profiles after setting primary:', profiles.map(p => ({ name: p.name, isPrimary: p.isPrimary })));
    }

    function handleAddProfile() {
        // Toggle the profile creation options
        if (profileCreationOptions.style.display === 'none') {
            profileCreationOptions.style.display = 'block';
            
            // Add event listeners for profile creation options when they're shown
            const createNewProfileBtn = document.getElementById('createNewProfileBtn');
            const importProfileBtn = document.getElementById('importProfileBtn');
            
            if (createNewProfileBtn && !createNewProfileBtn.hasAttribute('data-listener-added')) {
                createNewProfileBtn.addEventListener('click', createNewProfile);
                createNewProfileBtn.setAttribute('data-listener-added', 'true');
            }
            if (importProfileBtn && !importProfileBtn.hasAttribute('data-listener-added')) {
                importProfileBtn.addEventListener('click', importProfile);
                importProfileBtn.setAttribute('data-listener-added', 'true');
            }
        } else {
            profileCreationOptions.style.display = 'none';
        }
    }
    
    function createNewProfile() {
        const profileName = prompt('Enter a name for your new profile:', `Profile ${profiles.length + 1}`);
        if (!profileName || !profileName.trim()) return;
        
        const newProfile = createProfile(profileName.trim());
        profiles.push(newProfile);
        saveProfilesList();
        renderProfilesList();
        
        // Hide the profile creation options
        profileCreationOptions.style.display = 'none';
        
        showModal({
            title: 'Profile Created',
            text: `Profile "${newProfile.name}" has been created successfully!`,
            buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
        });
    }
    
    function importProfile() {
        // Check if file input already exists to prevent double selection
        let fileInput = document.getElementById('profileImportFileInput');
        if (!fileInput) {
            fileInput = document.createElement('input');
            fileInput.id = 'profileImportFileInput';
            fileInput.type = 'file';
            fileInput.accept = '.json';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            
            fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const importedData = JSON.parse(text);
                
                console.log('Importing profile data:', importedData);
                
                // Validate imported data - check if it has the required data structure
                if (!importedData.bills && !importedData.debts && !importedData.settings) {
                    throw new Error('Invalid profile file format - missing required data');
                }
                
                // Extract profile name from the data or use a default
                let profileName = importedData.profileName || 'Imported Profile';
                if (!importedData.profileName && importedData.settings && importedData.settings.finances) {
                    // Try to create a meaningful name from the data
                    const balance = importedData.settings.finances.balance || '0';
                    profileName = `Imported Profile ($${balance})`;
                }
                
                // Create new profile
                const newProfile = createProfile(profileName);
                profiles.push(newProfile);
                saveProfilesList();
                
                console.log('Created new profile:', newProfile);
                
                // Import the data to the new profile
                const originalProfileId = currentProfileId;
                currentProfileId = newProfile.id;
                
                console.log('Switching to new profile for data import:', currentProfileId);
                
                // Save imported data to new profile
                if (importedData.bills) {
                    console.log('Importing bills:', importedData.bills.length, 'items');
                    saveProfileData('bills', importedData.bills);
                }
                if (importedData.debts) {
                    console.log('Importing debts:', importedData.debts.length, 'items');
                    saveProfileData('debts', importedData.debts);
                }
                if (importedData.archivedDebts) {
                    console.log('Importing archived debts:', importedData.archivedDebts.length, 'items');
                    saveProfileData('archivedDebts', importedData.archivedDebts);
                }
                if (importedData.goals) {
                    console.log('Importing goals:', importedData.goals.length, 'items');
                    saveProfileData('goals', importedData.goals);
                }
                if (importedData.incomeSchedules) {
                    console.log('Importing income schedules:', importedData.incomeSchedules.length, 'items');
                    saveProfileData('incomeSchedules', importedData.incomeSchedules);
                }
                if (importedData.paydayMarkers) {
                    console.log('Importing payday markers:', importedData.paydayMarkers.length, 'items');
                    saveProfileData('paydayMarkers', importedData.paydayMarkers);
                }
                if (importedData.paydayRecords) {
                    console.log('Importing payday records:', importedData.paydayRecords.length, 'items');
                    saveProfileData('paydayRecords', importedData.paydayRecords);
                }
                if (importedData.adjustments) {
                    console.log('Importing adjustments:', importedData.adjustments.length, 'items');
                    saveProfileData('adjustments', importedData.adjustments);
                }
                if (importedData.settings) {
                    console.log('Importing settings');
                    saveProfileData('settings', importedData.settings);
                }
                if (importedData.incomes) {
                    console.log('Importing incomes');
                    saveProfileData('incomes', importedData.incomes);
                }
                
                // Switch back to original profile
                currentProfileId = originalProfileId;
                localStorage.setItem('sum-it-forecast.currentProfileId', currentProfileId);
                
                console.log('Import completed successfully, switched back to profile:', currentProfileId);
                
                renderProfilesList();
                
                // Hide the profile creation options
                profileCreationOptions.style.display = 'none';
                
                showModal({
                    title: 'Profile Imported',
                    text: `Profile "${newProfile.name}" has been imported successfully!`,
                    buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                });
                
            } catch (error) {
                console.error('Import error:', error);
                showModal({
                    title: 'Import Failed',
                    text: 'Failed to import profile. Please make sure the file is a valid profile export.',
                    buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                });
            }
            
            // Reset file input for next use
            fileInput.value = '';
        });
        }
        
        // Trigger file selection
        fileInput.click();
    }

    async function handleRenameProfile(profileId) {
        const profile = profiles.find(p => p.id === profileId);
        if (!profile) return;
        
        const currentName = profile.name;
        const newName = prompt(`Enter new profile name:`, currentName);
        
        if (newName && newName.trim() && newName.trim() !== currentName) {
            profile.name = newName.trim();
            saveProfilesList();
            renderProfilesList();
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--accent); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
            successMsg.textContent = ` Profile renamed to "${newName.trim()}"`;
            document.body.appendChild(successMsg);
            setTimeout(() => successMsg.remove(), 3000);
        }
    }

    // DEPRECATED: This function uses insecure localStorage keys and should not be used
    // Use exportProfile(profileId) instead for secure profile-specific exports
    async function handleExportProfile() {
        console.warn('DEPRECATED: handleExportProfile() is insecure and should not be used. Use exportProfile(profileId) instead.');
        // Use the existing export functionality from Data Management
        try {
            // Safely parse data from localStorage with error handling
            const profileData = {
                bills: JSON.parse(localStorage.getItem('sum-it-forecast.bills') || '[]'),
                debts: JSON.parse(localStorage.getItem('sum-it-forecast.debts') || '[]'),
                dashboardSections: JSON.parse(localStorage.getItem('sum-it-forecast.dashboardSections') || '[]'),
                incomes: JSON.parse(localStorage.getItem('sum-it-forecast.incomes') || '[]'),
                settings: JSON.parse(localStorage.getItem('sum-it-forecast.settings') || '{}'),
                wallpaper: localStorage.getItem('sum-it-forecast.wallpaper') || null,
                incomeSchedules: JSON.parse(localStorage.getItem('sum-it-forecast.incomeSchedules') || '[]'),
                paydayMarkers: JSON.parse(localStorage.getItem('sum-it-forecast.paydayMarkers') || '[]'),
                paydayRecords: JSON.parse(localStorage.getItem('sum-it-forecast.paydayRecords') || '[]'),
                adjustments: JSON.parse(localStorage.getItem('sum-it-forecast.adjustments') || '[]'),
                profileName: localStorage.getItem('sum-it-forecast.profileName') || 'Profile 1',
                profileCreatedDate: localStorage.getItem('sum-it-forecast.profileCreatedDate') || new Date().toISOString().split('T')[0]
            };

            // Generate filename with current date
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const defaultFilename = `sum-it-profile-${dateStr}.json`;

            // Ask user for custom filename
            const customFilename = prompt('Enter filename for export (or leave blank for default):', defaultFilename);

            // If user cancels the prompt, don't proceed with export
            if (customFilename === null) {
                return;
            }

            // Use custom filename or default if empty
            const finalFilename = customFilename.trim() || defaultFilename;

            // Check if we're running in Cordova with file plugin
            if (window.cordova && window.cordova.file && window.resolveLocalFileSystemURL) {
                // Cordova export method
                exportProfileCordova(profileData, finalFilename);
            } else {
                // Browser fallback method
                exportProfileBrowser(profileData, finalFilename);
            }
        } catch (error) {
            console.error("Failed to export profile:", error);
            await showModal({
                title: 'Export Error',
                text: 'Could not export profile. There may be corrupted data in your local storage. Try resetting to factory defaults first.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
        }
    }

    async function handleResetProfile() {
        const choice = await showModal({
            title: 'Confirm Reset',
            text: 'Are you sure you want to reset EVERYTHING to factory defaults? All bills, financial info, and appearance settings will be permanently deleted.',
            buttons: [
                { text: 'Yes, Reset Everything', value: 'confirm', class: 'danger-btn' },
                { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
            ]
        });

        if (choice === 'confirm') {
            localStorage.removeItem('sum-it-forecast.bills');
            localStorage.removeItem('sum-it-forecast.settings');
            localStorage.removeItem('sum-it-forecast.wallpaper');
            localStorage.removeItem('sum-it-forecast.debts');
            localStorage.removeItem('sum-it-forecast.dashboardSections');
            
            // Set default enabled sections after factory reset
            const defaultSections = [
                { id: 'balanceSummaryCard', name: 'Available Balance', description: 'Your current available balance', visible: true, order: 1, required: true },
                { id: 'dueSummaryCard', name: 'Your Share', description: 'Your share of upcoming bills', visible: true, order: 2, required: false },
                { id: 'pendingBillsCard', name: 'Pending', description: 'Bills pending payment', visible: true, order: 3, required: false },
                { id: 'next30DaysCard', name: 'Next 30 Days', description: 'Bills due in the next 30 days', visible: true, order: 4, required: false },
                { id: 'recurringPaymentManagerCard', name: 'Recurring Payment Manager', description: 'Manage and analyze recurring payments', visible: false, order: 5, required: false },
                { id: 'financeCard', name: 'My Finances', description: 'Financial management tools', visible: true, order: 6, required: true },
                { id: 'theTabCard', name: 'The Tab', description: 'Track shared expenses and debts', visible: true, order: 7, required: true },
                { id: 'expenseTrackerCard', name: 'Log Expense', description: 'Quick expense logging', visible: true, order: 8, required: false },
                { id: 'billTrackerCard', name: 'Upcoming Bills', description: 'All upcoming bills', visible: false, order: 9, required: false },
                { id: 'pastBillsCard', name: 'Past Bills', description: 'Previously paid bills', visible: false, order: 10, required: false }
            ];
            localStorage.setItem('sum-it-forecast.dashboardSections', JSON.stringify(defaultSections));
            
            await showModal({ title: 'Profile Reset', text: 'Your profile has been reset. The application will now reload.', buttons: [{ text: 'Reload', value: 'ok', class: 'save-btn' }]});
            location.reload();
        }
    }

    // --- DEMO MODE ---
    function generateDemoProfile() {
        // --- Helpers ---
        const rand = (min, max) => Math.random() * (max - min) + min;
        const randInt = (min, max) => Math.floor(rand(min, max + 1));
        const oneOf = (arr) => arr[Math.floor(Math.random() * arr.length)];
        const toYMD = (date) => date.toISOString().split('T')[0];
        let idCounter = Date.now();

        // --- Config ---
        const demoBills = [];
        const demoDebts = [];
        let demoSettings = {};
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const lookbackStartDate = new Date(today);
        lookbackStartDate.setFullYear(today.getFullYear() - 1);

        // 1. Finances
        const annualSalary = rand(75000, 95000);
        const paycheck = parseFloat((annualSalary / 26).toFixed(2));
        let nextPayday = new Date(today);
        // Find the next Friday. If today is Friday, it's a potential payday.
        nextPayday.setDate(nextPayday.getDate() + (5 - nextPayday.getDay() + 7) % 7);
        if (randInt(0, 1) === 1) { // 50% chance the next payday is one week later
            nextPayday.setDate(nextPayday.getDate() + 7);
        }

        demoSettings.finances = {
            balance: rand(paycheck * 0.8, paycheck * 2.2).toFixed(2),
            paycheck: paycheck,
            payday: toYMD(nextPayday),
            frequency: 'Bi-Weekly'
        };

        // 2. Recurring Bills & Their History
        const recurringBillTemplates = [
            { name: 'Mortgage', amount: rand(1400, 1800), day: 1, category: 'Rent/Mortgage', frequency: 'Monthly' },
            { name: 'Car Payment', amount: rand(450, 600), day: 15, category: 'Loan', frequency: 'Monthly' },
            { name: 'Car Insurance', amount: rand(100, 180), day: 20, category: 'Insurance', frequency: 'Monthly' },
            { name: 'Wisconsin Public Service', amount: rand(80, 250), day: randInt(5, 25), category: 'Utilities', frequency: 'Monthly' },
            { name: 'Spectrum Internet', amount: rand(80, 100), day: randInt(5, 25), category: 'Utilities', frequency: 'Monthly' },
            { name: 'Green Bay Water Utility', amount: rand(50, 90), day: randInt(5, 25), category: 'Utilities', frequency: 'Quarterly' },
            { name: 'AT&T Cell Phone', amount: rand(80, 130), day: randInt(5, 25), category: 'Subscription', frequency: 'Monthly' },
            { name: 'Netflix/Hulu Bundle', amount: rand(25, 45), day: randInt(5, 25), category: 'Subscription', frequency: 'Monthly' },
            { name: 'Planet Fitness', amount: rand(25, 45), day: randInt(5, 25), category: 'Personal', frequency: 'Monthly' },
        ];

        recurringBillTemplates.forEach(billTmpl => {
            // Find the next due date for this bill
            let nextDueDate = new Date(today);
            nextDueDate.setDate(billTmpl.day);
            if (nextDueDate < today) {
                if (billTmpl.frequency === 'Monthly') {
                    nextDueDate.setMonth(nextDueDate.getMonth() + 1);
                } else if (billTmpl.frequency === 'Quarterly') {
                    nextDueDate.setMonth(nextDueDate.getMonth() + 3);
                }
            }

            // Create the main recurring bill (the one that shows up as upcoming)
            demoBills.push({
                id: idCounter++,
                name: billTmpl.name,
                amount: parseFloat(billTmpl.amount.toFixed(2)),
                date: toYMD(nextDueDate),
                category: billTmpl.category,
                frequency: billTmpl.frequency,
                status: 'unpaid',
                notes: 'Recurring payment'
            });

            // Now, generate the history of 'paid' bills for this recurring item
            let historicalDueDate = new Date(nextDueDate);
            while (historicalDueDate > lookbackStartDate) {
                // Move to the PREVIOUS due date
                if (billTmpl.frequency === 'Monthly') {
                    historicalDueDate.setMonth(historicalDueDate.getMonth() - 1);
                } else if (billTmpl.frequency === 'Quarterly') {
                    historicalDueDate.setMonth(historicalDueDate.getMonth() - 3);
                }

                if (historicalDueDate < lookbackStartDate) break;
                
                // Create a paid, one-time bill for this historical date
                const paidAmount = billTmpl.amount * rand(0.95, 1.05); // slight variation
                demoBills.push({
                    id: idCounter++,
                    name: billTmpl.name, // Same name to link them conceptually
                    amount: parseFloat(paidAmount.toFixed(2)),
                    date: toYMD(historicalDueDate),
                    category: billTmpl.category,
                    frequency: 'One-Time', // Historical entries are always one-time
                    status: 'paid',
                    paidTimestamp: historicalDueDate.toISOString(),
                    notes: 'Recurring payment history'
                });
            }
        });

        // 3. Historical One-Off Paid Expenses (for realism)
        const expenseTemplates = {
            Groceries: { names: ["Woodman's", "Pick 'n Save", "Festival Foods", "Meijer", "Aldi"], amount: [70, 220], perWeek: 1.2 },
            Gas: { names: ["Kwik Trip", "Shell", "BP", "Costco Gas"], amount: [40, 70], perWeek: 1 },
            Food: { names: ["Kroll's East", "Hinterland Brewery", "Chipotle", "Culver's", "Titletown Gameday"], amount: [15, 85], perWeek: 3 },
            Coffee: { names: ["Starbucks", "Colectivo Coffee", "Kwik Trip Coffee"], amount: [4, 12], perWeek: 3 },
            Personal: { names: ["Target", "Amazon Order", "Walmart", "Bay Park Square Mall"], amount: [40, 400], perWeek: 0.5 },
            Entertainment: { names: ["Resch Center Event", "Concert Ticket", "Packers Game", "Lambeau Field Tour"], amount: [50, 300], perWeek: 0.2 }
        };

        for (let d = new Date(lookbackStartDate); d <= today; d.setDate(d.getDate() + 1)) {
            Object.entries(expenseTemplates).forEach(([category, config]) => {
                if (Math.random() < config.perWeek / 7) {
                    const expenseDate = new Date(d);
                    const amount = rand(config.amount[0], config.amount[1]);
                    demoBills.push({
                        id: idCounter++,
                        name: oneOf(config.names),
                        amount: parseFloat(amount.toFixed(2)),
                        date: toYMD(expenseDate),
                        category: category,
                        frequency: 'One-Time',
                        status: 'paid',
                        paidTimestamp: expenseDate.toISOString(),
                        notes: 'One-time expense'
                    });
                }
            });
        }
        
        // 4. "The Tab" Debts
        const friends = ['Aaron', 'Jordy', 'Davante', 'Clay'];
        for(let i=0; i < randInt(2, 4); i++) {
            const debtDate = new Date(today);
            debtDate.setDate(debtDate.getDate() - randInt(1, 45));
            demoDebts.push({
                id: idCounter++,
                name: oneOf(friends),
                amount: randInt(10, 50),
                date: toYMD(debtDate),
                notes: oneOf(['For lunch', 'Concert ticket', 'Drinks at Hinterland']),
                status: 'outstanding',
                paidAmount: 0
            });
        }

        // 5. Save to localStorage
        localStorage.setItem('sum-it-forecast.bills', JSON.stringify(demoBills));
        localStorage.setItem('sum-it-forecast.debts', JSON.stringify(demoDebts));
        const existingSettings = JSON.parse(localStorage.getItem('sum-it-forecast.settings') || '{}');
        const finalSettings = {...existingSettings, ...demoSettings};
        localStorage.setItem('sum-it-forecast.settings', JSON.stringify(finalSettings));
    }


    // --- EVENT HANDLERS ---
    $('billFrequency').addEventListener('change', () => {
        $('customFrequencyWrapper').style.display = $('billFrequency').value === 'Custom' ? 'grid' : 'none';
    });
    $('editBillFrequency').addEventListener('change', () => {
        $('editCustomFrequencyWrapper').style.display = $('editBillFrequency').value === 'Custom' ? 'grid' : 'none';
    });

    // --- EVENT LISTENERS ---
    const privacyToggleBtn = $('privacyToggleBtn');
    if (privacyToggleBtn) {
        privacyToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent the summary from toggling
            e.preventDefault();
            const financeStack = $('financeCard').querySelector('.stack');
            const isBlurred = financeStack.classList.toggle('blurred');
            $('actualBalance').classList.toggle('privacy-blurred', isBlurred);
            $('projected10Day').classList.toggle('privacy-blurred', isBlurred);
            privacyToggleBtn.querySelector('.eye-open').style.display = isBlurred ? 'none' : 'block';
            privacyToggleBtn.querySelector('.eye-closed').style.display = isBlurred ? 'block' : 'none';
            saveData(); // Save the new state
        });
    }
    addBillBtnHeader.addEventListener('click', async () => {
        if (document.body.classList.contains('mobile-view')) {
            const choice = await showModal({
                title: 'What would you like to add?',
                text: '',
                buttons: [
                    { text: 'Add a Bill', value: 'bill', class: 'save-btn' },
                    { text: 'Log an Expense', value: 'expense', class: 'special-btn' },
                    { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
                ]
            });
            if (choice === 'bill') {
                addBillModal.classList.add('visible');
            } else if (choice === 'expense') {
                toggleExpenseView(false, true); // Reset to quick options
                expenseModal.classList.add('visible');

                // Auto-focus first quick expense button on mobile
                if (window.innerWidth <= 768) {
                    setTimeout(() => {
                        const firstQuickBtn = expenseModal.querySelector('.quick-expense-btn');
                        if (firstQuickBtn) {
                            firstQuickBtn.focus();
                        }
                    }, 200); // Wait for modal animation to complete
                }
            }
        } else {
            addBillModal.classList.add('visible');
        }
    });
    closeAddBillModalBtn.addEventListener('click', () => addBillModal.classList.remove('visible'));
    archiveBtn.addEventListener('click', () => {
        appView.style.display = 'none';
        archiveView.style.display = 'flex';
        const categories = [...new Set(bills.map(b => b.category))].sort();
        filterCategory.innerHTML = '<option value="">All Categories</option>';
        categories.forEach(c => filterCategory.innerHTML += `<option value="${c}">${c}</option>`);
        renderArchive();
    });
    backFromArchiveBtn.addEventListener('click', () => { archiveView.style.display = 'none'; appView.style.display = 'grid'; });
    
    // Tab Archive Modal Event Listeners
    $('tabArchiveBtn').addEventListener('click', () => {
        $('tabArchiveModal').classList.add('visible');
        renderTabArchive();
    });
    $('closeTabArchiveModalBtn').addEventListener('click', () => {
        $('tabArchiveModal').classList.remove('visible');
    });
    
    addBtn.addEventListener('click', handleAddBill);
    expenseForm.addEventListener('submit', handleCustomExpenseSubmit);
    billListBody.addEventListener('click', handleListClick);
    pastBillsListBody.addEventListener('click', handleListClick);
    archiveBillsListBody.addEventListener('dblclick', async (e) => {
        const tr = e.target.closest('tr[data-id]');
        if (tr) {
            const billId = Number(tr.dataset.id);
            const bill = bills.find(b => b.id === billId);
            if (bill && bill.paidTimestamp) {
                const formattedDate = formatPaymentDateTime(bill.paidTimestamp);
                await showModal({
                    title: `"${bill.name}"`,
                    text: `Marked as Paid on: ${formattedDate}`,
                    buttons: [{ text: 'Close', value: 'close', class: 'cancel-btn' }]
                });
            }
        }
    });
    archiveBillsListBody.addEventListener('click', async (e) => {
        if (e.target.matches('.remove-btn')) {
            const tr = e.target.closest('tr');
            if (!tr) return;
            const billId = Number(tr.dataset.id);
            const bill = bills.find(b => b.id === billId);
            if (!bill) return;

            const choice = await showModal({
                title: 'Confirm Deletion',
                text: `Are you sure you want to permanently delete this paid record for "${bill.name}"? This cannot be undone.`,
                buttons: [
                    { text: 'Delete Record', value: 'delete', class: 'danger-btn' },
                    { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
                ]
            });

            if (choice === 'delete') {
                animateRemove(tr, () => {
                    bills = bills.filter(b => b.id !== billId);
                    saveData();
                    renderArchive();
                });
            }
        }
    });

    [filterSearchTerm, filterStartDate, filterEndDate, filterCategory].forEach(el => {
        el.addEventListener('input', renderArchive);
    });
    clearFiltersBtn.addEventListener('click', () => {
        filterSearchTerm.value = '';
        filterStartDate.value = '';
        filterEndDate.value = '';
        filterCategory.value = '';
        renderArchive();
    });

    $('customExpenseBtn').addEventListener('click', () => toggleExpenseView(true));
    $('cancelCustomExpenseBtn').addEventListener('click', () => toggleExpenseView(false));
    document.querySelectorAll('.quick-expense-btn').forEach(btn => btn.addEventListener('click', handleQuickExpense));

    // Expense Modal Listeners
    $('closeExpenseModalBtn').addEventListener('click', () => expenseModal.classList.remove('visible'));
    $('expenseModal').querySelectorAll('.quick-expense-btn').forEach(btn => btn.addEventListener('click', handleQuickExpense));
    $('customExpenseModalBtn').addEventListener('click', () => toggleExpenseView(true, true));
    $('cancelCustomExpenseModalBtn').addEventListener('click', () => toggleExpenseView(false, true));
    $('expenseModalForm').addEventListener('submit', (e) => {
        e.preventDefault();
        const desc = $('expenseModalDescription').value.trim();
        const amount = parseFloat($('expenseModalAmount').value);
        handleAddExpense(desc, amount, expenseModal);
        $('expenseModalForm').reset();
    });

    // Income Management Functions
    function shouldAdvancePayday(payday, frequency, createdDate = null) {
        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        
        const paydayDate = new Date(payday + 'T00:00:00');
        
        // If payday is today or in the future, don't advance
        if (paydayDate >= today) return false;
        
        // If we have a createdDate, use the "endurance" logic
        if (createdDate) {
            const createdDateObj = new Date(createdDate + 'T00:00:00');
            const daysSinceCreation = Math.floor((today - createdDateObj) / (1000 * 60 * 60 * 24));
            
            // If the income was created today (legacy data migration), use grace period logic instead
            if (daysSinceCreation === 0) {
                // Fall back to grace period logic for newly migrated incomes
                const daysDifference = Math.floor((today - paydayDate) / (1000 * 60 * 60 * 24));
                let gracePeriodDays;
                switch (frequency) {
                    case 'Weekly':
                        gracePeriodDays = 3;
                        break;
                    case 'Bi-Weekly':
                        gracePeriodDays = 5;
                        break;
                    case 'Monthly':
                        gracePeriodDays = 7;
                        break;
                    default:
                        gracePeriodDays = 5;
                }
                return daysDifference > gracePeriodDays;
            }
            
            const shouldAdvance = today > createdDateObj;
            // If the user has "endured" past the original commitment date, advance the payday
            return shouldAdvance;
        }
        
        // Fallback for incomes without createdDate (legacy data)
        // Use a simple grace period approach
        const daysDifference = Math.floor((today - paydayDate) / (1000 * 60 * 60 * 24));
        let gracePeriodDays;
        switch (frequency) {
            case 'Weekly':
                gracePeriodDays = 3;
                break;
            case 'Bi-Weekly':
                gracePeriodDays = 5;
                break;
            case 'Monthly':
                gracePeriodDays = 7;
                break;
            default:
                gracePeriodDays = 5;
        }
        return daysDifference > gracePeriodDays;
    }

    function auditPrimaryPayday() {
        const paydayValue = nextPayday.value;
        const frequency = payFrequency.value;
        
        if (!paydayValue || !frequency) return;
        
        // Get the primary income's createdDate for endurance logic
        const primaryIncome = incomes.find(inc => inc.isPrimary);
        const createdDate = primaryIncome ? primaryIncome.createdDate : null;
        
        // Only advance if it's reasonable to assume the user hasn't received the income yet
        if (shouldAdvancePayday(paydayValue, frequency, createdDate)) {
            const today = getCurrentDate();
            today.setHours(0, 0, 0, 0);
            
            let currentPayday = new Date(paydayValue + 'T00:00:00');
            
            if (frequency === 'Weekly') {
                currentPayday.setDate(currentPayday.getDate() + 7);
            } else if (frequency === 'Bi-Weekly') {
                currentPayday.setDate(currentPayday.getDate() + 14);
            } else if (frequency === 'Monthly') {
                let dayOfMonth = currentPayday.getDate();
                currentPayday.setMonth(currentPayday.getMonth() + 1);
                // Handle month-end edge cases (e.g., Jan 31 -> Feb 28/29)
                if (currentPayday.getDate() !== dayOfMonth) {
                    currentPayday.setDate(0); // Go to last day of previous month
                }
            }
            
            // Update the input field with the new payday
            nextPayday.value = currentPayday.toISOString().split('T')[0];
            
            // Save the updated data
            saveData();
            
            console.log(`Primary payday updated from ${paydayValue} to ${nextPayday.value} (${frequency} frequency)`);
        }
    }

    function getNextPayday(income) {
        if (!income.payday || !income.frequency) return income.payday;
        
        const today = getCurrentDate();
        today.setHours(0, 0, 0, 0);
        
        let currentPayday = new Date(income.payday + 'T00:00:00');
        const frequency = income.frequency;
        
        // Only advance if it's reasonable to assume the user hasn't received the income yet
        if (shouldAdvancePayday(income.payday, frequency, income.createdDate)) {
            if (frequency === 'Weekly') {
                currentPayday.setDate(currentPayday.getDate() + 7);
            } else if (frequency === 'Bi-Weekly') {
                currentPayday.setDate(currentPayday.getDate() + 14);
            } else if (frequency === 'Monthly') {
                let dayOfMonth = currentPayday.getDate();
                currentPayday.setMonth(currentPayday.getMonth() + 1);
                // Handle month-end edge cases (e.g., Jan 31 -> Feb 28/29)
                if (currentPayday.getDate() !== dayOfMonth) {
                    currentPayday.setDate(0); // Go to last day of previous month
                }
            }
        }
        
        // Format as YYYY-MM-DD for consistency with stored format
        return currentPayday.toISOString().split('T')[0];
    }

    function renderIncomeList() {
        const incomeList = $('incomeList');
        incomeList.innerHTML = '';

        // Show all income schedules (both primary and additional)
        incomeSchedules.forEach((schedule, index) => {
            if (schedule.isDeleted) return; // Skip deleted schedules
            
            const incomeItem = document.createElement('div');
            incomeItem.className = `income-item ${schedule.isPrimary ? 'primary-income' : ''}`;

            // Get PaydayMarker information for this schedule
            const nextPlannedMarker = paydayMarkers
                .filter(marker => marker.scheduleId === schedule.id && marker.status === 'planned')
                .sort((a, b) => new Date(a.occurrenceDate) - new Date(b.occurrenceDate))[0];
            
            const issuedCount = paydayMarkers.filter(marker => 
                marker.scheduleId === schedule.id && marker.status === 'issued'
            ).length;
            
            const canceledCount = paydayMarkers.filter(marker => 
                marker.scheduleId === schedule.id && marker.status === 'canceled'
            ).length;

            incomeItem.innerHTML = `
<div class="income-info">
                    <div class="income-name">${getEmojiOrFallback('', '$')} ${schedule.name}</div>
                    <div class="income-details">
                        <div class="income-detail"> $${parseFloat(schedule.amount || 0).toFixed(2)}</div>
                        <div class="income-detail"> ${nextPlannedMarker ? new Date(nextPlannedMarker.occurrenceDate).toLocaleDateString() : 'No upcoming paydays'}</div>
                        <div class="income-detail"> ${schedule.frequency}</div>
                        <div class="income-detail" style="font-size: 12px; color: var(--muted);">
                             ${issuedCount} issued   ${canceledCount} canceled
                        </div>
                    </div>
                </div>
                <div class="income-actions">
                    <button class="income-btn edit" data-id="${schedule.id}" title="Edit Income">
                         Edit
                    </button>
                    ${!schedule.isPrimary ? `<button class="income-btn delete" data-id="${schedule.id}" title="Delete Income">
                         Delete
                    </button>` : ''}
                </div>
            `;

            incomeList.appendChild(incomeItem);
        });

        // Also show any legacy incomes that haven't been converted to PaydayMarker system yet
        incomes.forEach((income, index) => {
            if (income.isPrimary) return; // Skip primary income (handled by schedules)
            
            // Check if this income already has a corresponding schedule
            const hasSchedule = incomeSchedules.some(schedule => schedule.id === income.id);
            if (hasSchedule) return; // Skip if already converted to PaydayMarker system
            
            const incomeItem = document.createElement('div');
            incomeItem.className = 'income-item legacy-income';
            
            const nextPayday = getNextPayday(income);
            incomeItem.innerHTML = `
<div class="income-info">
                    <div class="income-name">${getEmojiOrFallback('', '$')} ${income.name} <span style="font-size: 11px; color: var(--muted);">(Legacy)</span></div>
                    <div class="income-details">
                        <div class="income-detail"> $${parseFloat(income.amount || 0).toFixed(2)}</div>
                        <div class="income-detail"> ${nextPayday ? new Date(nextPayday).toLocaleDateString() : 'No date set'}</div>
                        <div class="income-detail"> ${income.frequency}</div>
                        <div class="income-detail" style="font-size: 12px; color: var(--warning);">
                             Legacy format - will be converted automatically
                        </div>
                    </div>
                </div>
                <div class="income-actions">
                    <button class="income-btn edit" data-id="${income.id}" title="Edit Income">
                         Edit
                    </button>
                    <button class="income-btn delete" data-id="${income.id}" title="Delete Income">
                         Delete
                    </button>
                </div>
            `;

            incomeList.appendChild(incomeItem);
        });
    }

    function showIncomeForm(incomeToEdit = null) {
        const incomeList = $('incomeList');
        const existingForm = incomeList.querySelector('.income-form');
        if (existingForm) existingForm.remove();

        const form = document.createElement('div');
        form.className = 'income-form';
        form.innerHTML = `
            <div class="income-form-row">
                <div class="income-form-group">
                    <label for="incomeName">Income Name</label>
                    <input type="text" id="incomeName" placeholder="e.g., Freelance Work" required>
                </div>
            </div>
            <div class="income-form-row">
                <div class="income-form-group">
                    <label for="incomeAmount">Amount ($)</label>
                    <input type="number" id="incomeAmount" placeholder="0.00" step="0.01" required>
                </div>
                <div class="income-form-group">
                    <label for="incomeFrequency">Frequency</label>
                    <select id="incomeFrequency">
                        <option value="Weekly">Weekly</option>
                        <option value="Bi-Weekly" selected>Bi-Weekly</option>
                        <option value="Monthly">Monthly</option>
                    </select>
                </div>
            </div>
            <div class="income-form-row">
                <div class="income-form-group">
                    <label for="incomePayday">Next Payday</label>
                    <input type="date" id="incomePayday" required>
                </div>
            </div>
            <div class="income-form-actions">
                <button type="button" class="cancel-btn" id="cancelIncomeBtn">Cancel</button>
                <button type="button" class="save-btn" id="saveIncomeBtn"> Submit Income Schedule</button>
            </div>
        `;

        incomeList.insertBefore(form, incomeList.firstChild);

        // Pre-fill form if editing
        if (incomeToEdit) {
            $('incomeName').value = incomeToEdit.name;
            $('incomeAmount').value = incomeToEdit.amount;
            $('incomeFrequency').value = incomeToEdit.frequency;
            $('incomePayday').value = incomeToEdit.payday;
        }

        // Focus first input
        setTimeout(() => {
            $('incomeName').focus();
        }, 100);

        // Add form event listeners
        $('cancelIncomeBtn').addEventListener('click', () => form.remove());
        $('saveIncomeBtn').addEventListener('click', () => saveIncome(incomeToEdit, form));
    }

    function saveIncome(incomeToEdit, form) {
        const name = $('incomeName').value.trim();
        const amount = parseFloat($('incomeAmount').value);
        const frequency = $('incomeFrequency').value;
        const payday = $('incomePayday').value;

        // Enhanced validation
        if (!name) {
            alert('Please enter an income name');
            $('incomeName').focus();
            return;
        }

        if (isNaN(amount) || amount <= 0) {
            alert('Please enter a valid amount greater than $0');
            $('incomeAmount').focus();
            return;
        }

        if (!payday) {
            alert('Please select a payday date');
            $('incomePayday').focus();
            return;
        }

        // Check for duplicate names (excluding the one being edited)
        const existingIncome = incomes.find(inc => 
            inc.name.toLowerCase() === name.toLowerCase() && 
            inc.id !== (incomeToEdit ? incomeToEdit.id : null)
        );
        
        if (existingIncome) {
            alert(`An income stream named "${name}" already exists. Please choose a different name.`);
            $('incomeName').focus();
            return;
        }

        if (incomeToEdit) {
            // Editing existing income - use adaptive pay system
            const success = updateIncomeAdaptively(incomeToEdit.id, amount, frequency, payday, name);
            
            if (!success) {
                alert('Failed to update income. Please try again.');
                return;
            }
            
            // Note: We no longer update legacy income entries to avoid duplication
            // The PaydayMarker system handles all income updates
            
            console.log(` Updated income "${name}" using adaptive pay system`);
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--accent); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
            successMsg.textContent = ` "${name}" updated using adaptive pay system`;
            document.body.appendChild(successMsg);
            setTimeout(() => successMsg.remove(), 3000);
        } else {
            // Add new income using PaydayMarker system
            if (incomes.length >= 5) {
                alert('Maximum of 5 income streams allowed');
                return;
            }

            const today = getCurrentDateString();
            
            // Create ScheduleVersion for the additional income
            const scheduleVersion = {
                id: 'schedule_' + Date.now(),
                name: name,
                amount: amount,
                frequency: frequency,
                effectiveFromDate: today,
                createdDate: today,
                isPrimary: false,
                isDeleted: false
            };

            // Add to schedules
            incomeSchedules.push(scheduleVersion);

            // Generate PaydayMarkers for the next 2 years
            const markers = generatePaydayMarkers(scheduleVersion, payday, 24); // 24 months
            paydayMarkers.push(...markers);

            // Note: We no longer add to legacy incomes array to avoid duplication
            // The PaydayMarker system handles all income display and management
            
            console.log(` Created additional income ScheduleVersion: ${scheduleVersion.id}`);
            console.log(` Generated ${markers.length} PaydayMarkers starting from ${payday}`);
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--ok); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
            successMsg.textContent = ` "${name}" added with ${markers.length} payday markers`;
            document.body.appendChild(successMsg);
            setTimeout(() => successMsg.remove(), 3000);
        }

        saveData();
        form.remove();
        renderIncomeList();
        updateSummary();
    }

    function deleteIncome(incomeId) {
        // First try to find in schedules (PaydayMarker system)
        const schedule = incomeSchedules.find(s => s.id === incomeId);
        if (schedule) {
            const confirmMessage = `Are you sure you want to delete "${schedule.name}"?\n\n This will COMPLETELY remove this income:\n All past paydays will be removed from history\n All future paydays will be canceled\n This action cannot be undone`;
            
            if (confirm(confirmMessage)) {
                // Use the new complete deletion system
                const deletedCount = deleteIncomeCompletely(incomeId);
                
                saveData();
                renderIncomeList();
                updateSummary();
                renderCalendar();
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--danger); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
                successMsg.textContent = ` Completely deleted "${schedule.name}" - ${deletedCount} paydays removed`;
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 4000);
            }
        } else {
            // Fall back to legacy income system
            const income = incomes.find(inc => inc.id === incomeId);
            if (!income) return;
            
            const confirmMessage = `Are you sure you want to delete "${income.name}"?`;
            
            if (confirm(confirmMessage)) {
                const index = incomes.findIndex(inc => inc.id === incomeId);
                if (index > -1) {
                    incomes.splice(index, 1);
                }
                
                saveData();
                renderIncomeList();
                updateSummary();
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--ok); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
                successMsg.textContent = ` "${income.name}" deleted successfully`;
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 3000);
            }
        }
    }

    // Income Modal Event Listeners
    $('manageIncomeBtn').addEventListener('click', () => {
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        const isMultipleIncomeEnabled = enableMultipleIncomeToggle.classList.contains('active');
        
        // Check if premium and multiple income feature is enabled
        if (!isPremiumEnabled || !isMultipleIncomeEnabled) {
            showModal({
                title: 'Premium Feature',
                text: 'Multiple income streams is a premium feature. To manage additional income streams, please upgrade to Premium.\n\nYour additional income data is preserved and will be restored when you upgrade.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
            return;
        }
        
        renderIncomeList();
        $('incomeModal').classList.add('visible');
    });

    $('closeIncomeModalBtn').addEventListener('click', () => {
        $('incomeModal').classList.remove('visible');
    });

    $('addIncomeBtn').addEventListener('click', () => {
        if (incomes.length >= 5) {
            alert('Maximum of 5 income streams allowed');
            return;
        }
        showIncomeForm();
    });

    // Event delegation for income actions
    $('incomeList').addEventListener('click', (e) => {
        const target = e.target.closest('.income-btn');
        if (!target) return;

        const incomeId = target.dataset.id;

        if (target.classList.contains('edit')) {
            // First try to find in schedules (PaydayMarker system)
            const scheduleToEdit = incomeSchedules.find(s => s.id === incomeId);
            if (scheduleToEdit) {
                // Convert schedule to legacy format for editing
                const incomeToEdit = {
                    id: scheduleToEdit.id,
                    name: scheduleToEdit.name,
                    amount: scheduleToEdit.amount,
                    frequency: scheduleToEdit.frequency,
                    payday: '', // Will be set from next planned marker
                    isPrimary: scheduleToEdit.isPrimary,
                    createdDate: scheduleToEdit.createdDate
                };
                
                // Get the next planned payday from markers
                const nextMarker = paydayMarkers
                    .filter(marker => marker.scheduleId === scheduleToEdit.id && marker.status === 'planned')
                    .sort((a, b) => new Date(a.occurrenceDate) - new Date(b.occurrenceDate))[0];
                
                if (nextMarker) {
                    incomeToEdit.payday = nextMarker.occurrenceDate;
                }
                
                showIncomeForm(incomeToEdit);
            } else {
                // Fall back to legacy income system
                const incomeToEdit = incomes.find(inc => inc.id === incomeId);
                if (incomeToEdit) {
                    showIncomeForm(incomeToEdit);
                }
            }
        } else if (target.classList.contains('delete')) {
            deleteIncome(incomeId);
        }
    });


    billListBody.addEventListener('dblclick', handleListDoubleClick);
    pastBillsListBody.addEventListener('dblclick', handleListDoubleClick);
    saveEditBtn.addEventListener('click', handleSaveEdit);
    closeModalBtn.addEventListener('click', closeEditModal);
    $('closeDayBreakdownModalBtn').addEventListener('click', closeDayBreakdownModal);
    $('dayBreakdownModal').addEventListener('click', handleModalActionClick);
    // Menu state management
    let isMenuOpen = false;
    let originalBodyStyle = {};
    let originalDocumentStyle = {};
    
    /**
     * Open menu with screen lock
     */
    function openMenu() {
        if (isMenuOpen) return;
        
        console.log(' Opening menu with screen lock...');
        
        // Store original styles
        originalBodyStyle = {
            overflow: document.body.style.overflow,
            position: document.body.style.position,
            top: document.body.style.top,
            left: document.body.style.left,
            right: document.body.style.right,
            width: document.body.style.width,
            height: document.body.style.height
        };
        
        originalDocumentStyle = {
            overflow: document.documentElement.style.overflow,
            position: document.documentElement.style.position,
            top: document.documentElement.style.top,
            left: document.documentElement.style.left,
            right: document.documentElement.style.right,
            width: document.documentElement.style.width,
            height: document.documentElement.style.height
        };
        
        // Lock the screen
        const scrollY = window.scrollY;
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'fixed';
        document.body.style.top = `-${scrollY}px`;
        document.body.style.left = '0';
        document.body.style.right = '0';
        document.body.style.width = '100%';
        document.body.style.height = '100%';
        
        document.documentElement.style.overflow = 'hidden';
        document.documentElement.style.position = 'fixed';
        document.documentElement.style.top = `-${scrollY}px`;
        document.documentElement.style.left = '0';
        document.documentElement.style.right = '0';
        document.documentElement.style.width = '100%';
        document.documentElement.style.height = '100%';
        
        // Create backdrop overlay
        createMenuBackdrop();
        
        // Show menu
        menuPanel.style.display = 'block';
        menuPanel.setAttribute('aria-hidden', 'false');
        
        // Store scroll position for restoration
        document.body.dataset.scrollY = scrollY.toString();
        
        isMenuOpen = true;
        
        // Add menu-open class for additional styling if needed
        document.body.classList.add('menu-open');
        document.documentElement.classList.add('menu-open');
        
        console.log(' Menu opened with screen lock');
    }
    
    /**
     * Close menu and restore screen
     */
    function closeMenu() {
        if (!isMenuOpen) return;
        
        console.log(' Closing menu and restoring screen...');
        
        // Remove backdrop overlay
        removeMenuBackdrop();
        
        // Hide menu
        menuPanel.style.display = 'none';
        menuPanel.setAttribute('aria-hidden', 'true');
        
        // Restore original styles
        document.body.style.overflow = originalBodyStyle.overflow || '';
        document.body.style.position = originalBodyStyle.position || '';
        document.body.style.top = originalBodyStyle.top || '';
        document.body.style.left = originalBodyStyle.left || '';
        document.body.style.right = originalBodyStyle.right || '';
        document.body.style.width = originalBodyStyle.width || '';
        document.body.style.height = originalBodyStyle.height || '';
        
        document.documentElement.style.overflow = originalDocumentStyle.overflow || '';
        document.documentElement.style.position = originalDocumentStyle.position || '';
        document.documentElement.style.top = originalDocumentStyle.top || '';
        document.documentElement.style.left = originalDocumentStyle.left || '';
        document.documentElement.style.right = originalDocumentStyle.right || '';
        document.documentElement.style.width = originalDocumentStyle.width || '';
        document.documentElement.style.height = originalDocumentStyle.height || '';
        
        // Restore scroll position
        const scrollY = parseInt(document.body.dataset.scrollY || '0');
        window.scrollTo(0, scrollY);
        delete document.body.dataset.scrollY;
        
        isMenuOpen = false;
        
        // Remove menu-open class
        document.body.classList.remove('menu-open');
        document.documentElement.classList.remove('menu-open');
        
        console.log(' Menu closed and screen restored');
    }
    
    // Enhanced menu toggle with screen lock
    menuBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const isOpen = menuPanel.style.display === 'block';
        if (isOpen) {
            closeMenu();
        } else {
            openMenu();
        }
    });
    
    closeMenuNotch.addEventListener('click', closeMenu);
    
    // Profile event listeners
    addProfileBtn.addEventListener('click', handleAddProfile);
    
    // Close options when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.profile-item')) {
            document.querySelectorAll('.profile-options').forEach(options => {
                options.style.display = 'none';
            });
        }
    });
    
    // Create backdrop overlay for menu
    let menuBackdrop = null;
    
    function createMenuBackdrop() {
        if (menuBackdrop) return;
        
        menuBackdrop = document.createElement('div');
        menuBackdrop.id = 'menuBackdrop';
        menuBackdrop.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9998;
            pointer-events: auto;
        `;
        
        // Close menu when clicking backdrop
        menuBackdrop.addEventListener('click', closeMenu);
        menuBackdrop.addEventListener('touchstart', (e) => {
            e.preventDefault();
        e.stopPropagation();
        }, { passive: false });
        
        document.body.appendChild(menuBackdrop);
    }
    
    function removeMenuBackdrop() {
        if (menuBackdrop) {
            menuBackdrop.remove();
            menuBackdrop = null;
        }
    }
    
    // Prevent keyboard events from propagating when menu is open
    document.addEventListener('keydown', (e) => {
        if (isMenuOpen) {
            // Allow escape key to close menu
            if (e.key === 'Escape') {
                e.preventDefault();
        e.stopPropagation();
                closeMenu();
                return;
            }
    
            // Prevent other keyboard events from reaching dashboard
        e.stopPropagation();
        }
    });
    
    // Handle back button on mobile devices
    window.addEventListener('popstate', (e) => {
        if (isMenuOpen) {
            e.preventDefault();
            closeMenu();
            // Push a new state to prevent back button from closing the app
            history.pushState(null, '', window.location.href);
        }
    });
    
    // Push initial state to handle back button
    history.pushState(null, '', window.location.href);
    calendarToggleBtn.addEventListener('click', () => {
        const wasListView = currentView === 'list';
        currentView = currentView === 'list' ? 'calendar' : 'list';
        if (wasListView && currentView === 'calendar') {
            resetCalendarToCurrentMonth();
        }
        renderApp(true);
    });
    calendarView.addEventListener('click', handleCalendarNav);

    // Swipe navigation for calendar on mobile
    function handleSwipeGesture() {
        const swipeThreshold = 50; // minimum distance for a swipe in pixels
        if (document.body.classList.contains('mobile-view') && currentView === 'calendar') {
            if (touchEndX < touchStartX - swipeThreshold) {
                // Swiped left
                calendarDate.setMonth(calendarDate.getMonth() + 1);
                renderCalendar();
            } else if (touchEndX > touchStartX + swipeThreshold) {
                // Swiped right
                if (!disableBackMonthNavToggle.classList.contains('active')) {
                    calendarDate.setMonth(calendarDate.getMonth() - 1);
                    renderCalendar();
                }
            }
        }
    }

    function handleMainViewSwipe() {
        // Ensure there was a touchstart event
        if (touchStartX === 0) return;

        const swipeThreshold = 50;
        const verticalThreshold = 75; // Don't swipe if scrolling vertically

        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;

        // Reset coordinates for the next swipe
        touchStartX = 0;
        touchStartY = 0;

        if (Math.abs(deltaX) < swipeThreshold || Math.abs(deltaY) > verticalThreshold) {
            // Not a long enough horizontal swipe, or it's mostly a vertical scroll
            return;
        }

        const isDashboardActive = dashboardTabBtn.classList.contains('active');
        const isGoalsActive = goalsTabBtn.classList.contains('active');
        const isStatisticsActive = statisticsTabBtn.classList.contains('active');

        if (isDashboardActive && deltaX < 0) { // Swiped left from Dashboard
            goalsTabBtn.click();
        } else if (isGoalsActive && deltaX < 0) { // Swiped left from Goals
            statisticsTabBtn.click();
        } else if (isGoalsActive && deltaX > 0) { // Swiped right from Goals
            dashboardTabBtn.click();
        } else if (isStatisticsActive && deltaX > 0) { // Swiped right from Statistics
            goalsTabBtn.click();
        }
    }
    calendarView.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
    }, { passive: true });

    calendarView.addEventListener('touchend', e => {
        // Stop the event from bubbling to the main view's swipe listener
        e.stopPropagation();
        touchEndX = e.changedTouches[0].screenX;

        const swipeThreshold = 50; // minimum distance for a swipe in pixels

        // Ensure it's in mobile mode and the calendar is the current view
        if (document.body.classList.contains('mobile-view') && currentView === 'calendar') {
            if (touchEndX < touchStartX - swipeThreshold) {
                // Swiped left (next month)
                calendarDate.setMonth(calendarDate.getMonth() + 1);
                renderCalendar();
            } else if (touchEndX > touchStartX + swipeThreshold) {
                // Swiped right (previous month)
                if (!disableBackMonthNavToggle.classList.contains('active')) {
                    calendarDate.setMonth(calendarDate.getMonth() - 1);
                    renderCalendar();
                }
            }
        }
    });

    // Swipe navigation for main views
    const setupSwipeListener = (element) => {
        element.addEventListener('touchstart', e => {
            // Do not start a swipe if the user is interacting with a form element or a scrollable area
            if (e.target.closest('input, select, textarea, button, [contenteditable]')) return;
            if (e.target.closest('.scrollable, .bill-table-wrapper, #pendingBillsList, #next30DaysList, .debt-list')) return;

            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        element.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleMainViewSwipe();
        }, { passive: true });
    };
    setupSwipeListener(appView);
    setupSwipeListener(statisticsView);
    setupSwipeListener(goalsView);

    [currentBalance, paycheckAmount, nextPayday, payFrequency].forEach(el => el.addEventListener('input', () => { saveData(); updateSummary(); }));
    
    // Add Enter key functionality to income input fields
    function addEnterSubmitToField(field) {
        field.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                
                // Add visual feedback
                field.style.backgroundColor = 'var(--accent)';
                field.style.color = 'white';
                
                // Submit the income schedule
                submitPrimaryIncome();
                
                // Reset visual feedback after a short delay
                setTimeout(() => {
                    field.style.backgroundColor = '';
                    field.style.color = '';
                }, 200);
            }
        });
    }
    
    // Apply Enter key functionality to all income-related fields
    addEnterSubmitToField(paycheckAmount);
    addEnterSubmitToField(nextPayday);
    addEnterSubmitToField(payFrequency);
    
    // Add click event listener for the submit income button
    submitIncomeBtn.addEventListener('click', () => {
        // Add visual feedback
        submitIncomeBtn.style.transform = 'scale(0.95)';
        submitIncomeBtn.style.opacity = '0.8';
        
        // Submit the income schedule
        submitPrimaryIncome();
        
        // Reset visual feedback after a short delay
        setTimeout(() => {
            submitIncomeBtn.style.transform = '';
            submitIncomeBtn.style.opacity = '';
        }, 150);
    });
    
    // Add event listener for the dontAutoDeduct toggle
    dontAutoDeductToggle.addEventListener('click', () => {
        dontAutoDeductToggle.classList.toggle('active');
        saveData();
        updateSummary();
    });

    // Mobile input improvements
    const isMobile = window.innerWidth <= 768;

    if (isMobile) {
        // Add Enter key support for finance inputs
        [currentBalance, paycheckAmount].forEach(input => {
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur(); // Close keyboard
                    saveData();
                    updateSummary();
                }
            });
        });

        // Add Enter key support for expense inputs
        const expenseDescription = $('expenseDescription');
        const expenseAmount = $('expenseAmount');

        if (expenseDescription && expenseAmount) {
            expenseDescription.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    expenseAmount.focus(); // Move to amount field
                }
            });

            expenseAmount.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    expenseAmount.blur(); // Close keyboard
                    // Auto-submit the expense form
                    const desc = expenseDescription.value.trim();
                    const amount = parseFloat(expenseAmount.value);
                    if (desc && !isNaN(amount) && amount > 0) {
                        handleAddExpense(desc, amount);
                    }
                }
            });
        }

        // Auto-scroll to keep focused inputs in view
        const keepInputInView = (input) => {
            if (isMobile) {
                setTimeout(() => {
                    const rect = input.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    const keyboardHeight = 300; // Approximate mobile keyboard height

                    // If input is too close to bottom (likely covered by keyboard)
                    if (rect.bottom > viewportHeight - keyboardHeight) {
                        const scrollAmount = rect.bottom - (viewportHeight - keyboardHeight) + 50;
                        window.scrollBy({
                            top: scrollAmount,
                            behavior: 'smooth'
                        });
                    }
                }, 300); // Small delay to let keyboard appear
            }
        };

        // Apply to all finance inputs
        [currentBalance, paycheckAmount, nextPayday, payFrequency].forEach(input => {
            input.addEventListener('focus', () => keepInputInView(input));
        });

        // Apply to expense inputs when they exist
        if (expenseDescription && expenseAmount) {
            expenseDescription.addEventListener('focus', () => keepInputInView(expenseDescription));
            expenseAmount.addEventListener('focus', () => keepInputInView(expenseAmount));
        }
    }
    document.querySelectorAll('.menu-panel input, .menu-panel select').forEach(el => {
        const event = el.type === 'range' || el.type === 'color' ? 'input' : 'change';
        el.addEventListener(event, () => {
            applyAllAppearance();
            saveData();
            
            // Handle landscape mode toggle
            if (el.id === 'disableLandscapeModeToggle') {
                applyLandscapeMode();
            }
        });
    });

    function applyLandscapeMode() {
        if (disableLandscapeModeToggle.classList.contains('active')) {
            // Disable landscape mode by setting viewport meta tag
            let viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=portrait');
            }
        } else {
            // Enable landscape mode by restoring default viewport
            let viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=yes');
            }
        }
    }

    function showPremiumRequiredModal() {
        showModal({
            title: 'Premium Feature',
            text: 'Unlimited future balance projections are a Premium feature. Please enable Premium to access this advanced functionality.',
            buttons: [
                { text: 'OK', value: 'ok', class: 'save-btn' }
            ]
        });
    }

    function backupPremiumFeatures() {
        // Backup current premium feature states before disabling them
        const premiumFeaturesBackup = {
            limitDailyBalance: limitDailyBalanceToggle.classList.contains('active'),
            enableCalendarPrint: enableCalendarPrintToggle.classList.contains('active'),
            enableMultipleIncome: enableMultipleIncomeToggle.classList.contains('active'),
            // Add more premium features here as they are implemented
            // example: customTheme: customThemeToggle.classList.contains('active'),
            // example: advancedReports: advancedReportsToggle.classList.contains('active'),
            backupTimestamp: new Date().toISOString() // Track when backup was made
        };
        localStorage.setItem('sum-it-forecast.premiumFeaturesBackup', JSON.stringify(premiumFeaturesBackup));
        console.log(' Premium features backed up:', premiumFeaturesBackup);
    }

    function restorePremiumFeatures() {
        // Restore premium feature states from backup
        const backupData = localStorage.getItem('sum-it-forecast.premiumFeaturesBackup');
        if (backupData) {
            try {
                const premiumFeaturesBackup = JSON.parse(backupData);
                let restoredFeatures = [];
                
                // Restore each premium feature if it was enabled in backup
                if (typeof premiumFeaturesBackup.limitDailyBalance === 'boolean' && premiumFeaturesBackup.limitDailyBalance) {
                    limitDailyBalanceToggle.classList.add('active');
                    restoredFeatures.push('Unlimited Projections');
                }
                if (typeof premiumFeaturesBackup.enableCalendarPrint === 'boolean' && premiumFeaturesBackup.enableCalendarPrint) {
                    enableCalendarPrintToggle.classList.add('active');
                    restoredFeatures.push('Calendar Print');
                }
                if (typeof premiumFeaturesBackup.enableMultipleIncome === 'boolean' && premiumFeaturesBackup.enableMultipleIncome) {
                    enableMultipleIncomeToggle.classList.add('active');
                    restoredFeatures.push('Multiple Income Streams');
                }
                
                // Add more premium features here as they are implemented
                // if (typeof premiumFeaturesBackup.customTheme === 'boolean' && premiumFeaturesBackup.customTheme) {
                //     customThemeToggle.classList.add('active');
                //     restoredFeatures.push('Custom Theme');
                // }
                
                if (restoredFeatures.length > 0) {
                    console.log(' Premium features restored:', restoredFeatures);
                    
                    // Show user feedback about restored features
                    const restoredMsg = document.createElement('div');
                    restoredMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--accent); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600; max-width: 300px;';
                    restoredMsg.innerHTML = ` Premium features restored:<br> ${restoredFeatures.join('<br> ')}`;
                    document.body.appendChild(restoredMsg);
                    setTimeout(() => restoredMsg.remove(), 4000);
                    
                    // Re-render calendar and update summary to reflect restored features
                    renderCalendar();
                    updateSummary();
                } else {
                    console.log('No premium features were previously enabled - all features remain off');
                }
            } catch (error) {
                console.error('Error restoring premium features backup:', error);
            }
        } else {
            console.log('No premium feature backup found - all features remain off');
        }
    }

    function auditPremiumFeatures() {
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        
        if (!isPremiumEnabled) {
            // Check if any premium features are currently active before disabling them
            const hasActiveFeatures = limitDailyBalanceToggle.classList.contains('active') ||
                                    enableCalendarPrintToggle.classList.contains('active') ||
                                    enableMultipleIncomeToggle.classList.contains('active');
            
            // If there are active features, backup them before disabling
            if (hasActiveFeatures) {
                console.log(' Premium disabled - backing up active features before disabling');
                backupPremiumFeatures();
            }
            
            // Hard disable all premium features regardless of saved settings
            limitDailyBalanceToggle.classList.remove('active');
            enableCalendarPrintToggle.classList.remove('active');
            enableMultipleIncomeToggle.classList.remove('active');
            
            // Save the corrected state immediately
            saveData();
        }
        // Note: We don't restore features here - that only happens when Premium is explicitly enabled
    }

    function handleCalendarPrint() {
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        const isPrintEnabled = enableCalendarPrintToggle.classList.contains('active');
        
        if (!isPremiumEnabled || !isPrintEnabled) {
            showModal({
                title: 'Premium Required',
                text: 'Calendar print functionality is a Premium feature. Please upgrade to Premium to print your calendar.',
                buttons: [
                    { text: 'OK', value: 'ok', class: 'save-btn' }
                ]
            });
            return;
        }
        
        // If both premium and print are enabled, proceed with printing
        window.print();
    }

    // Add event listeners for utility toggles
    function handleUtilityToggle(toggleElement, callback) {
        toggleElement.addEventListener('click', () => {
            toggleElement.classList.toggle('active');
            if (callback) callback();
            saveData();
        });
    }

    handleUtilityToggle(disableAutoOpenCurrentBillsToggle);
    handleUtilityToggle(blurSummaryToggle, applySummaryBlur);
    handleUtilityToggle(dailyBalanceInCalendarToggle, () => renderCalendar());
    handleUtilityToggle(disableBackMonthNavToggle, () => renderCalendar());
    handleUtilityToggle(disableLandscapeModeToggle, applyLandscapeMode);
    
    // Premium toggle event listener
    enablePremiumToggle.addEventListener('click', () => {
        const wasPremiumEnabled = enablePremiumToggle.classList.contains('active');
        enablePremiumToggle.classList.toggle('active');
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        
        if (!wasPremiumEnabled && isPremiumEnabled) {
            // Premium was just enabled - restore user's previous feature preferences
            restorePremiumFeatures();
            saveData();
        } else if (wasPremiumEnabled && !isPremiumEnabled) {
            // Premium was just disabled - backup current feature states before disabling
            backupPremiumFeatures();
        }
        
        // Always audit premium features when premium toggle changes
        auditPremiumFeatures();
        
        // Re-render calendar if daily balance is shown or if premium was just enabled
        if (dailyBalanceInCalendarToggle.classList.contains('active') || (isPremiumEnabled && !wasPremiumEnabled)) {
            renderCalendar();
        }
    });
    
    // Unlimited projections toggle with premium validation
    limitDailyBalanceToggle.addEventListener('click', () => {
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        const isCurrentlyActive = limitDailyBalanceToggle.classList.contains('active');
        
        // If trying to enable unlimited projections and premium is not enabled, show modal
        if (!isCurrentlyActive && !isPremiumEnabled) {
            showPremiumRequiredModal();
            return;
        }
        
        // Allow the toggle if premium is enabled or if disabling unlimited projections
        limitDailyBalanceToggle.classList.toggle('active');
        // Always audit premium features after any toggle change
        auditPremiumFeatures();
        // Re-render calendar if daily balance is shown
        if (dailyBalanceInCalendarToggle.classList.contains('active')) {
            renderCalendar();
        }
    });

    // Multiple income toggle with premium validation
    enableMultipleIncomeToggle.addEventListener('click', () => {
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        const isCurrentlyActive = enableMultipleIncomeToggle.classList.contains('active');
        
        // If trying to enable multiple income and premium is not enabled, show modal
        if (!isCurrentlyActive && !isPremiumEnabled) {
            showModal({
                title: 'Premium Required',
                text: 'Multiple income streams is a premium feature. Please upgrade to Premium to use this feature.',
                buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
            });
            return; // Don't toggle
        }
        
        // Toggle the multiple income setting
        enableMultipleIncomeToggle.classList.toggle('active');
        
        // If disabling multiple income, hide additional incomes from display
        if (!enableMultipleIncomeToggle.classList.contains('active')) {
            console.log('Multiple income disabled - additional incomes hidden but preserved');
            renderCalendar(); // Re-render calendar to hide additional incomes
            updateSummary(); // Update summary to exclude additional incomes
        } else {
            console.log('Multiple income enabled - showing all incomes');
            renderCalendar(); // Re-render calendar to show all incomes
            updateSummary(); // Update summary to include additional incomes
        }
        
        saveData();
    });

    // Calendar print toggle with premium validation
    enableCalendarPrintToggle.addEventListener('click', () => {
        const isPremiumEnabled = enablePremiumToggle.classList.contains('active');
        const isCurrentlyActive = enableCalendarPrintToggle.classList.contains('active');
        
        // If trying to enable calendar print and premium is not enabled, show modal
        if (!isCurrentlyActive && !isPremiumEnabled) {
            showModal({
                title: 'Premium Required',
                text: 'Calendar print functionality is a Premium feature. Please enable Premium to access this functionality.',
                buttons: [
                    { text: 'OK', value: 'ok', class: 'save-btn' }
                ]
            });
            return;
        }
        
        // Allow the toggle if premium is enabled or if disabling calendar print
        enableCalendarPrintToggle.classList.toggle('active');
        // Always audit premium features after any toggle change
        auditPremiumFeatures();
    });

    wallpaperFile.addEventListener('change', handleWallpaperFile);
    $('resetProfileBtn').addEventListener('click', handleResetProfile);
    $('unpaidToolBtn').addEventListener('click', handleUnpaidTool);
    $('resetDashboardOrderBtn').addEventListener('click', resetDashboardOrder);
    
    // Date override event listeners
    setDateOverrideBtn.addEventListener('click', setDateOverride);
    resetDateOverrideBtn.addEventListener('click', resetDateOverride);
    
    // Push notification test event listener
    testNotificationBtn.addEventListener('click', sendTestNotification);
    
    // Legacy income conversion event listener
    convertLegacyIncomeBtn.addEventListener('click', convertLegacyIncomeToModern);
    
    // Emoji support test event listener
    testEmojiSupportBtn.addEventListener('click', testEmojiSupport);
    
    // Debug: Clear income from calendar event listener
    clearIncomeFromCalendarBtn.addEventListener('click', clearIncomeFromCalendar);

    // Setup Cordova-dependent functionality after device is ready
    function setupCordovaFunctionality() {
        // Lock screen orientation to portrait
        if (window.screen && window.screen.orientation) {
            // Modern browser API
            window.screen.orientation.lock('portrait').catch(function(err) {
                console.log('Modern orientation lock failed:', err);
            });
        } else if (window.ScreenOrientation) {
            // Legacy browser API
            window.ScreenOrientation.lock('portrait').catch(function(err) {
                console.log('Legacy orientation lock failed:', err);
            });
        } else if (window.screen && window.screen.lockOrientation) {
            // Cordova plugin API
            window.screen.lockOrientation('portrait');
            console.log('Orientation locked to portrait using Cordova plugin');
        } else {
            console.log('No orientation lock API available');
        }
        
        $('exportProfileBtn').addEventListener('click', handleExportProfile);
        $('importProfileBtn').addEventListener('click', handleImportProfile);
        
        // Initialize push notifications
        if (window.PushNotification) {
            const push = PushNotification.init({
                android: {
                    senderID: "123456789" // Placeholder - replace with actual Firebase sender ID
                },
                ios: {
                    alert: "true",
                    badge: "true",
                    sound: "true"
                }
            });

            push.on('registration', function(data) {
                console.log("Push notification registration ID:", data.registrationId);
                // Store registration ID for server use
                localStorage.setItem('pushRegistrationId', data.registrationId);
            });

            push.on('notification', function(data) {
                console.log("Received push notification:", data);
                // Handle notification when app is in foreground
                if (data.additionalData && data.additionalData.foreground) {
                    // Show in-app notification or handle as needed
                    console.log("Foreground notification received:", data.message);
                }
            });

            push.on('error', function(e) {
                console.error("Push notification error:", e.message);
            });
        }
    }

    // Check if Cordova is available and setup accordingly
    if (window.cordova) {
        // Wait for device to be ready before setting up cordova functionality
        document.addEventListener('deviceready', function() {
            console.log('Cordova device ready, setting up file export functionality');
            setupCordovaFunctionality();
        }, false);
        
        // Fallback in case deviceready already fired
        if (document.readyState === 'complete') {
            setupCordovaFunctionality();
        }
    } else {
        // Not in Cordova environment, setup basic functionality
        console.log('Not in Cordova environment, setting up browser file operations');
        setupCordovaFunctionality();
    }

    $('demoModeBtn').addEventListener('click', async () => {
        const choice = await showModal({
            title: 'Enable Demo Mode?',
            text: 'This will replace your current profile with a randomized, pre-populated one.\n\nYour current data will be lost. This action cannot be undone.',
            buttons: [
                { text: 'Enable Demo', value: 'confirm', class: 'danger-btn' },
                { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
            ]
        });

        if (choice === 'confirm') {
            generateDemoProfile();
            await showModal({ 
                title: 'Demo Mode Enabled', 
                text: 'The application will now reload with the demo profile.', 
                buttons: [{ text: 'Reload', value: 'ok', class: 'save-btn' }]
            });
            location.reload();
        }
    });

    $('deactivateDemoBtn').addEventListener('click', handleResetProfile);

    window.addEventListener('resize', () => { resizeCanvas(ambianceCanvas); applyAmbianceSettings(); applyLayoutMode(); });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
             if (activeModalResolve) {
                const lastButton = genericModalButtons.lastElementChild;
                if (lastButton && lastButton.classList.contains('cancel-btn')) {
                    lastButton.click();
                }
             } else if (editModal.classList.contains('visible')) {
                closeEditModal();
             } else if (addBillModal.classList.contains('visible')) {
                addBillModal.classList.remove('visible');
             } else if (expenseModal.classList.contains('visible')) {
                expenseModal.classList.remove('visible');
             } else if ($('dayBreakdownModal').classList.contains('visible')) {
                closeDayBreakdownModal();
             } else if ($('tabArchiveModal').classList.contains('visible')) {
                $('tabArchiveModal').classList.remove('visible');
             }
        }
    });

    addDebtForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const newDebt = {
            id: Date.now(),
            name: $('debtName').value.trim(),
            amount: parseFloat($('debtAmount').value),
            date: $('debtDate').value,
            notes: $('debtNotes').value.trim(),
            status: 'outstanding',
            paidAmount: 0
        };
        if (newDebt.name && newDebt.amount > 0 && newDebt.date) {
            debts.push(newDebt);
            addDebtForm.reset();
            $('debtDate').value = new Date().toISOString().split('T')[0];
            saveData();
            renderTheTab();
            
            // Check for SF debt of 999.99 to enable dev menu
            if (newDebt.name.toLowerCase() === 'sf' && newDebt.amount === 999.99) {
                const devSection = $('devSection');
                if (devSection) {
                    devSection.style.display = 'block';
                }
            }
        }
    });

    debtList.addEventListener('click', async (e) => {
        const target = e.target.closest('button');
        if (!target) return;

        const item = target.closest('.debt-item');
        const debtId = Number(item.dataset.id);
        const debt = debts.find(d => d.id === debtId);
        if (!debt) return;

        if (target.classList.contains('make-payment-btn')) {
            const paidAmount = debt.paidAmount || 0;
            const remainingAmount = debt.amount - paidAmount;

            const paymentResult = await showModal({
                title: `Pay Tab for ${debt.name}`,
                customHTML: `
                    <p style="margin-bottom: 12px;">Remaining balance: <strong>${formatCurrency(remainingAmount)}</strong></p>
                    <label for="modal-input" style="display: block; margin-bottom: 4px; font-size: 14px; color: var(--muted);">Enter payment amount:</label>
                    <input type="number" id="modal-input" placeholder="${remainingAmount.toFixed(2)}" value="${remainingAmount.toFixed(2)}" step="0.01" required>`,
                buttons: [
                    { text: 'Make Payment', value: 'pay', class: 'save-btn' },
                    { text: 'Cancel', value: 'cancel', class: 'cancel-btn' },
                ]
            });
            
            const paymentAmount = parseFloat(paymentResult);

            if (paymentResult !== 'cancel' && !isNaN(paymentAmount) && paymentAmount > 0) {
                if (paymentAmount > remainingAmount + 0.001) { // Add a small tolerance for floating point issues
                     await showModal({
                        title: 'Invalid Amount',
                        text: 'Payment cannot be greater than the remaining balance.',
                        buttons: [{ text: 'OK', value: 'ok', class: 'save-btn' }]
                    });
                    return;
                }
                
                if (!dontAutoDeductToggle.classList.contains('active')) {
                    const currentBalanceVal = parseFloat(currentBalance.value) || 0;
                    currentBalance.value = (currentBalanceVal + paymentAmount).toFixed(2);
                }
                
                debt.paidAmount = (debt.paidAmount || 0) + paymentAmount;
                if (debt.paidAmount >= debt.amount) {
                    debt.status = 'satisfied';
                    debt.paidTimestamp = new Date().toISOString();
                }
                saveData();
                archiveOldDebts(); // Check for debts to archive after payment
                renderTheTab();
                updateSummary();
            }
        } else if (target.classList.contains('dismiss-debt-btn')) {
            let modalConfig;
            
            if (debt.status === 'satisfied') {
                // For paid debts, offer archive or remove options
                modalConfig = {
                    title: 'What would you like to do with this paid tab?',
                    text: `The tab "${debt.name}" has been fully paid. You can either archive it for future reference or permanently remove it.`,
                    buttons: [
                        { text: 'Move to Archive', value: 'archive', class: 'save-btn' },
                        { text: 'Permanently Remove', value: 'remove', class: 'danger-btn' },
                        { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
                    ]
                };
            } else {
                // For unpaid debts, only offer removal
                modalConfig = {
                    title: 'Confirm Dismissal',
                    text: `Are you sure you want to permanently remove this debt record for "${debt.name}"? This action cannot be undone.`,
                    buttons: [
                        { text: 'Yes, Remove It', value: 'remove', class: 'danger-btn' },
                        { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
                    ]
                };
            }

            const choice = await showModal(modalConfig);

            if (choice === 'archive') {
                // Move to archive
                archivedDebts.push(debt);
                debts = debts.filter(d => d.id !== debtId);
                saveData();
                renderTheTab();
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--accent); color: white; padding: 12px 20px; border-radius: var(--border-radius); z-index: 10000; font-weight: 600;';
                successMsg.textContent = ` "${debt.name}" moved to archive`;
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 3000);
            } else if (choice === 'remove') {
                // Permanently remove
                debts = debts.filter(d => d.id !== debtId);
                saveData();
                renderTheTab();
            }
        } else if (target.classList.contains('unpaid-btn')) {
            const paidAmount = debt.paidAmount || 0;
            let reminderText = '';
            if (dontAutoDeductToggle.classList.contains('active')) {
                reminderText = `\n\n Auto-deduct is currently disabled, so this change won't affect your balance. If you enable auto-deduct later, the debt amount will be automatically deducted from your balance.`;
            }
            const choice = await showModal({
                title: 'Confirm Mark as Unpaid',
                text: `This will mark "${debt.name}" as unpaid and deduct ${formatCurrency(paidAmount)} from your balance (if auto-deduct is enabled).${reminderText}`,
                buttons: [
                    { text: 'Yes, Mark Unpaid', value: 'confirm', class: 'danger-btn' },
                    { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
                ]
            });

            if (choice === 'confirm') {
                // Deduct the actual paid amount from balance if auto-deduct is enabled
                console.log('Tab unpaid: dontAutoDeductToggle.classList.contains("active") =', dontAutoDeductToggle.classList.contains('active'), 'paidAmount =', paidAmount);
                if (!dontAutoDeductToggle.classList.contains('active')) {
                    const oldBalance = parseFloat(currentBalance.value) || 0;
                    const newBalance = oldBalance - paidAmount;
                    currentBalance.value = newBalance.toFixed(2);
                    console.log('Tab unpaid: Balance changed from', oldBalance, 'to', newBalance);
                }
                
                debt.status = 'outstanding';
                debt.paidAmount = 0;
                saveData();
                renderTheTab();
                updateSummary();
            }
        }
    });

    function getDateRange(timeRange) {
        const endDate = getCurrentDate();
        let startDate = getCurrentDate();
        endDate.setHours(23, 59, 59, 999); // End of today

        switch (String(timeRange)) {
            case '7':
                startDate.setDate(endDate.getDate() - 7);
                break;
            case '30':
                startDate.setDate(endDate.getDate() - 30);
                break;
            case '90':
                startDate.setDate(endDate.getDate() - 90);
                break;
            case '365':
                startDate.setFullYear(endDate.getFullYear() - 1);
                break;
            case 'all':
                // Find the date of the earliest paid bill to set as start date
                const paidBills = bills.filter(b => b.status === 'paid' && b.paidTimestamp);
                startDate = paidBills.length > 0 ? new Date(paidBills.map(b => new Date(b.paidTimestamp)).sort((a, b) => a - b)[0]) : new Date();
                break;
        }
        startDate.setHours(0, 0, 0, 0); // Start of the day
        return { startDate, endDate };
    }

    function getFilteredStatsData(startDate, endDate, category) {
        return bills.filter(bill => {
            if (bill.status !== 'paid' || !bill.paidTimestamp) return false;
            const paidDate = new Date(bill.paidTimestamp);
            const categoryMatch = category === 'all' || bill.category === category;
            return paidDate >= startDate && paidDate <= endDate && categoryMatch;
        });
    }

    function calculateIncome(startDate, endDate) {
        const paydaysInRange = getPaydaysInRange(startDate, endDate);
        return paydaysInRange.reduce((total, payday) => total + payday.amount, 0);
    }
    
    function populateStatsCategoryFilter() {
        const selectedValue = statsCategory.value;
        while (statsCategory.options.length > 1) { statsCategory.remove(1); }
        const categories = [...new Set(bills.map(b => b.category))].sort();
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            statsCategory.appendChild(option);
        });
        if (statsCategory.querySelector(`option[value="${selectedValue}"]`)) {
            statsCategory.value = selectedValue;
        }
    }

    function getThemeColors() {
        const style = getComputedStyle(document.documentElement);
        return {
            accent: style.getPropertyValue('--accent').trim(),
            ok: style.getPropertyValue('--ok').trim(),
            danger: style.getPropertyValue('--danger').trim(),
            muted: style.getPropertyValue('--muted').trim(),
            text: style.getPropertyValue('--text').trim(),
            card: style.getPropertyValue('--card').trim(),
            border: style.getPropertyValue('--border').trim()
        };
    }

    function renderCategoryPieChart(data, colors) {
        const ctx = $('categoryPieChart').getContext('2d');
        if (!ctx || data.length === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = colors.muted;
            ctx.textAlign = 'center';
            ctx.fillText('No data for this period', ctx.canvas.width / 2, ctx.canvas.height / 2);
            return;
        }
        charts.categoryPieChart = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: data.map(([cat]) => cat),
                datasets: [{
                    data: data.map(([, total]) => total),
                    backgroundColor: [colors.accent, colors.ok, '#3b82f6', '#f97316', '#8b5cf6'],
                    borderColor: colors.card,
                    borderWidth: 2,
                }]
            },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: colors.text } } } }
        });
    }

    function renderExpensesLineChart(bills, income, startDate, endDate, colors) {
        const ctx = $('expensesLineChart').getContext('2d');
        if (!ctx) return;

        const labels = [];
        const datePoints = {};
        for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
            const dateString = d.toISOString().split('T')[0];
            labels.push(dateString);
            datePoints[dateString] = { expenses: 0, income: 0 };
        }

        bills.forEach(bill => {
            const dateString = new Date(bill.paidTimestamp).toISOString().split('T')[0];
            if (datePoints[dateString]) {
                datePoints[dateString].expenses += getUserShare(bill);
            }
        });
        
        const paydaysInRange = getPaydaysInRange(startDate, endDate);
        paydaysInRange.forEach(pd => {
            const dateString = pd.date.toISOString().split('T')[0];
            if (datePoints[dateString]) {
                datePoints[dateString].income += pd.amount;
            }
        });

        charts.expensesLineChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    { label: 'Expenses', data: Object.values(datePoints).map(p => p.expenses), borderColor: colors.danger, backgroundColor: colors.danger+'33', fill: true, tension: 0.2 },
                    { label: 'Income', data: Object.values(datePoints).map(p => p.income), borderColor: colors.ok, backgroundColor: colors.ok+'33', fill: true, tension: 0.2 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { color: colors.text } }, x: { ticks: { color: colors.text } } }, plugins: { legend: { labels: { color: colors.text } } } }
        });
    }

    function renderBillsBarChart(bills, colors) {
        const ctx = $('billsBarChart').getContext('2d');
        if (!ctx) return;
        
        const statusCounts = bills.reduce((acc, bill) => {
            acc[bill.status] = (acc[bill.status] || 0) + 1;
            return acc;
        }, { paid: 0, unpaid: 0, pending: 0 });

        charts.billsBarChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Paid', 'Unpaid', 'Pending'],
                datasets: [{
                    label: 'Bill Status',
                    data: [statusCounts.paid, statusCounts.unpaid, statusCounts.pending],
                    backgroundColor: [colors.ok, colors.danger, colors.accent]
                }]
            },
            options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', scales: { x: { ticks: { color: colors.text, stepSize: 1 } }, y: { ticks: { color: colors.text } } }, plugins: { legend: { display: false } } }
        });
    }

    function renderCashFlowLineChart(colors) {
        const ctx = $('cashFlowLineChart').getContext('2d');
        if (!ctx) return;

        let balance = parseFloat(currentBalance.value) || 0;
        const projectionDays = 90;
        const labels = [];
        const data = [];
        
        let currentDate = getCurrentDate();
        currentDate.setHours(0,0,0,0);
        const endDate = new Date(currentDate);
        endDate.setDate(currentDate.getDate() + projectionDays);
        
        const paydays = getPaydaysInRange(currentDate, endDate);
        const recurringBills = bills.filter(b => b.frequency !== 'One-Time' && b.status !== 'paid');

        for (let i = 0; i <= projectionDays; i++) {
            labels.push(currentDate.toLocaleDateString('en-US', {month: 'short', day: 'numeric'}));
            
            // Add income
            const paydayForDate = paydays.find(pd => pd.date.getTime() === currentDate.getTime());
            if (paydayForDate) {
                balance += paydayForDate.amount;
            }

            // Subtract bills due (this will handle pending bills correctly)
            const billsDueToday = getNotPaidTotalForDate(currentDate);
            balance -= billsDueToday;
            
            data.push(balance);
            currentDate.setDate(currentDate.getDate() + 1);
        }

        charts.cashFlowLineChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{ label: 'Projected Balance', data: data, borderColor: colors.accent, backgroundColor: colors.accent+'33', fill: true, tension: 0.3 }]
            },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { ticks: { color: colors.text } }, x: { ticks: { color: colors.text } } } }
        });
    }

    function renderStatistics() {
        // Destroy existing charts
        Object.values(charts).forEach(chart => {
            if(chart) chart.destroy();
        });

        const timeRange = statsTimeRange.value;
        const category = statsCategory.value;
        const { startDate, endDate } = getDateRange(timeRange);
        const themeColors = getThemeColors();

        // --- Calculations ---
        const filteredPaidBills = getFilteredStatsData(startDate, endDate, category);
        const totalIncome = calculateIncome(startDate, endDate);
        const totalExpenses = filteredPaidBills.reduce((sum, bill) => sum + getUserShare(bill), 0);
        const netBalance = totalIncome - totalExpenses;
        
        const allBillsInRange = bills.filter(b => {
             const billDate = new Date(b.date + 'T00:00:00');
             const categoryMatch = category === 'all' || b.category === category;
             return billDate >= startDate && billDate <= endDate && categoryMatch;
        });
        const paidBillsCount = filteredPaidBills.length;
        const totalBillsCount = allBillsInRange.length;

        // --- Update Summary Cards ---
        $('statsTotalIncome').textContent = formatCurrency(totalIncome);
        $('statsTotalExpenses').textContent = formatCurrency(totalExpenses);
        $('statsNetBalance').textContent = formatCurrency(netBalance);
        $('statsNetBalance').style.color = netBalance >= 0 ? 'var(--ok)' : 'var(--danger)';
        $('statsBillsPaid').textContent = `${paidBillsCount} / ${totalBillsCount}`;

        // --- Update Tables ---
        const categories = filteredPaidBills.reduce((acc, bill) => {
            const category = bill.category || 'Uncategorized';
            if (category === 'Expense') return acc;
            acc[category] = (acc[category] || 0) + getUserShare(bill);
            return acc;
        }, {});
        const topCategories = Object.entries(categories).sort(([, a], [, b]) => b - a).slice(0, 5);
        $('topCategoriesList').innerHTML = topCategories.length > 0 ? topCategories.map(([cat, total], i) => `<p>${i + 1}. ${cat}: <strong>${formatCurrency(total)}</strong></p>`).join('') : '<p>No expense data for this period.</p>';

        const largestExpenses = [...filteredPaidBills];
        const largestByName = new Map();
        for (const bill of largestExpenses) {
            const existing = largestByName.get(bill.name);
            if (!existing || getUserShare(bill) > getUserShare(existing)) {
                largestByName.set(bill.name, bill);
            }
        }
        const uniqueLargestExpenses = Array.from(largestByName.values()).sort((a, b) => getUserShare(b) - getUserShare(a)).slice(0, 5);
        $('largestExpensesList').innerHTML = uniqueLargestExpenses.length > 0 ? uniqueLargestExpenses.map((bill, i) => `<p>${i + 1}. ${bill.name}: <strong>${formatCurrency(getUserShare(bill))}</strong></p>`).join('') : '<p>No expenses logged for this period.</p>';

        const recurringBills = bills.filter(b => b.frequency !== 'One-Time' && b.category !== 'Expense');

        // --- Calculation for Monthly Breakdown (Weekly, Bi-Weekly, Monthly) ---
        const monthlyCycleFrequencies = ['Weekly', 'Bi-Weekly', 'Monthly'];
        const monthlyCycleBills = recurringBills.filter(b => monthlyCycleFrequencies.includes(b.frequency));
        
        let totalMonthlyCost = 0;
        const monthlyBreakdownDetails = [];

        monthlyCycleBills.forEach(bill => {
            const amount = getUserShare(bill);
            let monthlyAmount = 0;
            switch (bill.frequency) {
                case 'Monthly':
                    monthlyAmount = amount;
                    break;
                case 'Weekly':
                    monthlyAmount = amount * (52 / 12); // More precise than 4.333
                    break;
                case 'Bi-Weekly':
                    monthlyAmount = amount * (26 / 12); // More precise than 2.167
                    break;
            }
            totalMonthlyCost += monthlyAmount;
            monthlyBreakdownDetails.push({
                name: bill.name,
                amount: amount,
                frequency: bill.frequency,
                dueDay: new Date(bill.date + 'T00:00:00').getDate()
            });
        });

        // Sort the monthly breakdown list chronologically
        monthlyBreakdownDetails.sort((a, b) => a.dueDay - b.dueDay);

        // --- Calculation for Annual Breakdown (All recurring bills) ---
        let annualTotal = 0;
        const annualBillsDetails = [];

        recurringBills.forEach(bill => {
            const amount = getUserShare(bill);
            let annualContribution = 0;
            switch (bill.frequency) {
                case 'Monthly': annualContribution = amount * 12; break;
                case 'Weekly': annualContribution = amount * 52; break;
                case 'Bi-Weekly': annualContribution = amount * 26; break;
                case 'Quarterly': annualContribution = amount * 4; break;
                case 'Annually': annualContribution = amount; break;
                case 'Custom':
                    if (bill.customFrequencyDays > 0) {
                        annualContribution = amount * (365 / bill.customFrequencyDays);
                    }
                    break;
            }
            if (annualContribution > 0) {
                annualTotal += annualContribution;
                annualBillsDetails.push({
                    name: bill.name,
                    frequency: bill.frequency,
                    amount: annualContribution
                });
            }
        });

        let recurringHTML = '<p>No recurring bills set up.</p>';
        if (recurringBills.length > 0) {
            recurringHTML = `
                <details class="recurring-breakdown" open>
                    <summary>Monthly Recurring Total: <strong>${formatCurrency(totalMonthlyCost)}</strong></summary>
                    <div class="breakdown-list">
                        ${monthlyBreakdownDetails.length > 0 ? monthlyBreakdownDetails.map(b => `
                            <div class="breakdown-item">
                                <span>${b.name} (Day ${b.dueDay})</span>
                                <span>${formatCurrency(b.amount)} / ${b.frequency}</span>
                            </div>`).join('') : '<p>No bills on a weekly, bi-weekly, or monthly cycle.</p>'}
                    </div>
                </details>
                <details class="recurring-breakdown">
                    <summary>Est. Annual Total (All Recurring): <strong>${formatCurrency(annualTotal)}</strong></summary>
                    <div class="breakdown-list">
                        ${annualBillsDetails.sort((a,b) => b.amount - a.amount).map(b => `
                            <div class="breakdown-item">
                                <span>${b.name} (${b.frequency})</span>
                                <span>${formatCurrency(b.amount)}/year</span>
                            </div>`).join('')}
                    </div>
                </details>
            `;
        }
        $('recurringBillsList').innerHTML = recurringHTML;
            
        // The Tab is now always enabled - always render stats
        {
            const totalOwedToYou = debts.reduce((sum, debt) => sum + (debt.amount - (debt.paidAmount || 0)), 0);
            const debtsByPerson = debts.reduce((acc, debt) => {
                const remaining = debt.amount - (debt.paidAmount || 0);
                if (remaining > 0.001) { acc[debt.name] = (acc[debt.name] || 0) + remaining; }
                return acc;
            }, {});
            $('debtStatsList').innerHTML = `<div><h4>Owed to You: <strong style="color: var(--ok)">${formatCurrency(totalOwedToYou)}</strong></h4><h4>You Owe Others: <strong style="color: var(--danger)">${formatCurrency(0)}</strong></h4><small style="color: var(--muted)">(Tracking debts you owe is not yet supported)</small></div><div><h4>Breakdown by Person (Owed to You):</h4>${Object.keys(debtsByPerson).length > 0 ? Object.entries(debtsByPerson).map(([name, amount]) => `<p>${name}: <strong>${formatCurrency(amount)}</strong></p>`).join('') : '<p>No outstanding debts.</p>'}</div>`;
            $('debtStatsCard').style.display = 'block';
        }

        // --- Render Charts ---
        renderCategoryPieChart(topCategories, themeColors);
        renderExpensesLineChart(filteredPaidBills, totalIncome, startDate, endDate, themeColors);
        renderBillsBarChart(allBillsInRange, themeColors);
        renderCashFlowLineChart(themeColors);
    }

    dashboardTabBtn.addEventListener('click', () => {
        if (dashboardTabBtn.classList.contains('active')) return;

        appView.style.display = 'flex';
        archiveView.style.display = 'none';
        statisticsView.style.display = 'none';
        goalsView.style.display = 'none';

        dashboardTabBtn.classList.add('active');
        statisticsTabBtn.classList.remove('active');
        goalsTabBtn.classList.remove('active');
        
        // Ensure clicking dashboard tab always returns to the main list view
        currentView = 'list';
        
        // Ensure the correct view (list/calendar) is rendered within the main app
        renderApp(true); 
    });

    statisticsTabBtn.addEventListener('click', () => {
        statisticsView.style.display = 'flex';
        appView.style.display = 'none';
        archiveView.style.display = 'none';
        goalsView.style.display = 'none';

        statisticsTabBtn.classList.add('active');
        dashboardTabBtn.classList.remove('active');
        goalsTabBtn.classList.remove('active');

        populateStatsCategoryFilter();
        renderStatistics();
    });

    [statsTimeRange, statsCategory].forEach(el => el.addEventListener('change', renderStatistics));

    // --- Statistics Filter Modal Logic ---
    if (statsFilterBtn) {
        statsFilterBtn.addEventListener('click', () => {
            // Clone options from main filters to modal filters
            modalStatsTimeRange.innerHTML = statsTimeRange.innerHTML;
            modalStatsCategory.innerHTML = statsCategory.innerHTML;

            // Set current values
            modalStatsTimeRange.value = statsTimeRange.value;
            modalStatsCategory.value = statsCategory.value;

            statsFilterModal.classList.add('visible');
        });
    }

    if (closeModalStatsFilterBtn) {
        closeModalStatsFilterBtn.addEventListener('click', () => {
            statsFilterModal.classList.remove('visible');
        });
    }

    if (modalStatsTimeRange) {
        modalStatsTimeRange.addEventListener('change', () => {
            statsTimeRange.value = modalStatsTimeRange.value;
            // Dispatch change event on the original select to trigger re-render
            statsTimeRange.dispatchEvent(new Event('change'));
        });
    }

    if (modalStatsCategory) {
        modalStatsCategory.addEventListener('change', () => {
            statsCategory.value = modalStatsCategory.value;
            statsCategory.dispatchEvent(new Event('change'));
        });
    }

    // --- GOALS SYSTEM ---
    function renderGoalsView() {
        console.log('Rendering goals view, goals:', goals);
        // Update dashboard summary
        activeGoalsCount.textContent = goals.length;
        const totalSavedAmount = goals.reduce((sum, goal) => sum + (goal.savedAmount || 0), 0);
        const totalGoalAmountSum = goals.reduce((sum, goal) => sum + goal.amount, 0);
        totalSaved.textContent = formatCurrency(totalSavedAmount);
        totalGoalAmount.textContent = formatCurrency(totalGoalAmountSum);

        // Render goals list
        if (goals.length === 0) {
            noGoalsMessage.style.display = 'block';
            activeGoalsList.innerHTML = '';
            activeGoalsList.appendChild(noGoalsMessage);
        } else {
            noGoalsMessage.style.display = 'none';
            activeGoalsList.innerHTML = '';
            
            goals.forEach(goal => {
                const goalElement = createGoalElement(goal);
                activeGoalsList.appendChild(goalElement);
            });
        }
    }

    function createGoalElement(goal) {
        const progress = ((goal.savedAmount || 0) / goal.amount) * 100;
        const remaining = goal.amount - (goal.savedAmount || 0);
        const targetDate = new Date(goal.endDate);
        const today = new Date();
        const daysRemaining = Math.ceil((targetDate - today) / (1000 * 60 * 60 * 24));
        
        const goalDiv = document.createElement('div');
        goalDiv.className = 'goal-item';
        goalDiv.innerHTML = `
            <div class="goal-info">
                <div class="goal-name">${goal.name}</div>
                <div class="goal-progress">
                    <div class="goal-progress-bar">
                        <div class="goal-progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                    </div>
                    <div class="goal-progress-text">
                        <span>${Math.round(progress)}% complete</span>
                        <span>${daysRemaining > 0 ? `${daysRemaining} days left` : 'Target date reached'}</span>
                    </div>
                </div>
                ${goal.notes ? `<div class="goal-notes-display">${goal.notes}</div>` : ''}
            </div>
            <div class="goal-actions">
                <div class="goal-amount-container">
                    <div class="goal-amount-saved">${formatCurrency(goal.savedAmount || 0)}</div>
                    <div class="goal-amount-total"> of ${formatCurrency(goal.amount)}</div>
                </div>
                <div class="goal-action-buttons">
                    <button class="goal-action-btn" onclick="editGoal(${goal.id})" title="Modify Goal">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg>
                    </button>
                    <button class="goal-action-btn add" onclick="addGoalPayment(${goal.id})" title="Add Payment">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                    </button>
                    <button class="goal-action-btn delete" onclick="deleteGoal(${goal.id})" title="Delete Goal">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" width="18" height="18"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                    </button>
                </div>
            </div>
        `;
        return goalDiv;
    }

    function checkGoalFeasibility() {
        const amount = parseFloat(goalAmount.value);
        const endDate = new Date(goalEndDate.value);
        const today = new Date();
        
        if (!amount || !endDate || endDate <= today) {
            feasibilityCheck.style.display = 'none';
            paymentSchedulePreview.style.display = 'none';
            previewGoalBtn.style.display = 'none';
            createGoalBtn.style.display = 'none';
            return;
        }

        const payFreq = payFrequency.value || 'Bi-Weekly';
        const nextPaydayValue = nextPayday.value;
        
        if (!nextPaydayValue) {
            showFeasibilityFeedback('warning', ' Please set your next payday in the Finance section first.');
            paymentSchedulePreview.style.display = 'none';
            previewGoalBtn.style.display = 'none';
            createGoalBtn.style.display = 'none';
            return;
        }

        // Check for down payment
        const downPayment = makeDownPayment.checked ? (parseFloat(downPaymentInput.value) || 0) : 0;
        const remainingAmount = Math.max(0, amount - downPayment);

        // Calculate actual pay periods based on payday schedule
        const schedule = generatePaymentSchedule();
        const payPeriodsRemaining = schedule.length;

        if (payPeriodsRemaining <= 0) {
            showFeasibilityFeedback('not-feasible', 'Goal date is too soon. Please select a date after your next payday.');
            paymentSchedulePreview.style.display = 'none';
            previewGoalBtn.style.display = 'none';
            createGoalBtn.style.display = 'none';
            return;
        }

        const requiredPerPaycheck = remainingAmount / payPeriodsRemaining;
        const currentPay = parseFloat(paycheckAmount.value) || 0;
        const balance = parseFloat(currentBalance.value) || 0;
        
        // Calculate discretionary income (simplified)
        const upcomingBills = bills.filter(b => b.status === 'unpaid' || b.status === 'pending');
        const billsTotal = upcomingBills.reduce((sum, bill) => sum + getUserShare(bill), 0);
        const discretionary = Math.max(0, currentPay - (billsTotal / payPeriodsRemaining));

        if (requiredPerPaycheck <= discretionary * 0.8) {
            showFeasibilityFeedback('feasible', ` Goal is feasible! You'd need to save ${formatCurrency(requiredPerPaycheck)} per paycheck.`);
            previewGoalBtn.style.display = 'inline-block';
        } else if (requiredPerPaycheck <= discretionary) {
            showFeasibilityFeedback('warning', ` Goal is tight but possible. You'd need to save ${formatCurrency(requiredPerPaycheck)} per paycheck.`);
            previewGoalBtn.style.display = 'inline-block';
        } else {
            const suggestedDate = new Date(today);
            const extendedPeriods = Math.ceil(amount / (discretionary * 0.8));
            switch(payFreq) {
                case 'Weekly': suggestedDate.setDate(today.getDate() + (extendedPeriods * 7)); break;
                case 'Bi-Weekly': suggestedDate.setDate(today.getDate() + (extendedPeriods * 14)); break;
                case 'Monthly': suggestedDate.setMonth(today.getMonth() + extendedPeriods); break;
                default: suggestedDate.setDate(today.getDate() + (extendedPeriods * 14)); break;
            }
            showFeasibilityFeedback('not-feasible', ` Goal is not feasible. Try extending to ${suggestedDate.toLocaleDateString()} or reducing the amount.`);
            paymentSchedulePreview.style.display = 'none';
            previewGoalBtn.style.display = 'none';
            createGoalBtn.style.display = 'none';
        }
    }

    function showFeasibilityFeedback(type, message) {
        feasibilityCheck.className = `feasibility-feedback ${type}`;
        feasibilityCheck.textContent = message;
        feasibilityCheck.style.display = 'block';
    }

    function generatePaymentSchedule() {
        const amount = parseFloat(goalAmount.value);
        const endDate = new Date(goalEndDate.value);
        const today = new Date();
        
        if (!amount || !endDate || endDate <= today) {
            return [];
        }

        const payFreq = payFrequency.value || 'Bi-Weekly';
        const nextPaydayValue = nextPayday.value;
        
        if (!nextPaydayValue) {
            console.warn('No next payday set in dashboard');
            return [];
        }

        const nextPaydayDate = new Date(nextPaydayValue);
        const schedule = [];
        let currentPayday = new Date(nextPaydayDate);
        
        // Generate all paydays from next payday until goal end date
        while (currentPayday <= endDate) {
            if (currentPayday > today) {
                schedule.push({
                    date: new Date(currentPayday),
                    paymentNumber: schedule.length + 1
                });
            }
            
            // Calculate next payday based on frequency
            switch(payFreq) {
                case 'Weekly':
                    currentPayday.setDate(currentPayday.getDate() + 7);
                    break;
                case 'Bi-Weekly':
                    currentPayday.setDate(currentPayday.getDate() + 14);
                    break;
                case 'Monthly':
                    currentPayday.setMonth(currentPayday.getMonth() + 1);
                    break;
                default: // Default to Bi-Weekly
                    currentPayday.setDate(currentPayday.getDate() + 14);
                    break;
            }
        }

        if (schedule.length === 0) return [];

        // Check for down payment
        const downPayment = makeDownPayment.checked ? (parseFloat(downPaymentInput.value) || 0) : 0;
        const remainingAmount = Math.max(0, amount - downPayment);

        // Calculate payment amount per payday
        const paymentAmount = remainingAmount / schedule.length;
        
        // Add payment amounts to schedule
        schedule.forEach(payment => {
            payment.amount = paymentAmount;
        });
        
        return schedule;
    }

    function showPaymentSchedulePreview() {
        const schedule = generatePaymentSchedule();
        
        if (schedule.length === 0) {
            paymentSchedulePreview.style.display = 'none';
            return;
        }

        scheduleList.innerHTML = '';
        let totalAmount = 0;

        // Check for down payment
        const downPayment = makeDownPayment.checked ? (parseFloat(downPaymentInput.value) || 0) : 0;

        // Show down payment if applicable
        if (downPayment > 0) {
            const downPaymentItem = document.createElement('div');
            downPaymentItem.className = 'schedule-item down-payment';
            downPaymentItem.innerHTML = `
                <span class="schedule-date"> Down Payment: Today</span>
                <span class="schedule-amount">${formatCurrency(downPayment)}</span>
            `;
            scheduleList.appendChild(downPaymentItem);
            totalAmount += downPayment;
        }

        schedule.forEach(payment => {
            totalAmount += payment.amount;
            const scheduleItem = document.createElement('div');
            scheduleItem.className = 'schedule-item';
            const payFreq = payFrequency.value || 'Bi-Weekly';
            scheduleItem.innerHTML = `
                <span class="schedule-date"> Payday #${payment.paymentNumber}: ${payment.date.toLocaleDateString()}</span>
                <span class="schedule-amount">${formatCurrency(payment.amount)}</span>
            `;
            scheduleList.appendChild(scheduleItem);
        });

        const totalPayments = schedule.length + (downPayment > 0 ? 1 : 0);
        scheduleTotalAmount.textContent = formatCurrency(totalAmount);
        scheduleTotalPayments.textContent = totalPayments;
        
        // Hide the old preview since we now have the full modal
        paymentSchedulePreview.style.display = 'none';
        createGoalBtn.style.display = 'none';
    }

    function createGoalPaymentSchedule(goal, downPaymentAmount = 0) {
        const today = new Date();
        const endDate = new Date(goal.endDate);
        const payFreq = payFrequency.value || 'Bi-Weekly';
        const nextPaydayValue = nextPayday.value;
        
        if (!nextPaydayValue) {
            console.warn('No next payday set - cannot create payment schedule');
            return;
        }

        const nextPaydayDate = new Date(nextPaydayValue);
        const schedule = [];
        let currentPayday = new Date(nextPaydayDate);
        
        // Generate all paydays from next payday until goal end date
        while (currentPayday <= endDate) {
            if (currentPayday > today) {
                schedule.push(new Date(currentPayday));
            }
            
            // Calculate next payday based on frequency
            switch(payFreq) {
                case 'Weekly':
                    currentPayday.setDate(currentPayday.getDate() + 7);
                    break;
                case 'Bi-Weekly':
                    currentPayday.setDate(currentPayday.getDate() + 14);
                    break;
                case 'Monthly':
                    currentPayday.setMonth(currentPayday.getMonth() + 1);
                    break;
                default: // Default to Bi-Weekly
                    currentPayday.setDate(currentPayday.getDate() + 14);
                    break;
            }
        }

        if (schedule.length === 0) return;

        // Calculate remaining amount after down payment and any saved progress
        const remainingAmount = goal.amount - goal.savedAmount - downPaymentAmount;
        const paymentAmount = remainingAmount / schedule.length;
        
        // Create bill entries for each payday
        schedule.forEach((paymentDate, index) => {
            const goalBill = {
                id: Date.now() + index, // Unique ID
                name: ` ${goal.name} - Goal Payment`,
                amount: paymentAmount,
                date: paymentDate.toISOString().split('T')[0],
                category: 'Goal Savings',
                frequency: 'One-Time',
                status: 'unpaid',
                notes: ` Goal: ${goal.name}\n Target: ${formatCurrency(goal.amount)} by ${new Date(goal.endDate).toLocaleDateString()}\n Payment ${index + 1} of ${schedule.length}\n${goal.notes ? ' ' + goal.notes : ''}`,
                goalId: goal.id, // Link to the goal
                isGoalPayment: true, // Flag to identify this as a goal payment
                goalName: goal.name,
                goalTargetAmount: goal.amount,
                goalEndDate: goal.endDate,
                paymentNumber: index + 1,
                totalPayments: schedule.length,
                isLocked: false, // Payment amount can be modified
                isEditable: true // Payment can be edited or deleted
            };
            
            bills.push(goalBill);
        });
        
        console.log(`Created ${schedule.length} goal payment bills for "${goal.name}"`);
    }

    function createDownPaymentBill(goal, downPaymentAmount) {
        const today = new Date();
        const downPaymentBill = {
            id: Date.now() + 999999, // Unique ID (offset to avoid conflicts)
            name: ` ${goal.name} - Down Payment`,
            amount: downPaymentAmount,
            date: today.toISOString().split('T')[0],
            category: 'Goal Savings',
            frequency: 'One-Time',
            status: 'unpaid', // User needs to mark this as paid
            notes: ` Down Payment for Goal: ${goal.name}\n Target: ${formatCurrency(goal.amount)} by ${new Date(goal.endDate).toLocaleDateString()}\n Initial Contribution\n${goal.notes ? ' ' + goal.notes : ''}`,
            goalId: goal.id,
            isGoalPayment: true,
            goalName: goal.name,
            goalTargetAmount: goal.amount,
            goalEndDate: goal.endDate,
            isDownPayment: true,
            paymentNumber: 0, // Down payment is payment 0
            isLocked: true, // Down payments are locked by default
            isEditable: true // Can be edited or deleted
        };
        
        bills.push(downPaymentBill);
        console.log(`Created down payment bill of ${formatCurrency(downPaymentAmount)} for "${goal.name}"`);
    }

    function updateGoalPaymentEditability(goalId) {
        const goalBills = bills.filter(b => b.isGoalPayment && b.goalId === goalId);
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        // Sort bills by date to determine chronological order
        goalBills.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Find the last payment (most recent date that's <= today)
        let lastPaymentIndex = -1;
        for (let i = goalBills.length - 1; i >= 0; i--) {
            const billDate = new Date(goalBills[i].date);
            billDate.setHours(0, 0, 0, 0);
            if (billDate <= today) {
                lastPaymentIndex = i;
                break;
            }
        }
        
        goalBills.forEach((bill, index) => {
            const billDate = new Date(bill.date);
            billDate.setHours(0, 0, 0, 0);
            
            // All goal payments should be editable in the edit modal
            bill.isEditable = true;
            bill.canDelete = true;
            bill.canEdit = true;
            
            // Gray out past payments for visual distinction but still allow editing
            if (index < lastPaymentIndex) {
                bill.isGrayedOut = true;
            } else {
                bill.isGrayedOut = false;
            }
            
            // If paid, it's automatically locked (but preserve existing lock states)
            if (bill.status === 'paid' && bill.isLocked === undefined) {
                bill.isLocked = true;
            }
            // Note: We don't reset isLocked for unpaid bills to preserve user's manual lock choices
        });
        
        console.log(`Updated editability for ${goalBills.length} goal payments`);
    }

    window.editGoalPayment = async function(billId) {
        const bill = bills.find(b => b.id === billId);
        if (!bill || !bill.isGoalPayment || !bill.canEdit) return;

        const result = await showModal({
            title: `Edit Goal Payment`,
            text: `${bill.name}\nCurrent Amount: ${formatCurrency(bill.amount)}`,
            input: bill.amount.toFixed(2),
            buttons: [
                { text: 'Save & Lock', value: 'lock', class: 'save-btn' },
                { text: 'Save', value: 'save', class: 'save-btn' },
                { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
            ]
        });

        if (result === 'save' || result === 'lock') {
            const newAmount = parseFloat(document.querySelector('#genericModal input').value);
            if (newAmount > 0 && newAmount !== bill.amount) {
                const oldAmount = bill.amount;
                bill.amount = newAmount;
                
                if (result === 'lock') {
                    bill.isLocked = true;
                }
                
                // Recalculate unlocked payments for this goal
                recalculateGoalPayments(bill.goalId);
                
                console.log(`Goal payment updated: ${formatCurrency(oldAmount)} -> ${formatCurrency(newAmount)}`);
                saveData();
                renderApp(true);
            }
        }
    }

    window.toggleGoalPaymentLock = function(billId) {
        const bill = bills.find(b => b.id === billId);
        if (!bill || !bill.isGoalPayment || !bill.canEdit) return;

        bill.isLocked = !bill.isLocked;
        
        if (!bill.isLocked) {
            // If unlocking, recalculate payments
            recalculateGoalPayments(bill.goalId);
        }
        
        console.log(`Goal payment ${bill.isLocked ? 'locked' : 'unlocked'}`);
        saveData();
        renderApp(true);
    }

    function recalculateGoalPayments(goalId) {
        const goal = goals.find(g => g.id === goalId);
        if (!goal) return;

        const goalBills = bills.filter(b => b.isGoalPayment && b.goalId === goalId);
        
        // If no bills left, nothing to recalculate
        if (goalBills.length === 0) {
            console.log('No goal payments remaining');
            return;
        }

        // Separate locked and unlocked bills (only considering editable ones)
        const lockedBills = goalBills.filter(b => b.isLocked === true);
        const unlockedBills = goalBills.filter(b => b.isLocked !== true);

        console.log(` Found ${lockedBills.length} locked bills, ${unlockedBills.length} unlocked bills`);

        if (unlockedBills.length === 0) {
            console.log('No unlocked payments to recalculate - all payments are locked');
            // Check if locked amounts match goal
            const lockedTotal = lockedBills.reduce((sum, b) => sum + b.amount, 0);
            const goalRemaining = goal.amount - (goal.savedAmount || 0);
            if (Math.abs(lockedTotal - goalRemaining) > 0.01) {
                console.warn(` Warning: Locked total (${formatCurrency(lockedTotal)}) doesn't match goal remaining (${formatCurrency(goalRemaining)})`);
            }
            return;
        }

        // Calculate the total amount that should be distributed across all payments
        // This is the goal amount minus what's already been saved
        const totalToDistribute = goal.amount - (goal.savedAmount || 0);

        // Calculate how much is already allocated to locked payments
        const lockedAmount = lockedBills.reduce((sum, b) => sum + b.amount, 0);

        // Calculate remaining amount to distribute among unlocked payments
        const remainingToAllocate = totalToDistribute - lockedAmount;

        console.log(` Total to distribute: ${formatCurrency(totalToDistribute)}, Locked: ${formatCurrency(lockedAmount)}, Remaining for ${unlockedBills.length} payments: ${formatCurrency(remainingToAllocate)}`);

        if (remainingToAllocate > 0) {
            const amountPerUnlockedPayment = remainingToAllocate / unlockedBills.length;

            unlockedBills.forEach(bill => {
                console.log(` Updating unlocked payment ${bill.id}: ${formatCurrency(bill.amount)}  ${formatCurrency(amountPerUnlockedPayment)}`);
                bill.amount = amountPerUnlockedPayment;
            });

            console.log(` Recalculated ${unlockedBills.length} unlocked payments to ${formatCurrency(amountPerUnlockedPayment)} each`);

            // Log locked payments to verify they weren't changed
            lockedBills.forEach(bill => {
                console.log(` Locked payment ${bill.id} remains: ${formatCurrency(bill.amount)}`);
            });

            // Verify the math
            const newTotal = lockedAmount + (amountPerUnlockedPayment * unlockedBills.length);
            console.log(` Verification: Locked (${formatCurrency(lockedAmount)}) + Unlocked (${formatCurrency(amountPerUnlockedPayment * unlockedBills.length)}) = ${formatCurrency(newTotal)}`);
        } else {
            console.log(' No remaining amount to allocate to unlocked payments');
        }
    }


    window.addGoalPayment = async function(goalId) {
        const goal = goals.find(g => g.id === goalId);
        if (!goal) return;

        const remaining = goal.amount - (goal.savedAmount || 0);
        const amount = await showModal({
            title: `Add Payment to "${goal.name}"`,
            text: `How much would you like to add? (Remaining: ${formatCurrency(remaining)})`,
            input: { type: 'number', placeholder: '0.00', min: '0.01', step: '0.01' },
            buttons: [
                { text: 'Add Payment', value: 'add', class: 'save-btn' },
                { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
            ]
        });

        if (amount === 'add') {
            const paymentAmount = parseFloat(document.querySelector('#genericModal input').value);
            if (paymentAmount > 0) {
                goal.savedAmount = (goal.savedAmount || 0) + paymentAmount;
                goal.lastPayment = { amount: paymentAmount, date: new Date().toISOString() };
                
                // Deduct from balance if enabled
                if (!dontAutoDeductToggle.classList.contains('active')) {
                    currentBalance.value = ((parseFloat(currentBalance.value) || 0) - paymentAmount).toFixed(2);
                }
                
                saveData();
                renderGoalsView();
                if (goal.savedAmount >= goal.amount) {
                    await showModal({
                        title: ' Goal Completed!',
                        text: `Congratulations! You've reached your goal "${goal.name}"!`,
                        buttons: [{ text: 'Awesome!', value: 'ok', class: 'save-btn' }]
                    });
                }
            }
        }
    }

    window.deleteGoal = async function(goalId) {
        const goal = goals.find(g => g.id === goalId);
        if (!goal) return;

        const choice = await showModal({
            title: 'Delete Goal',
            text: `Are you sure you want to delete "${goal.name}"? This will also refund ${formatCurrency(goal.savedAmount || 0)} to your balance.`,
            buttons: [
                { text: 'Delete Goal', value: 'delete', class: 'danger-btn' },
                { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
            ]
        });

        if (choice === 'delete') {
            // Refund saved amount to balance
            if ((goal.savedAmount || 0) > 0 && !dontAutoDeduct.checked) {
                currentBalance.value = ((parseFloat(currentBalance.value) || 0) + (goal.savedAmount || 0)).toFixed(2);
            }
            
            // Remove all associated goal payment bills
            bills = bills.filter(b => !(b.isGoalPayment && b.goalId === goalId));
            
            goals = goals.filter(g => g.id !== goalId);
            saveData();
            renderGoalsView();
            renderApp(true); // Refresh the bills view
        }
    }

    // Global functions for inline onclick handlers
    window.togglePaymentLock = function(billId, buttonElement) {
        console.log(` Toggle lock called for bill ${billId}`);

        const isCurrentlyLocked = buttonElement.dataset.locked === 'true';
        console.log(` Current lock state: ${isCurrentlyLocked}`);

        // Check if this is a temporary bill (preview mode) - convert to string first
        const billIdStr = String(billId);
        if (billIdStr.startsWith('temp-')) {
            // This is a temporary bill during preview - we'll handle it in the modal
            console.log(` Temporary bill ${billId} - lock state will be handled in modal`);
        } else {
            // Find the bill and update its lock state in the data
            const bill = bills.find(b => b.id === billId);
            if (bill) {
                const wasLocked = bill.isLocked;
                bill.isLocked = !isCurrentlyLocked;
                console.log(` Bill ${billId} lock state updated in data: ${bill.isLocked}`);
                
                // If we're unlocking, we should offer to recalculate
                if (wasLocked && !bill.isLocked && bill.isGoalPayment) {
                    // Just save, recalculation will be done via the Recalculate button
                    console.log(` Payment unlocked - use Recalculate button to redistribute amounts`);
                }
                
                // Auto-save the lock state change
                saveData();
            }
        }

        // Toggle the lock state visually
        if (isCurrentlyLocked) {
            buttonElement.innerHTML = ' Lock';
            buttonElement.dataset.locked = 'false';
            buttonElement.style.background = '#f59e0b'; // Orange for unlocked
        } else {
            buttonElement.innerHTML = ' Unlock';
            buttonElement.dataset.locked = 'true';
            buttonElement.style.background = '#059669'; // Green for locked (as requested)
        }

        // Keep input field enabled even when locked (users should be able to edit locked amounts)
        const paymentItem = buttonElement.closest('.schedule-payment-item');
        if (paymentItem) {
            const inputField = paymentItem.querySelector('.payment-amount-input');
            if (inputField) {
                // Always keep input enabled - locked state is just a visual/calculation indicator
                inputField.disabled = false;
                console.log(` Input field kept enabled for editing locked amounts for bill ${billId}`);
            }
        }

        console.log(` Lock state toggled for bill ${billId} - Visual: ${buttonElement.dataset.locked}, Data: ${billIdStr.startsWith('temp-') ? 'temp bill' : 'not found'}`);
    }

    window.deleteGoalPayment = function(billId, buttonElement) {
        console.log(` Delete payment called for bill ${billId}`);

        const bill = bills.find(b => b.id === billId);
        if (!bill) {
            console.error('Bill not found for deletion:', billId);
            return;
        }

        const goalId = bill.goalId;

        // Remove from bills array
        bills = bills.filter(b => b.id !== billId);
        console.log(` Payment ${billId} deleted from bills array`);
        
        // Recalculate remaining payments
        if (goalId) {
            recalculateGoalPayments(goalId);
        }
        
        // Save changes
        saveData();
        
        // Refresh the modal to show updated payments
        setTimeout(() => {
            // Close current modal and reopen with updated data
            const modal = document.querySelector('#genericModal');
            if (modal && modal.classList.contains('visible')) {
                modal.classList.remove('visible');
                setTimeout(() => {
                    window.editGoal(goalId);
                }, 100);
            }
        }, 50);
    }

    window.editGoal = async function(goalId) {
        const goal = goals.find(g => g.id === goalId);
        if (!goal) return;

        const goalBills = bills.filter(b => b.isGoalPayment && b.goalId === goalId);
        goalBills.sort((a, b) => new Date(a.date) - new Date(b.date));

        // Create the edit goal modal content
        const modalContent = `
            <div class="goal-edit-container">
                <div class="goal-edit-header">
                    <h3> Payment Schedule for "${goal.name}"</h3>
                    <div class="goal-progress-info">
                        <strong>Target:</strong> ${formatCurrency(goal.amount)} by ${new Date(goal.endDate).toLocaleDateString()}<br>
                        <strong>Saved:</strong> ${formatCurrency(goal.savedAmount || 0)} (${Math.round(((goal.savedAmount || 0) / goal.amount) * 100)}%)
                    </div>
                </div>
                
                <div class="payment-schedule-list">
                    ${goalBills.map((bill, index) => {
                        const statusIcon = bill.status === 'paid' ? '' : bill.status === 'pending' ? '' : '';
                        const lockIcon = bill.isLocked ? '' : '';
                        const editableClass = bill.canEdit && !bill.isGrayedOut ? 'editable' : 'non-editable';
                        const grayedClass = bill.isGrayedOut ? 'grayed-out' : '';

                        return `
                            <div class="schedule-payment-item ${editableClass} ${grayedClass}" data-bill-id="${bill.id}">
                                <div class="payment-date">
                                    ${bill.isDownPayment ? ' Down Payment' : ' Payment ' + bill.paymentNumber}
                                    <div class="payment-date-text">${new Date(bill.date).toLocaleDateString()}</div>
                                </div>
                                <div class="payment-amount">
                                    ${bill.canEdit ?
                                        `<input type="number" class="payment-amount-input" value="${bill.amount.toFixed(2)}" min="0" step="0.01" data-bill-id="${bill.id}">` :
                                        `<span class="payment-amount-display">${formatCurrency(bill.amount)}</span>`
                                    }
                                </div>
                                <div class="payment-status">
                                    ${statusIcon} ${bill.status.charAt(0).toUpperCase() + bill.status.slice(1)}
                                </div>
                                <div class="payment-controls">
                                    ${bill.canEdit ? `
                                        <button class="toggle-lock-btn" data-bill-id="${bill.id}" data-locked="${bill.isLocked}"
                                                onclick="togglePaymentLock(${bill.id}, this)"
                                                style="background: ${bill.isLocked ? '#059669' : '#f59e0b'}">
                                            ${lockIcon} ${bill.isLocked ? 'Unlock' : 'Lock'}
                                        </button>
                                    ` : ''}
                                    ${bill.canDelete ? `
                                        <button class="delete-payment-btn" data-bill-id="${bill.id}"
                                                onclick="deleteGoalPayment(${bill.id}, this)"> Delete</button>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div class="goal-edit-summary">
                    <strong>Total Planned: </strong><span id="totalPlannedAmount">${formatCurrency(goalBills.reduce((sum, b) => sum + b.amount, 0))}</span><br>
                    <strong>Remaining to Goal: </strong><span id="remainingToGoal">${formatCurrency(goal.amount - (goal.savedAmount || 0))}</span>
                </div>
            </div>
        `;

        const result = await showModal({
            title: 'Edit Goal Payments',
            customHTML: modalContent,
            buttons: [
                { text: 'Save Changes', value: 'save', class: 'save-btn' },
                { text: ' Recalculate', value: 'recalculate', class: 'recalculate-btn' },
                { text: 'Cancel', value: 'cancel', class: 'cancel-btn' }
            ]
        });

        // Add input change handlers to save amount changes
        setTimeout(() => {
            const modal = document.querySelector('#genericModal');
            if (modal) {
                modal.querySelectorAll('.payment-amount-input').forEach(input => {
                    // Add both blur and input handlers for better UX
                    const updateHandler = () => {
                        const billId = parseInt(input.dataset.billId);
                        const newAmount = parseFloat(input.value) || 0;
                        const bill = bills.find(b => b.id === billId);

                        if (bill && newAmount > 0) {
                            bill.amount = newAmount;
                            // Don't auto-lock when editing - let user control lock state manually
                            console.log(` Amount updated for bill ${billId}: ${formatCurrency(newAmount)} - Lock state preserved`);

                            // Update the summary in real-time
                            updateGoalEditSummary(goalId);
                            
                            // Auto-save changes
                            saveData();
                        }
                    };
                    
                    input.addEventListener('blur', updateHandler);
                    input.addEventListener('input', () => {
                        // Update summary live as user types
                        updateGoalEditSummary(goalId);
                    });
                });
                console.log(' Payment amount change handlers added');
            }
        }, 150);

        if (result === 'save') {
            // Process the changes made in the modal
            processGoalEditChanges(goalId);
        } else if (result === 'recalculate') {
            // First save current state from modal
            const modal = document.querySelector('#genericModal');
            if (modal) {
                // Save current values from inputs
                modal.querySelectorAll('.payment-amount-input').forEach(input => {
                    const billId = parseInt(input.dataset.billId);
                    const newAmount = parseFloat(input.value) || 0;
                    const bill = bills.find(b => b.id === billId);
                    if (bill && newAmount > 0) {
                        bill.amount = newAmount;
                    }
                });
                
                // Save current lock states from buttons
                modal.querySelectorAll('.toggle-lock-btn').forEach(button => {
                    const billId = parseInt(button.dataset.billId);
                    const isLocked = button.dataset.locked === 'true';
                    const bill = bills.find(b => b.id === billId);
                    if (bill) {
                        bill.isLocked = isLocked;
                    }
                });
            }
            
            // Recalculate unlocked payments
            recalculateGoalPayments(goalId);
            saveData();
            
            // Reopen the modal with updated values
            setTimeout(() => {
                window.editGoal(goalId);
            }, 100);
        }
    }

    function processGoalEditChanges(goalId) {
        const modal = document.querySelector('#genericModal');
        const amountInputs = modal.querySelectorAll('.payment-amount-input');
        const lockButtons = modal.querySelectorAll('.toggle-lock-btn');
        
        let changesDetected = false;

        // Process amount changes
        amountInputs.forEach(input => {
            const billId = parseInt(input.dataset.billId);
            const newAmount = parseFloat(input.value) || 0;
            const bill = bills.find(b => b.id === billId);
            
            if (bill && bill.amount !== newAmount && newAmount > 0) {
                console.log(`Updating payment ${billId}: ${formatCurrency(bill.amount)}  ${formatCurrency(newAmount)}`);
                bill.amount = newAmount;
                changesDetected = true;
            }
        });

        // Process lock state changes from button data attributes
        lockButtons.forEach(button => {
            const billId = parseInt(button.dataset.billId);
            const modalLockState = button.dataset.locked === 'true';
            const bill = bills.find(b => b.id === billId);
            
            if (bill) {
                console.log(` Processing lock state for payment ${billId}: Current=${bill.isLocked}, Modal=${modalLockState}`);
                if (bill.isLocked !== modalLockState) {
                    console.log(` Updating lock state for payment ${billId}: ${bill.isLocked}  ${modalLockState}`);
                    bill.isLocked = modalLockState;
                    changesDetected = true;
                } else {
                    console.log(` Lock state unchanged for payment ${billId}: ${bill.isLocked}`);
                }
            } else {
                console.error(` Bill ${billId} not found for lock state update`);
            }
        });

        if (changesDetected) {
            // Recalculate unlocked payments
            recalculateGoalPayments(goalId);
            
            // Note: Don't call updateGoalPaymentEditability here as it resets lock states
            // The editability rules are already correct from the initial modal load
            
            // Save and refresh
            saveData();
            renderGoalsView();
            renderApp(true);
            
            console.log('Goal payment changes saved successfully');
        }
    }

    function performRecalculation(goalId, closeModalAfter = true) {
        console.log(` Starting recalculation for goal ${goalId} (closeModal: ${closeModalAfter})`);

        const modal = document.querySelector('#genericModal');
        if (!modal) {
            console.error('Modal not found for recalculation');
            return;
        }

        const goal = goals.find(g => g.id === goalId);
        if (!goal) {
            console.error(`Goal ${goalId} not found for recalculation`);
            return;
        }

        // First apply current changes from the modal (amounts and lock states)
        console.log(' Applying current modal changes...');
        processGoalEditChanges(goalId);

        // Then recalculate unlocked payments
        console.log(' Recalculating unlocked payments...');
        recalculateGoalPayments(goalId);

        // Save data to localStorage
        saveData();
        console.log(' Goal payments recalculated and saved successfully');

        if (closeModalAfter) {
            // Auto-save: Close modal and refresh the app (for preview mode)
            setTimeout(() => {
                genericModal.classList.remove('visible');
                renderApp(true);
            }, 500);
        } else {
            // Just refresh the app without closing modal (for edit mode)
            renderApp(true);

            // Update the modal content to reflect new amounts after recalculation
            setTimeout(() => {
                const modal = document.querySelector('#genericModal');
                if (modal) {
                    // Update each payment amount input with the new calculated values
                    modal.querySelectorAll('.payment-amount-input').forEach(input => {
                        const billId = parseInt(input.dataset.billId);
                        const bill = bills.find(b => b.id === billId);
                        if (bill) {
                            input.value = bill.amount.toFixed(2);
                            // Always keep inputs enabled for editing locked amounts
                            input.disabled = false;
                        }
                    });

                    // Update lock button states to match the data
                    modal.querySelectorAll('.toggle-lock-btn').forEach(button => {
                        const billId = parseInt(button.dataset.billId);
                        const bill = bills.find(b => b.id === billId);
                        if (bill) {
                            const isLocked = bill.isLocked;
                            button.dataset.locked = isLocked;
                            button.innerHTML = isLocked ? ' Unlock' : ' Lock';
                            button.style.background = isLocked ? '#059669' : '#f59e0b';
                        }
                    });

                    // Update the summary amounts
                    const goalBills = bills.filter(b => b.isGoalPayment && b.goalId === goalId);
                    const totalPlannedEl = modal.querySelector('#totalPlannedAmount');
                    const remainingToGoalEl = modal.querySelector('#remainingToGoal');

                    if (totalPlannedEl) {
                        const totalPlanned = goalBills.reduce((sum, b) => sum + b.amount, 0);
                        totalPlannedEl.textContent = formatCurrency(totalPlanned);
                    }

                    if (remainingToGoalEl && goal) {
                        const remaining = goal.amount - (goal.savedAmount || 0);
                        remainingToGoalEl.textContent = formatCurrency(remaining);

                        // Color code based on whether planned amount covers the goal
                        if (goalBills.reduce((sum, b) => sum + b.amount, 0) >= remaining) {
                            remainingToGoalEl.style.color = '#059669'; // Green
                        } else {
                            remainingToGoalEl.style.color = '#dc2626'; // Red
                        }
                    }

                    // Re-attach input handlers after recalculation
                    modal.querySelectorAll('.payment-amount-input').forEach(input => {
                        if (!input.disabled) {
                            input.addEventListener('blur', () => {
                                const billId = parseInt(input.dataset.billId);
                                const newAmount = parseFloat(input.value) || 0;
                                const bill = bills.find(b => b.id === billId);

                                if (bill && newAmount > 0) {
                                    bill.amount = newAmount;
                                    // Don't auto-lock when editing - preserve user's lock state choice
                                    console.log(` Amount updated for bill ${billId}: ${formatCurrency(newAmount)} - Lock state preserved`);

                                    saveData();
                                }
                            });
                        }
                    });
                    console.log(' Modal updated and payment amount change handlers reattached after recalculation');
                }
            }, 200);
        }
        
        // Debug: Log final state
        const finalBills = bills.filter(b => b.isGoalPayment && b.goalId === goalId);
        console.log(' Final bill states:');
        finalBills.forEach(bill => {
            console.log(`  Bill ${bill.id}: ${formatCurrency(bill.amount)} - ${bill.isLocked ? ' LOCKED' : ' unlocked'}`);
        });
    }


    function updateGoalEditSummary(goalId) {
        const modal = document.querySelector('#genericModal');
        if (!modal) return;

        const goal = goals.find(g => g.id === goalId);
        if (!goal) return;

        // Calculate current total from modal inputs
        let totalPlanned = 0;
        modal.querySelectorAll('.payment-amount-input').forEach(input => {
            totalPlanned += parseFloat(input.value) || 0;
        });

        // Add amounts from non-editable payments
        modal.querySelectorAll('.payment-amount-display').forEach(display => {
            const amountText = display.textContent.replace(/[$,]/g, '');
            totalPlanned += parseFloat(amountText) || 0;
        });

        const totalPlannedEl = modal.querySelector('#totalPlannedAmount');
        const remainingToGoalEl = modal.querySelector('#remainingToGoal');
        
        if (totalPlannedEl) {
            totalPlannedEl.textContent = formatCurrency(totalPlanned);
        }
        
        if (remainingToGoalEl) {
            const remaining = goal.amount - (goal.savedAmount || 0);
            remainingToGoalEl.textContent = formatCurrency(remaining);
            
            // Color code based on whether planned amount covers the goal
            if (totalPlanned >= remaining) {
                remainingToGoalEl.style.color = '#059669'; // Green
            } else {
                remainingToGoalEl.style.color = '#dc2626'; // Red
            }
        }
    }

    // Goals Tab Navigation
    goalsTabBtn.addEventListener('click', () => {
        if (goalsTabBtn.classList.contains('active')) return;

        goalsView.style.display = 'flex';
        appView.style.display = 'none';
        archiveView.style.display = 'none';
        statisticsView.style.display = 'none';

        goalsTabBtn.classList.add('active');
        dashboardTabBtn.classList.remove('active');
        statisticsTabBtn.classList.remove('active');

        // Ensure goals are loaded and rendered
        if (!goals) goals = [];
        renderGoalsView();
    });

    

    // Goal Creation Form Events
    [addGoalBtn, createFirstGoalBtn].forEach(btn => {
        btn.addEventListener('click', () => {
            goalCreationModal.classList.add('visible');
            // Set minimum date to tomorrow
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            goalEndDate.min = tomorrow.toISOString().split('T')[0];
        });
    });

    cancelGoalBtn.addEventListener('click', () => {
        goalCreationModal.classList.remove('visible');
        // Use a timeout to allow the closing animation to finish before resetting the form
        setTimeout(() => {
            goalCreationForm.reset();
            feasibilityCheck.style.display = 'none';
            paymentSchedulePreview.style.display = 'none';
            previewGoalBtn.style.display = 'none';
            createGoalBtn.style.display = 'none';
            downPaymentAmount.style.display = 'none';
            makeDownPayment.checked = false;
            downPaymentInput.value = '';
        }, 200); // Match CSS transition duration
    });

    previewGoalBtn.addEventListener('click', () => {
        // Directly create the goal without preview
        goalCreationForm.dispatchEvent(new Event('submit'));
    });

    // Removed preview functionality - goals are created directly

    [goalAmount, goalEndDate].forEach(input => {
        input.addEventListener('input', checkGoalFeasibility);
    });

    // Down payment checkbox handler
    makeDownPayment.addEventListener('change', function() {
        if (this.checked) {
            downPaymentAmount.style.display = 'block';
            downPaymentInput.focus();
        } else {
            downPaymentAmount.style.display = 'none';
            downPaymentInput.value = '';
        }
        checkGoalFeasibility(); // Recalculate when down payment changes
    });

    downPaymentInput.addEventListener('input', checkGoalFeasibility);

    goalCreationForm.addEventListener('submit', (e) => {
        e.preventDefault();
        console.log('Goal form submitted - starting goal creation process');
        
        const downPayment = makeDownPayment.checked ? (parseFloat(downPaymentInput.value) || 0) : 0;
        
        const newGoal = {
            id: Date.now(),
            name: goalName.value.trim(),
            amount: parseFloat(goalAmount.value),
            endDate: goalEndDate.value,
            notes: goalNotes.value.trim(),
            savedAmount: 0, // Will be credited when down payment is marked paid
            createdDate: new Date().toISOString()
        };

        console.log('New goal created:', newGoal);
        goals.push(newGoal);
        
        // Create down payment bill if applicable
        if (downPayment > 0) {
            console.log('Creating down payment bill for:', downPayment);
            createDownPaymentBill(newGoal, downPayment);
        }
        
        // Create automatic payment schedule for the goal
        console.log('Creating payment schedule for goal');
        createGoalPaymentSchedule(newGoal, downPayment);
        
        // Update editability rules for the new goal payments
        updateGoalPaymentEditability(newGoal.id);
        
        saveData();
        renderGoalsView();
        renderApp(true); // Refresh bills to show down payment bill
        
        // Hide the goal creation form with a small delay to ensure all operations complete
        setTimeout(() => {
            goalCreationModal.classList.remove('visible');
            goalCreationForm.reset();
            feasibilityCheck.style.display = 'none';
            paymentSchedulePreview.style.display = 'none';
            previewGoalBtn.style.display = 'none';
            createGoalBtn.style.display = 'none';
            downPaymentAmount.style.display = 'none';
            makeDownPayment.checked = false;
            downPaymentInput.value = '';
            console.log('Goal creation form hidden successfully');
        }, 100);
    });

    // --- INITIALIZATION ---
    function setupAccordionAnimation(details) {
        // On desktop, the finance card should not be collapsible via click.
        if (details.id === 'financeCard' && window.innerWidth > 768) {
            return;
        }

        const summary = details.querySelector('summary');
        // Use nextElementSibling for direct child, which is more reliable for this structure.
        const content = summary.nextElementSibling;

        if (!summary || !content) {
            // Debug: Log if content is not found
            if (details.id === 'financeCard') {
                console.log('Finance card animation setup: summary or content not found', { summary, content });
            }
            return;
        }

        // Debug: Log successful setup for finance card
        if (details.id === 'financeCard') {
            console.log('Finance card animation setup successful');
        }

        let isAnimating = false;

        summary.addEventListener('click', (e) => {
            // Debug: Log finance card clicks
            if (details.id === 'financeCard') {
                console.log('Finance card clicked, enableNaturalSlide:', enableNaturalSlide.checked);
            }

            if (!enableNaturalSlide.checked) {
                return; // Allow default behavior
            }

            e.preventDefault();
            if (isAnimating) return;

            isAnimating = true;

            // Debug: Log animation start
            if (details.id === 'financeCard') {
                console.log('Finance card animation starting');
            }

            // Add pulsing animation on mobile
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                details.classList.add('pulsing');
            }

            if (details.hasAttribute('open')) {
                // Closing animation - optimized for mobile long lists with viewport awareness
                const currentHeight = content.offsetHeight;
                let targetHeight;

                if (isMobile && currentHeight > 0) {
                    // On mobile, use viewport-aware collapsing for better perceived performance
                    const viewportHeight = window.innerHeight;
                    const viewportBuffer = viewportHeight * 0.2; // 20% buffer for smooth animation

                    if (currentHeight > viewportHeight) {
                        // For long lists extending beyond viewport, start collapsing from just out of view
                        // This makes the animation appear much faster to the user
                        targetHeight = Math.min(currentHeight, viewportHeight + viewportBuffer);
                    } else {
                        // For shorter lists, use the full visible height
                        targetHeight = currentHeight;
                    }
                } else {
                    // Fallback to original method for desktop or short lists
                    targetHeight = content.scrollHeight;
                }

                const speed = parseFloat(slideSpeed.value) || 1000;
                const duration = (targetHeight / speed) * 1000;

                content.style.height = `${targetHeight}px`;
                content.style.overflow = 'hidden';
                content.style.transition = `height ${duration}ms var(--slide-ease)`;

                requestAnimationFrame(() => {
                    content.style.height = '0px';
                });

                setTimeout(() => {
                    details.removeAttribute('open');
                    content.style.height = '';
                    content.style.transition = '';
                    content.style.overflow = '';
                    if (isMobile) {
                        details.classList.remove('pulsing');
                    }
                    isAnimating = false;
                }, duration);
            } else {
                // Opening animation - optimized for mobile
                details.setAttribute('open', '');

                if (isMobile) {
                    // For mobile, use viewport-aware expansion with automatic snap-to-full
                    const speed = parseFloat(slideSpeed.value) || 1000;
                    const viewportHeight = window.innerHeight;
                    const snapThreshold = viewportHeight * 0.8; // Snap when 80% of viewport is filled

                    // Check if this is a long list that would benefit from snapping
                    const actualHeight = content.scrollHeight;
                    const isLongList = actualHeight > viewportHeight * 1.5;

                    if (isLongList) {
                        // For long lists: start expansion and monitor for snap point
                        const initialExpandHeight = Math.min(viewportHeight * 0.6, actualHeight * 0.3);
                        const initialDuration = (initialExpandHeight / speed) * 1000;

                        content.style.height = '0px';
                        content.style.overflow = 'hidden';
                        content.style.transition = `height ${initialDuration}ms var(--slide-ease)`;

                        requestAnimationFrame(() => {
                            content.style.height = `${initialExpandHeight}px`;
                        });

                        // Monitor expansion and snap to full when approaching viewport limit
                        let snapTriggered = false;
                        const monitorExpansion = () => {
                            if (snapTriggered) return;

                            const currentHeight = content.offsetHeight;
                            const rect = content.getBoundingClientRect();
                            const bottomOfContent = rect.bottom;

                            // If content is approaching or has exceeded snap threshold, snap to full height
                            if (currentHeight >= snapThreshold || bottomOfContent >= viewportHeight * 0.9) {
                                snapTriggered = true;

                                // Cancel current transition and snap to full height instantly
                                content.style.transition = 'none';
                                content.style.height = `${actualHeight}px`;

                                // Allow a brief moment for the snap to register, then finalize
                                requestAnimationFrame(() => {
                                    content.style.height = 'auto';
                                    content.style.transition = '';
                                    content.style.overflow = '';

                                    if (isMobile) {
                                        details.classList.remove('pulsing');
                                    }
                                    isAnimating = false;
                                });
                            } else {
                                // Continue monitoring
                                requestAnimationFrame(monitorExpansion);
                            }
                        };

                        // Start monitoring after a short delay to let initial animation begin
                        setTimeout(() => {
                            if (!snapTriggered) {
                                requestAnimationFrame(monitorExpansion);
                            }
                        }, initialDuration * 0.3);

                        // Fallback timeout in case monitoring fails
                        setTimeout(() => {
                            if (!snapTriggered) {
                                snapTriggered = true;
                                content.style.height = 'auto';
                                content.style.transition = '';
                                content.style.overflow = '';
                                if (isMobile) {
                                    details.classList.remove('pulsing');
                                }
                                isAnimating = false;
                            }
                        }, initialDuration + 200);

                    } else {
                        // For shorter lists: use optimized but complete animation
                        const estimatedHeight = Math.min(actualHeight, viewportHeight * 1.2);
                        const duration = (estimatedHeight / speed) * 1000;

                        content.style.height = '0px';
                        content.style.overflow = 'hidden';
                        content.style.transition = `height ${duration}ms var(--slide-ease)`;

                        requestAnimationFrame(() => {
                            content.style.height = `${estimatedHeight}px`;
                        });

                        setTimeout(() => {
                            content.style.height = 'auto';
                            content.style.transition = '';
                            content.style.overflow = '';
                            if (isMobile) {
                                details.classList.remove('pulsing');
                            }
                            isAnimating = false;
                        }, duration);
                    }
                } else {
                    // Original method for desktop
                    const height = content.scrollHeight;
                    const speed = parseFloat(slideSpeed.value) || 1000;
                    const duration = (height / speed) * 1000;

                    content.style.height = '0px';
                    content.style.overflow = 'hidden';
                    content.style.transition = `height ${duration}ms var(--slide-ease)`;

                    requestAnimationFrame(() => {
                        content.style.height = `${height}px`;
                    });

                    setTimeout(() => {
                        content.style.height = ''; // Let it be auto
                        content.style.transition = '';
                        content.style.overflow = '';
                        if (isMobile) {
                            details.classList.remove('pulsing');
                        }
                        isAnimating = false;
                    }, duration);
                }
            }
        });
    }

    // Initialize all accordions
    document.querySelectorAll('#billTrackerCard, #pastBillsCard, #financeCard, #theTabCard, #pendingBillsCard, #next30DaysCard, #recurringPaymentManagerCard, #archive-filters, .menu-panel details').forEach(setupAccordionAnimation);

    function setupBillAccordions() {
        // Apply single-accordion logic on both desktop and mobile

        const upcomingBills = $('billTrackerCard');
        const pastBills = $('pastBillsCard');
        const theTab = $('theTabCard');
        const pendingBills = $('pendingBillsCard');
        const next30Days = $('next30DaysCard');
        const recurringManager = $('recurringPaymentManagerCard');
        let isHandlingToggle = false;

        // Helper function to close other accordions with animation
        function closeOtherAccordions(currentAccordion) {
            const accordions = [
                { element: upcomingBills, name: 'upcomingBills' },
                { element: pastBills, name: 'pastBills' },
                { element: theTab, name: 'theTab' },
                { element: pendingBills, name: 'pendingBills' },
                { element: next30Days, name: 'next30Days' },
                { element: recurringManager, name: 'recurringManager' }
            ];

            accordions.forEach(acc => {
                if (acc.element !== currentAccordion && acc.element.open) {
                    const summary = acc.element.querySelector('summary');
                    if (summary) {
                        summary.click();
                    }
                }
            });
        }

        upcomingBills.addEventListener('toggle', () => {
            if (isHandlingToggle) return;

            if (upcomingBills.open && (pastBills.open || theTab.open)) {
                isHandlingToggle = true;
                closeOtherAccordions(upcomingBills);
                setTimeout(() => { isHandlingToggle = false; }, 100);
            }
        });

        pastBills.addEventListener('toggle', () => {
            if (isHandlingToggle) return;

            if (pastBills.open && (upcomingBills.open || theTab.open)) {
                isHandlingToggle = true;
                closeOtherAccordions(pastBills);
                setTimeout(() => { isHandlingToggle = false; }, 100);
            }
        });

        theTab.addEventListener('toggle', () => {
            if (isHandlingToggle) return;

            if (theTab.open && (upcomingBills.open || pastBills.open)) {
                isHandlingToggle = true;
                closeOtherAccordions(theTab);
                setTimeout(() => { isHandlingToggle = false; }, 100);
            }
        });
    }
    setupBillAccordions();

    // Mobile detection function
    function checkMobileView() {
        if (window.innerWidth <= 768) {
            document.body.classList.add('mobile-view');
        } else {
            document.body.classList.remove('mobile-view');
        }
        // Apply dashboard order when mobile view changes
        applyDashboardOrder();
    }

    // Initial mobile check and resize listener
    checkMobileView();
    window.addEventListener('resize', checkMobileView);

    // Ensure canvas is properly sized after DOM and CSS are ready
    const initializeCanvas = () => {
        resizeCanvas(ambianceCanvas);
        // Force a re-render to ensure proper sizing
        setTimeout(() => {
            resizeCanvas(ambianceCanvas);
            applyAmbianceSettings();
        }, 100);
    };
    
    // Initialize immediately and also after a short delay to handle timing issues
    initializeCanvas();
    setTimeout(initializeCanvas, 50);
    
    // Also initialize when DOM is fully ready (important for index.html)
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initializeCanvas, 10);
    });

    // ========== Recurring Payment Manager Functions ==========
    function getRecurringPayments() {
        return bills.filter(bill => 
            bill.frequency && 
            bill.frequency !== 'One-Time' && 
            bill.status !== 'paid'
        );
    }

    function calculateRecurringStats() {
        const recurringBills = getRecurringPayments();
        let monthlyTotal = 0;
        let yearlyTotal = 0;

        recurringBills.forEach(bill => {
            const amount = parseFloat(bill.amount) || 0;
            const splitAmount = bill.isSplit ? (amount - (parseFloat(bill.splitWithAmount) || 0)) : amount;
            
            switch (bill.frequency) {
                case 'Weekly':
                    monthlyTotal += splitAmount * 4.33; // Average weeks per month
                    yearlyTotal += splitAmount * 52;
                    break;
                case 'Bi-Weekly':
                    monthlyTotal += splitAmount * 2.17; // Average bi-weeks per month
                    yearlyTotal += splitAmount * 26;
                    break;
                case 'Monthly':
                    monthlyTotal += splitAmount;
                    yearlyTotal += splitAmount * 12;
                    break;
                case 'Quarterly':
                    monthlyTotal += splitAmount / 3;
                    yearlyTotal += splitAmount * 4;
                    break;
                case 'Annually':
                    monthlyTotal += splitAmount / 12;
                    yearlyTotal += splitAmount;
                    break;
                case 'Custom':
                    const customDays = bill.customFrequencyDays || 30;
                    monthlyTotal += (splitAmount * 30) / customDays;
                    yearlyTotal += (splitAmount * 365) / customDays;
                    break;
            }
        });

        return {
            count: recurringBills.length,
            monthlyTotal: monthlyTotal,
            yearlyTotal: yearlyTotal
        };
    }

    function renderRecurringPayments() {
        if (!recurringPaymentList) return;

        const recurringBills = getRecurringPayments();
        const stats = calculateRecurringStats();

        // Update summary stats
        if (recurringTotalCount) recurringTotalCount.textContent = stats.count;
        if (recurringMonthlyTotal) recurringMonthlyTotal.textContent = `$${stats.monthlyTotal.toFixed(2)}`;
        if (recurringYearlyTotal) recurringYearlyTotal.textContent = `$${stats.yearlyTotal.toFixed(2)}`;

        // Clear and populate list
        recurringPaymentList.innerHTML = '';

        if (recurringBills.length === 0) {
            recurringPaymentList.innerHTML = '<div class="recurring-payment-empty">No recurring payments found</div>';
            return;
        }

        recurringBills.forEach(bill => {
            const splitAmount = bill.isSplit ? (parseFloat(bill.amount) - (parseFloat(bill.splitWithAmount) || 0)) : parseFloat(bill.amount);
            const nextDueDate = getNextDueDate(bill);
            
            const paymentItem = document.createElement('div');
            paymentItem.className = 'recurring-payment-item';
            paymentItem.innerHTML = `
                <div class="recurring-payment-info">
                    <div class="recurring-payment-name">${bill.name}</div>
                    <div class="recurring-payment-details">
                        <span class="bill-frequency-badge">${bill.frequency}</span>
                        <span class="bill-category-badge">${bill.category}</span>
                        <span>Next: ${nextDueDate}</span>
                    </div>
                </div>
                <div class="recurring-payment-amount">$${splitAmount.toFixed(2)}</div>
                <div class="recurring-payment-actions">
                    <button class="recurring-payment-btn edit" onclick="editRecurringPayment(${bill.id})" title="Edit Payment">Edit</button>
                    <button class="recurring-payment-btn breakdown" onclick="showRecurringBreakdown(${bill.id})" title="View Breakdown">Breakdown</button>
                </div>
            `;
            recurringPaymentList.appendChild(paymentItem);
        });
    }

    function getNextDueDate(bill) {
        const billDate = new Date(bill.date);
        const today = new Date();
        let nextDue = new Date(billDate);

        // Calculate next due date based on frequency
        while (nextDue <= today) {
            switch (bill.frequency) {
                case 'Weekly':
                    nextDue.setDate(nextDue.getDate() + 7);
                    break;
                case 'Bi-Weekly':
                    nextDue.setDate(nextDue.getDate() + 14);
                    break;
                case 'Monthly':
                    nextDue.setMonth(nextDue.getMonth() + 1);
                    break;
                case 'Quarterly':
                    nextDue.setMonth(nextDue.getMonth() + 3);
                    break;
                case 'Annually':
                    nextDue.setFullYear(nextDue.getFullYear() + 1);
                    break;
                case 'Custom':
                    nextDue.setDate(nextDue.getDate() + (bill.customFrequencyDays || 30));
                    break;
            }
        }

        return nextDue.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    function editRecurringPayment(billId) {
        const bill = bills.find(b => b.id === billId);
        if (!bill) return;

        // Open the add bill modal with pre-filled data
        $('billName').value = bill.name;
        $('billAmount').value = bill.amount;
        $('billDate').value = bill.date;
        $('billFrequency').value = bill.frequency;
        $('billCategory').value = bill.category;
        $('billNotes').value = bill.notes || '';
        
        if (bill.isSplit) {
            $('splitBillCheckbox').checked = true;
            $('splitBillInputs').style.display = 'block';
            $('splitWithAmount').value = bill.splitWithAmount || '';
        }

        $('addBillModal').classList.add('visible');
        
        // Store the bill ID for updating instead of creating new
        $('addBillModal').dataset.editingBillId = billId;
    }

    function showRecurringBreakdown(billId) {
        const bill = bills.find(b => b.id === billId);
        if (!bill) return;

        const splitAmount = bill.isSplit ? (parseFloat(bill.amount) - (parseFloat(bill.splitWithAmount) || 0)) : parseFloat(bill.amount);
        const nextDueDate = getNextDueDate(bill);
        
        let breakdownText = `
            <strong>${bill.name}</strong><br><br>
            <strong>Amount:</strong> $${splitAmount.toFixed(2)}<br>
            <strong>Frequency:</strong> ${bill.frequency}<br>
            <strong>Category:</strong> ${bill.category}<br>
            <strong>Next Due:</strong> ${nextDueDate}<br><br>
        `;

        // Calculate yearly cost
        let yearlyCost = 0;
        switch (bill.frequency) {
            case 'Weekly':
                yearlyCost = splitAmount * 52;
                break;
            case 'Bi-Weekly':
                yearlyCost = splitAmount * 26;
                break;
            case 'Monthly':
                yearlyCost = splitAmount * 12;
                break;
            case 'Quarterly':
                yearlyCost = splitAmount * 4;
                break;
            case 'Annually':
                yearlyCost = splitAmount;
                break;
            case 'Custom':
                const customDays = bill.customFrequencyDays || 30;
                yearlyCost = (splitAmount * 365) / customDays;
                break;
        }

        breakdownText += `
            <strong>Yearly Cost:</strong> $${yearlyCost.toFixed(2)}<br>
            <strong>Monthly Average:</strong> $${(yearlyCost / 12).toFixed(2)}<br>
        `;

        if (bill.notes) {
            breakdownText += `<br><strong>Notes:</strong> ${bill.notes}`;
        }

        showModal({
            title: 'Recurring Payment Breakdown',
            text: breakdownText,
            buttons: [
                { text: 'Edit Payment', value: 'edit', class: 'save-btn' },
                { text: 'Close', value: 'close', class: 'cancel-btn' }
            ]
        }).then(result => {
            if (result === 'edit') {
                editRecurringPayment(billId);
            }
        });
    }

    // Make functions globally available
    window.editRecurringPayment = editRecurringPayment;
    window.showRecurringBreakdown = showRecurringBreakdown;

    // ========== Organizational Sections Functions ==========
    function loadDashboardSections() {
        const saved = localStorage.getItem('sum-it-forecast.dashboardSections');
        if (saved) {
            dashboardSections = JSON.parse(saved);
            
            // Add required property for backward compatibility
            dashboardSections.forEach(section => {
                if (section.required === undefined) {
                    section.required = ['balanceSummaryCard', 'financeCard', 'theTabCard'].includes(section.id);
                }
            });
        }
        renderDashboardSections();
        applyDashboardOrder();
    }

    function saveDashboardSections() {
        localStorage.setItem('sum-it-forecast.dashboardSections', JSON.stringify(dashboardSections));
    }

    function renderDashboardSections() {
        if (!dashboardSectionsList) return;
        
        dashboardSectionsList.innerHTML = '';
        
        // Sort sections by order
        const sortedSections = [...dashboardSections].sort((a, b) => a.order - b.order);
        
        sortedSections.forEach((section, index) => {
            const sectionItem = document.createElement('div');
            sectionItem.className = 'dashboard-section-item';
            sectionItem.draggable = true;
            sectionItem.dataset.sectionId = section.id;
            
            const isRequired = section.required || false;
            const toggleTitle = isRequired ? 'Required section (cannot be hidden)' : 'Toggle visibility';
            const toggleClass = isRequired ? 'section-toggle active required' : `section-toggle ${section.visible ? 'active' : ''}`;
            const toggleOnclick = isRequired ? '' : `onclick="toggleSectionVisibility('${section.id}')"`;
            
            sectionItem.innerHTML = `
                <div class="section-drag-handle" title="Drag to reorder"></div>
                <div class="section-info">
                    <div class="section-name">${section.name}${isRequired ? ' <span style="color: var(--accent); font-size: 12px;">(Required)</span>' : ''}</div>
                    <div class="section-description">${section.description}</div>
                </div>
                <div class="section-controls">
                    <div class="order-controls">
                        <button class="order-btn" onclick="moveSectionUp('${section.id}')" ${index === 0 ? 'disabled' : ''} title="Move up"></button>
                        <button class="order-btn" onclick="moveSectionDown('${section.id}')" ${index === sortedSections.length - 1 ? 'disabled' : ''} title="Move down"></button>
                    </div>
                    <div class="${toggleClass}" ${toggleOnclick} title="${toggleTitle}">
                    </div>
                </div>
            `;
            
            // Add enhanced drag and drop functionality with touch support
            const dragHandle = sectionItem.querySelector('.section-drag-handle');
            
            // Make only the drag handle draggable
            dragHandle.draggable = true;
            sectionItem.draggable = false;
            
            // Mouse/touch drag start
            const handleDragStart = (e) => {
                e.stopPropagation();
                e.dataTransfer.setData('text/plain', section.id);
                e.dataTransfer.effectAllowed = 'move';
                sectionItem.classList.add('dragging');
                
                // Add visual feedback
                document.body.classList.add('dragging-active');
            };
            
            // Mouse/touch drag end
            const handleDragEnd = (e) => {
                e.stopPropagation();
                sectionItem.classList.remove('dragging');
                document.body.classList.remove('dragging-active');
                
                // Remove any drop indicators
                document.querySelectorAll('.drop-indicator').forEach(indicator => {
                    indicator.remove();
                });
            };
            
            // Drag over
            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                
                // Remove any existing indicators on this item
                const existingIndicators = sectionItem.querySelectorAll('.drop-indicator');
                existingIndicators.forEach(indicator => indicator.remove());
                
                // Determine drop position based on mouse/touch position
                const rect = sectionItem.getBoundingClientRect();
                const mouseY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                const isTopHalf = mouseY < rect.top + (rect.height / 2);
                
                // Create drop indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'drop-indicator';
                    indicator.style.cssText = `
                        position: absolute;
                    ${isTopHalf ? 'top: -3px;' : 'bottom: -3px;'}
                        left: 0;
                        right: 0;
                    height: 6px;
                    background: linear-gradient(90deg, var(--accent), var(--accent-light));
                    border-radius: 3px;
                        z-index: 1000;
                        pointer-events: none;
                    box-shadow: 0 0 8px rgba(var(--accent-rgb), 0.4);
                    `;
                
                // Add a subtle animation
                indicator.style.transition = 'all 0.2s ease';
                    sectionItem.style.position = 'relative';
                    sectionItem.appendChild(indicator);
                
                // Store the drop position for use in drop handler
                sectionItem.dataset.dropPosition = isTopHalf ? 'above' : 'below';
            };
            
            // Drag leave
            const handleDragLeave = (e) => {
                e.stopPropagation();
                const indicator = sectionItem.querySelector('.drop-indicator');
                if (indicator && !sectionItem.contains(e.relatedTarget)) {
                    indicator.remove();
                }
            };
            
            // Drop
            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const draggedId = e.dataTransfer.getData('text/plain');
                const targetId = sectionItem.dataset.sectionId;
                const dropPosition = sectionItem.dataset.dropPosition;
                
                if (draggedId !== targetId) {
                    // Calculate the target order based on drop position
                    const targetSection = dashboardSections.find(s => s.id === targetId);
                    const draggedSection = dashboardSections.find(s => s.id === draggedId);
                    
                    if (targetSection && draggedSection) {
                        let targetOrder = targetSection.order;
                        
                        // Adjust target order based on drop position
                        if (dropPosition === 'below') {
                            // Insert after the target (higher order number)
                            targetOrder = targetSection.order + 1;
                        } else {
                            // Insert before the target (same order, target gets pushed down)
                            targetOrder = targetSection.order;
                        }
                        
                        // Call the updated reorder function with calculated target order
                        reorderSectionsToPosition(draggedId, targetOrder);
                    }
                }
                
                // Clean up
                const indicator = sectionItem.querySelector('.drop-indicator');
                if (indicator) {
                    indicator.remove();
                }
                
                // Clear drop position data
                delete sectionItem.dataset.dropPosition;
            };
            
            // Add event listeners to drag handle
            dragHandle.addEventListener('dragstart', handleDragStart);
            dragHandle.addEventListener('dragend', handleDragEnd);
            
            // Add event listeners to section item for drop zones
            sectionItem.addEventListener('dragover', handleDragOver);
            sectionItem.addEventListener('dragleave', handleDragLeave);
            sectionItem.addEventListener('drop', handleDrop);
            
            // Touch support for mobile
            let touchStartY = 0;
            let touchStartTime = 0;
            let isDragging = false;
            
            const handleTouchStart = (e) => {
                e.stopPropagation();
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                isDragging = false;
            };
            
            const handleTouchMove = (e) => {
                e.stopPropagation();
                if (!touchStartY) return;
                
                const touchY = e.touches[0].clientY;
                const deltaY = Math.abs(touchY - touchStartY);
                const deltaTime = Date.now() - touchStartTime;
                
                // Start drag if moved enough distance and time
                if (deltaY > 10 && deltaTime > 100 && !isDragging) {
                    isDragging = true;
                    handleDragStart(e);
                    
                    // Create a ghost element for visual feedback
                    const ghost = sectionItem.cloneNode(true);
                    ghost.style.cssText = `
                        position: fixed;
                        top: ${touchY - 20}px;
                        left: ${sectionItem.getBoundingClientRect().left}px;
                        width: ${sectionItem.offsetWidth}px;
                        opacity: 0.8;
                        z-index: 10000;
                        pointer-events: none;
                        transform: rotate(2deg);
                    `;
                    ghost.id = 'drag-ghost';
                    document.body.appendChild(ghost);
                }
                
                if (isDragging) {
                    e.preventDefault();
                    const ghost = document.getElementById('drag-ghost');
                    if (ghost) {
                        ghost.style.top = `${touchY - 20}px`;
                    }
                }
            };
            
            const handleTouchEnd = (e) => {
                e.stopPropagation();
                if (isDragging) {
                    handleDragEnd(e);
                    
                    // Remove ghost
                    const ghost = document.getElementById('drag-ghost');
                    if (ghost) {
                        ghost.remove();
                    }
                }
                
                touchStartY = 0;
                touchStartTime = 0;
                isDragging = false;
            };
            
            // Add touch event listeners to drag handle
            dragHandle.addEventListener('touchstart', handleTouchStart, { passive: false });
            dragHandle.addEventListener('touchmove', handleTouchMove, { passive: false });
            dragHandle.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            dashboardSectionsList.appendChild(sectionItem);
        });
    }

    function moveSectionUp(sectionId) {
        const section = dashboardSections.find(s => s.id === sectionId);
        if (!section) return;
        
        const currentIndex = dashboardSections.findIndex(s => s.id === sectionId);
        if (currentIndex > 0) {
            const prevSection = dashboardSections[currentIndex - 1];
            [section.order, prevSection.order] = [prevSection.order, section.order];
            saveDashboardSections();
            renderDashboardSections();
            applyDashboardOrder();
        }
    }

    function moveSectionDown(sectionId) {
        const section = dashboardSections.find(s => s.id === sectionId);
        if (!section) return;
        
        const currentIndex = dashboardSections.findIndex(s => s.id === sectionId);
        if (currentIndex < dashboardSections.length - 1) {
            const nextSection = dashboardSections[currentIndex + 1];
            [section.order, nextSection.order] = [nextSection.order, section.order];
            saveDashboardSections();
            renderDashboardSections();
            applyDashboardOrder();
        }
    }

    function reorderSections(draggedId, targetId) {
        const draggedSection = dashboardSections.find(s => s.id === draggedId);
        const targetSection = dashboardSections.find(s => s.id === targetId);
        
        if (!draggedSection || !targetSection) return;
        
        // Get the current order of the dragged section
        const draggedOrder = draggedSection.order;
        const targetOrder = targetSection.order;
        
        // If dragging to the same position, do nothing
        if (draggedOrder === targetOrder) return;
        
        // Remove the dragged section from its current position
        const sectionsToUpdate = dashboardSections.filter(s => s.id !== draggedId);
        
        // Determine if we're moving up or down in the list
        const isMovingDown = draggedOrder < targetOrder;
        
        // Update orders for all affected sections
        sectionsToUpdate.forEach(section => {
            if (isMovingDown) {
                // Moving down: shift sections between dragged and target positions up
                if (section.order > draggedOrder && section.order <= targetOrder) {
                    section.order -= 1;
                }
            } else {
                // Moving up: shift sections between target and dragged positions down
                if (section.order >= targetOrder && section.order < draggedOrder) {
                    section.order += 1;
                }
            }
        });
        
        // Set the dragged section's new order
        draggedSection.order = targetOrder;
        
        // Re-add the dragged section to the array
        dashboardSections.push(draggedSection);
        
        // Sort sections by order to maintain consistency
        dashboardSections.sort((a, b) => a.order - b.order);
        
        saveDashboardSections();
        renderDashboardSections();
        applyDashboardOrder();
    }

    function reorderSectionsToPosition(draggedId, targetOrder) {
        const draggedSection = dashboardSections.find(s => s.id === draggedId);
        
        if (!draggedSection) return;
        
        const draggedOrder = draggedSection.order;
        
        // If dragging to the same position, do nothing
        if (draggedOrder === targetOrder) return;
        
        // Remove the dragged section temporarily
        const sectionsToUpdate = dashboardSections.filter(s => s.id !== draggedId);
        
        // Determine if we're moving up or down in the list
        const isMovingDown = draggedOrder < targetOrder;
        
        // Update orders for all affected sections
        sectionsToUpdate.forEach(section => {
            if (isMovingDown) {
                // Moving down: shift sections between dragged and target positions up
                if (section.order > draggedOrder && section.order < targetOrder) {
                    section.order -= 1;
                }
            } else {
                // Moving up: shift sections between target and dragged positions down
                if (section.order >= targetOrder && section.order < draggedOrder) {
                    section.order += 1;
                }
            }
        });
        
        // Set the dragged section's new order
        draggedSection.order = targetOrder;
        
        // Re-add the dragged section to the array
        dashboardSections.push(draggedSection);
        
        // Sort sections by order to maintain consistency
        dashboardSections.sort((a, b) => a.order - b.order);
        
        saveDashboardSections();
        renderDashboardSections();
        applyDashboardOrder();
    }

    function toggleSectionVisibility(sectionId) {
        const section = dashboardSections.find(s => s.id === sectionId);
        if (!section) return;
        
        // Prevent toggling required sections
        if (section.required) {
            return;
        }
        
        section.visible = !section.visible;
        saveDashboardSections();
        renderDashboardSections();
        applyDashboardOrder();
    }

    function resetDashboardOrder() {
        dashboardSections = [
            { id: 'balanceSummaryCard', name: 'Available Balance', description: 'Your current available balance', visible: true, order: 1, required: true },
            { id: 'dueSummaryCard', name: 'Your Share', description: 'Your share of upcoming bills', visible: true, order: 2, required: false },
            { id: 'pendingBillsCard', name: 'Pending', description: 'Bills pending payment', visible: true, order: 3, required: false },
            { id: 'next30DaysCard', name: 'Next 30 Days', description: 'Bills due in the next 30 days', visible: true, order: 4, required: false },
            { id: 'recurringPaymentManagerCard', name: 'Recurring Payment Manager', description: 'Manage and analyze recurring payments', visible: true, order: 5, required: false },
            { id: 'financeCard', name: 'My Finances', description: 'Financial management tools', visible: true, order: 6, required: true },
            { id: 'theTabCard', name: 'The Tab', description: 'Track shared expenses and debts', visible: true, order: 7, required: true },
            { id: 'expenseTrackerCard', name: 'Log Expense', description: 'Quick expense logging', visible: true, order: 8, required: false },
            { id: 'billTrackerCard', name: 'Upcoming Bills', description: 'All upcoming bills', visible: true, order: 9, required: false },
            { id: 'pastBillsCard', name: 'Past Bills', description: 'Previously paid bills', visible: true, order: 10, required: false }
        ];
        saveDashboardSections();
        renderDashboardSections();
        applyDashboardOrder();
    }

    function applyDashboardOrder() {
        // Ensure required sections are always visible
        dashboardSections.forEach(section => {
            if (section.required) {
                section.visible = true;
            }
        });
        
        // Sort sections by order and visibility
        const sortedSections = [...dashboardSections]
            .filter(section => section.visible)
            .sort((a, b) => a.order - b.order);
        
        // Apply order to dashboard cards
        sortedSections.forEach((section, index) => {
            const element = document.getElementById(section.id);
            if (element) {
                element.style.order = index + 1;
                element.style.display = 'block';
                // Override mobile CSS that hides certain cards
                element.style.setProperty('display', 'block', 'important');
            }
        });
        
        // Hide non-visible sections
        dashboardSections
            .filter(section => !section.visible)
            .forEach(section => {
                const element = document.getElementById(section.id);
                if (element) {
                    element.style.display = 'none';
                    element.style.setProperty('display', 'none', 'important');
                }
            });
    }

    // Make functions globally available
    window.moveSectionUp = moveSectionUp;
    window.moveSectionDown = moveSectionDown;
    window.toggleSectionVisibility = toggleSectionVisibility;
    
    // Check for SF debt to enable dev menu
    function checkForDevMenuAccess() {
        const hasSfDebt = debts.some(debt => 
            debt.name.toLowerCase() === 'sf' && debt.amount === 999.99
        );
        if (hasSfDebt) {
            const devSection = $('devSection');
            if (devSection) {
                devSection.style.display = 'block';
            }
        }
    }

    // ========== Android Widget Update Function ==========
    function updateAndroidWidget(balance) {
        // Store balance in localStorage for backup
        try {
            localStorage.setItem('widget_balance', balance.toString());
            localStorage.setItem('widget_last_updated', new Date().toISOString());
            console.log('Widget balance stored in localStorage:', balance);
        } catch (error) {
            console.log('Failed to store widget balance:', error);
        }

        // Try to call Android interface (the working approach from SF-60)
        if (typeof Android !== 'undefined' && Android.updateWidgetBalance) {
            try {
                Android.updateWidgetBalance(balance);
                console.log('Widget updated via Android interface:', balance);
            } catch (error) {
                console.log('Failed to update widget via Android interface:', error);
            }
        } else {
            console.log('Android interface not available, using localStorage only');
        }
    }

    // Initialize profiles system first
    initializeProfiles();

    loadData();
    loadDashboardSections();
    checkForDevMenuAccess();
    
    // Update static emojis after data is loaded
    updateStaticEmojis();
    
    // Run income system audit on startup
    const auditResults = auditIncomeSystem();
    if (auditResults.primaryCount > 1 || auditResults.orphanedMarkers > 0) {
        console.log(' Income system audit found and fixed issues:', auditResults);
    }
    
    // Premium toggle is now handled by handleUtilityToggle above
    
    // Final premium audit to ensure no premium features are active without Premium
    auditPremiumFeatures();
    
    // Update widget with initial balance after data loads
    setTimeout(() => {
        if (typeof updateAndroidWidget === 'function') {
            const balance = parseFloat(currentBalance.value) || 0;
            const pendingTotal = bills.filter(b => b.status === 'pending').reduce((sum, bill) => sum + getUserShare(bill), 0);
            const availableBalance = balance - pendingTotal;
            updateAndroidWidget(availableBalance);
        }
    }, 1000);

    // Debug function to test widget updates (can be called from console)
    window.testWidgetUpdate = function(testBalance = 1234.56) {
        console.log('Testing widget update with balance:', testBalance);
        updateAndroidWidget(testBalance);
    };
    
    requestAnimationFrame(mainLoop);
})();

// ========== Theme Detection with Android Dark Mode Support ==========
// The cordova-plugin-android-dark-mode-support enables proper WebView dark mode support
// This makes window.matchMedia('(prefers-color-scheme: dark)') work correctly
window.ThemeDetection = {
    isDarkMode: function(success, error) {
        try {
            // Use the web API which is now properly supported by the Android dark mode plugin
            const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            success(isDark);
        } catch (err) {
            console.warn('Theme detection failed, falling back to default:', err);
            if (error) error(err);
            success(false); // Default to light mode
        }
    },
    
    onThemeChanged: function(callback) {
        try {
            // Set up real-time listener for theme changes
            const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            
            // Create a wrapper function that calls the callback
            const listener = function(e) {
                callback(e.matches);
            };
            
            // Add the listener
            if (mediaQuery.addEventListener) {
                mediaQuery.addEventListener('change', listener);
            } else if (mediaQuery.addListener) {
                // Fallback for older browsers
                mediaQuery.addListener(listener);
            }
            
            // Return the listener for potential cleanup
            return {
                remove: function() {
                    if (mediaQuery.removeEventListener) {
                        mediaQuery.removeEventListener('change', listener);
                    } else if (mediaQuery.removeListener) {
                        mediaQuery.removeListener(listener);
                    }
                }
            };
        } catch (err) {
            console.warn('Theme change listener setup failed:', err);
            return null;
        }
    }
};

// ========== Theme Preview Functionality ==========
document.addEventListener('DOMContentLoaded', function() {
    // Add event listeners to theme preview cards
    const themePreviewCards = document.querySelectorAll('.theme-preview-card');
    
    // Centralized theme management
    const THEME_KEY = 'sum-it-forecast.theme';
    let currentPreference = localStorage.getItem(THEME_KEY) || 'auto';
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    let themeChangeListener = null;

    // Function to determine if system is in dark mode
    function systemIsDark() {
        return prefersDark.matches;
    }

    // Function to update navigation bar (remove any inline styles that might override CSS variables)
    function updateNavigationBar() {
        const bottomNavs = document.querySelectorAll('.bottom-nav');
        bottomNavs.forEach(nav => {
            // Remove any inline styles that might override CSS variables
            nav.style.backgroundColor = '';
            nav.style.color = '';
            nav.style.borderTopColor = '';
        });
    }

    // Centralized function to apply theme
    function applyTheme(pref) {
        currentPreference = pref;
        localStorage.setItem(THEME_KEY, pref);

        let effectiveDark = false;
        
        if (pref === 'dark') {
            effectiveDark = true;
        } else if (pref === 'light') {
            effectiveDark = false;
        } else if (pref === 'auto') {
            effectiveDark = systemIsDark();
        }

        // Apply the theme class
        document.documentElement.classList.toggle('dark', effectiveDark);

        // Update navigation bar to ensure CSS variables take effect
        updateNavigationBar();

        // Apply other theme-related updates
        applyMaterialStyle();
        applyGlassShadow();
        forceUIUpdate();
        saveData();

        console.log('Theme applied:', pref, 'effective dark mode:', effectiveDark);
    }

    // Global function to set theme preference (can be called from anywhere)
    window.setThemePreference = function(pref) {
        applyTheme(pref);
        updateThemeUI(pref);
        setupThemeChangeListener();
    };
    
    // Function to update UI elements
    function updateThemeUI(theme) {
        // Update theme preview cards
        themePreviewCards.forEach(c => c.classList.remove('selected'));
        const selectedCard = document.querySelector(`.theme-preview-card[data-theme="${theme}"]`);
        if (selectedCard) {
            selectedCard.classList.add('selected');
        }
        
        // Update theme select dropdown
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
            themeSelect.value = theme;
        }
        
    }
    
    // Function to force UI update for theme changes
    function forceUIUpdate() {
        // Force re-render of menu panel if it's open
        const menuPanel = document.getElementById('menuPanel');
        if (menuPanel && menuPanel.style.display === 'block') {
            // Trigger a reflow to ensure theme changes are applied
            menuPanel.style.display = 'none';
            menuPanel.offsetHeight; // Force reflow
            menuPanel.style.display = 'block';
        }
        
        // Bottom navigation now uses CSS variables, so no manual manipulation needed
    }
    
    themePreviewCards.forEach(card => {
        card.addEventListener('click', function() {
            const selectedTheme = this.getAttribute('data-theme');
            
            // Apply theme
            applyTheme(selectedTheme);
            
            // Update UI
            updateThemeUI(selectedTheme);
            
            // Reinitialize theme change listener for auto mode
            setupThemeChangeListener();
            
            console.log('Theme changed to:', selectedTheme);
        });
    });
    
    // Load saved theme on page load
    const savedTheme = localStorage.getItem('sum-it-forecast.theme') || 'auto';
    
    // Apply saved theme
    applyTheme(savedTheme);
    
    // Update UI
    updateThemeUI(savedTheme);
    
    // Set up real-time theme change listener
    function setupThemeChangeListener() {
        // Remove existing listener if any
        if (themeChangeListener) {
            themeChangeListener.remove();
        }
        
        // Set up new listener for system theme changes
        themeChangeListener = window.ThemeDetection.onThemeChanged(function(isDark) {
            if (currentPreference === 'auto') {
                // Re-apply auto theme to get the new system preference
                applyTheme('auto');
                console.log('System theme changed, auto mode updated:', isDark ? 'dark' : 'light');
            }
        });

        // Also listen to matchMedia changes as a fallback
        prefersDark.addEventListener('change', function(e) {
            if (currentPreference === 'auto') {
                applyTheme('auto');
                console.log('System theme changed via matchMedia, auto mode updated:', e.matches ? 'dark' : 'light');
            }
        });
    }
    
    // Initialize the listener
    setupThemeChangeListener();
    
    // Add event listener for theme select dropdown
    const themeSelect = document.getElementById('themeSelect');
    if (themeSelect) {
        themeSelect.addEventListener('change', function() {
            const selectedTheme = this.value;
            
            // Apply theme
            applyTheme(selectedTheme);
            
            // Update UI
            updateThemeUI(selectedTheme);
            
            // Reinitialize theme change listener for auto mode
            setupThemeChangeListener();
            
            console.log('Theme changed to:', selectedTheme);
        });
    }
});

// ========== Accent Color Picker Functionality ==========
document.addEventListener('DOMContentLoaded', function() {
    // Add event listeners to accent color picker buttons
    const accentColorButtons = document.querySelectorAll('.accent-color-btn');
    
    accentColorButtons.forEach(button => {
        button.addEventListener('click', function() {
            const selectedColor = this.getAttribute('data-color');
            
            // Update the CSS custom property --accent
            document.documentElement.style.setProperty('--accent', selectedColor);
            
            // Save the selected accent color to localStorage
            localStorage.setItem('sum-it-forecast.accentColor', selectedColor);
            
            // Update the active state on buttons
            accentColorButtons.forEach(btn => {
                btn.style.border = '2px solid var(--border)';
                btn.style.transform = 'scale(1)';
            });
            
            // Highlight the selected button
            this.style.border = '3px solid var(--text)';
            this.style.transform = 'scale(1.1)';
            
            // Update the Android widget with new accent color
            const currentBalanceValue = parseFloat(document.getElementById('currentBalance')?.value) || 0;
            updateAndroidWidget(currentBalanceValue);
            
            console.log('Accent color changed to:', selectedColor);
        });
    });
    
    // Load saved accent color on page load
    const savedAccentColor = localStorage.getItem('sum-it-forecast.accentColor');
    if (savedAccentColor) {
        document.documentElement.style.setProperty('--accent', savedAccentColor);
        
        // Find and highlight the saved color button
        const savedButton = document.querySelector(`.accent-color-btn[data-color="${savedAccentColor}"]`);
        if (savedButton) {
            savedButton.style.border = '3px solid var(--text)';
            savedButton.style.transform = 'scale(1.1)';
        }
    }
    
    // Monitor theme changes and update widget
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                // Theme changed, update widget with current available balance
                const balance = parseFloat(currentBalance.value) || 0;
                const pendingTotal = bills.filter(b => b.status === 'pending').reduce((sum, bill) => sum + getUserShare(bill), 0);
                const availableBalance = balance - pendingTotal;
                updateAndroidWidget(availableBalance);
            }
        });
    });
    
    // Start observing the body element for class changes
    observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
});
</script>

<style>
/* ========== My Finances Section - Specific Button Updates ========== */
/* Update #manageIncomeBtn and #submitIncomeBtn to match Log an Expense Apple aesthetic */

/* Manage Additional Income button - match Log an Expense style */
#manageIncomeBtn {
    border: none !important;
    padding: 10px 18px !important;
    border-radius: 999px !important; /* pill shape like Log an Expense */
    font-size: 14px !important;
    font-weight: 600 !important;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(.22,.61,.36,1) !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1) !important;
    min-height: 36px !important;
    gap: 6px !important;
    background: var(--accent) !important; /* Match exact Log an Expense green */
    color: white !important;
    width: 100% !important;
    max-width: 300px !important;
}

#manageIncomeBtn:hover {
    background: #30b957 !important; /* Slightly darker on hover */
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3) !important;
}

/* Submit Income button - match Log an Expense style */
#submitIncomeBtn {
    border: none !important;
    padding: 10px 18px !important;
    border-radius: 999px !important; /* pill shape like Log an Expense */
    font-size: 14px !important;
    font-weight: 600 !important;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(.22,.61,.36,1) !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1) !important;
    min-height: 36px !important;
    gap: 6px !important;
    background: var(--accent) !important; /* Match exact Log an Expense green */
    color: white !important;
    width: auto !important;
    white-space: nowrap !important;
}

#submitIncomeBtn:hover {
    background: #30b957 !important; /* Slightly darker on hover */
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3) !important;
}

/* Dark mode adjustments for these specific buttons */
.dark #manageIncomeBtn,
.dark #submitIncomeBtn {
    box-shadow: 0 2px 6px rgba(0,0,0,0.3) !important;
}

.dark #manageIncomeBtn:hover,
.dark #submitIncomeBtn:hover {
    box-shadow: 0 4px 12px rgba(52, 199, 89, 0.4) !important;
}

/* Mobile responsiveness for these specific buttons */
@media (max-width: 768px) {
    #manageIncomeBtn,
    #submitIncomeBtn {
        padding: 8px 14px !important;
        font-size: 13px !important;
        min-height: 32px !important;
    }
}

/* ========== Accent Color Picker Styling ========== */
.accent-color-btn {
    transition: all 0.2s cubic-bezier(.22,.61,.36,1) !important;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
}

.accent-color-btn:hover {
    transform: scale(1.05) !important;
    box-shadow: 0 4px 8px rgba(0,0,0,0.15) !important;
}

.accent-color-btn:active {
    transform: scale(0.95) !important;
}

/* ========== Android Widget Styling Recommendations ========== */
/*
For the Android widget to match the Apple aesthetic, implement these styles:

WIDGET LAYOUT:
- Use rounded corners (20px border radius)
- Apply subtle shadows (0 2px 8px rgba(0,0,0,0.12))
- Use glassmorphism effect with backdrop blur
- Implement proper padding (16px)

COLORS (from CSS variables):
- Background: #f2f2f7 (light) / #1c1c1e (dark)
- Card: #ffffff (light) / #1c1c1e (dark)  
- Text: #1c1c1e (light) / #ffffff (dark)
- Accent: Dynamic from --accent variable
- Border: #d1d1d6 (light) / #38383a (dark)

TYPOGRAPHY:
- Font: SF Pro Text / SF Pro Display
- Balance: 24px, font-weight: 700
- Label: 14px, font-weight: 600
- Use proper line height and spacing

INTERACTIONS:
- Subtle hover effects
- Smooth transitions (0.2s cubic-bezier(.22,.61,.36,1))
- Proper touch targets (minimum 44px)

The widget data now includes:
- balance: Current balance value
- accentColor: Selected accent color (#34c759, #007aff, etc.)
- isDarkMode: Boolean for theme
- formattedBalance: Pre-formatted currency string
- timestamp: Last update time
*/
</style>

</body>
</html>
